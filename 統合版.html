<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>統合版（電子書籍＋プランナー）</title>
<script>
  // preload performance mode to avoid initial heavy paints
  try{ if(localStorage.getItem('performance-mode')==='1'){ document.documentElement.classList.add('performance-mode'); } }catch(e){}
</script>
<style>
  :root{
    --bg:#0b0e13; --panel:#121823; --muted:#98a2b3; --text:#e6eaf0; --brand:#4f8cff; --brand2:#6ee7b7;
    --accent:#ffd166; --danger:#ff6b6b; --ok:#22c55e; --card:#0f1420; --ink:#66d9ef;
    --chip:#0f1624;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#0b0e13,#0c111a 40%,#0b0e13);color:var(--text);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  a{color:var(--brand)}
  .topbar{position:relative;z-index:50;backdrop-filter:blur(12px);background:rgba(10,14,22,.7);border-bottom:1px solid #1b2432}
  .topbar-inner{display:flex;gap:6px;align-items:center;justify-content:space-between;padding:4px 8px;max-width:1200px;margin:auto}
  .brand{display:flex;gap:10px;align-items:center}
  .logo{width:28px;height:28px;border-radius:8px;background:conic-gradient(from 90deg,var(--brand),var(--brand2),var(--accent),var(--brand));box-shadow:0 0 30px rgba(79,140,255,.25)}
  .brand h1{display:none}
  .tabs{display:flex;gap:4px;flex-wrap:wrap;flex:0 0 auto}
  .open-tabs{display:flex;gap:4px;flex-wrap:wrap;align-items:center;flex:1;min-width:120px}
  .open-tab{padding:3px 8px;border:1px solid #243249;background:rgba(14,20,32,.7);border-radius:8px;cursor:pointer;user-select:none;font-size:11px;line-height:1.2;display:inline-flex;align-items:center;gap:6px;max-width:220px}
  .open-tab .label{display:inline-block;max-width:160px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .open-tab .close{border:none;background:transparent;color:#9fb0c9;cursor:pointer;font-size:12px;padding:0 2px;line-height:1}
  .open-tab .close:hover{color:#fff}
  .open-tab.active{border-color:var(--brand);box-shadow:0 0 0 1px rgba(79,140,255,.25) inset;color:#fff;background:rgba(79,140,255,.12)}
  .tab{padding:3px 7px;border:1px solid #223047;background:#0e1420;border-radius:7px;cursor:pointer;user-select:none;font-size:10.5px;line-height:1.1}
  .tab.active{border-color:var(--brand);box-shadow:0 0 0 1px rgba(79,140,255,.2) inset;color:#fff}
  .actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .topbar .btn{padding:4px 8px;border-radius:7px;font-size:11px;min-height:0}
  .btn{padding:6px 10px;border:1px solid #2a384d;background:#0f1726;border-radius:9px;color:#e6eaf0;cursor:pointer;font-size:12px}
  .btn.primary{background:linear-gradient(180deg,#2a63ff,#2148c7);border-color:#3158f0}
  .btn.ghost{background:transparent;border-color:#253144}
  .btn.small{padding:6px 10px;font-size:12px}
  .btn.danger{border-color:#4a2530;background:#23131a}
  .btn:hover{filter:brightness(1.05)}
  .layout{max-width:1200px;margin:16px auto;display:grid;grid-template-columns:260px 1fr;gap:14px;padding:0 14px}
  .panel{background:var(--panel);border:1px solid #1f2a3a;border-radius:14px;box-shadow:0 8px 30px rgba(0,0,0,.2)}
  .side{padding:12px}
  .side h3{margin:4px 0 10px;font-size:13px;color:#b7c0cd}
  .input, select, textarea{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #263449;background:#0d1420;color:#e6eaf0}
  textarea{min-height:72px;resize:vertical}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 9px;border:1px solid #27354a;border-radius:999px;background:var(--chip);color:#cbd5e1;font-size:12px;margin:4px 6px 0 0}
  .toggle{display:flex;gap:6px;flex-wrap:wrap}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:12px;padding:12px}
  .card{background:var(--card);border:1px solid #1b2432;border-radius:14px;overflow:hidden;display:flex;flex-direction:column}
  .thumb{aspect-ratio:3/4;background:#0e1522;display:grid;place-items:center}
  .thumb img{max-width:100%;max-height:100%}
  .meta{padding:10px}
  .title{font-weight:600;margin:0 0 4px}
  .muted{color:var(--muted);font-size:12px}
  .row{display:flex;gap:8px;align-items:center}
  .row.space{justify-content:space-between}
  .hidden{display:none !important}
.viewer{position:relative;display:grid;grid-template-columns:1fr var(--control-width,340px);gap:12px;height:calc(100vh - 160px)}
  .stage-host{position:relative}
  #stageHost{position:relative}
  .stage{position:relative;background:#0a0f18;border:1px solid #1b2432;border-radius:14px;overflow:hidden;touch-action:none;cursor:grab}
  .stage.pan-disabled{cursor:auto}
  .stage-inner{position:relative;min-height:100%;display:grid;place-items:center}
  .stage img{display:block;max-width:100%;height:auto;transition:transform .08s ease-out;will-change:transform;}
  .stage.is-panning{cursor:grabbing}
  body.selecting .stage{cursor:crosshair}
  .stage-buttons{position:absolute;top:4px;display:flex;gap:4px;z-index:14;align-items:center}
  .stage-buttons.right{right:10px}
  .stage-buttons.left{left:10px}
  .mini-menu{background:rgba(10,14,22,.3);color:#e5e9f5;border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:2px 6px;font-size:10.5px;cursor:pointer;user-select:none;transition:background .15s,color .15s,border-color .15s,box-shadow .15s,opacity .15s}
  .mini-menu:hover{background:rgba(10,14,22,.6);opacity:.95}
  .mini-menu.active{background:rgba(79,140,255,.2);color:#fff;border-color:var(--brand);box-shadow:0 0 0 1px rgba(79,140,255,.35);opacity:1;}
  #stageHost.slice-view{max-width:none;width:100%;margin:0 auto;padding:0 4px}
  #stageHost.slice-view .stage,
  #stageHost.slice-view .dual{max-height:70vh;overflow:hidden}
  #stageHost.slice-view .stage-inner{
    align-items:start;
    align-content:start;
    justify-items:center;
  }
  #stageHost.slice-view .stage img,
  #stageHost.slice-view .pane img{
    width:100%;
    max-width:none;
    height:auto;
  }
  body.mainmode2 #stageHost.slice-view{
    max-width:none;
    width:100%;
    margin:0 auto;
    padding:0 12px;
  }
  body.mainmode2 #stageHost.slice-view .stage,
  body.mainmode2 #stageHost.slice-view .dual{
    max-height:calc(100vh - 120px);
  }
  body.mainmode2 #stageHost.slice-view .stage-inner{
    align-items:start;
    align-content:start;
    justify-items:center;
  }
  .interaction-hint{position:absolute;left:16px;top:16px;padding:6px 12px;border-radius:999px;background:rgba(15,23,39,.7);border:1px solid rgba(255,255,255,.1);font-size:12px;z-index:6;transition:opacity .2s ease,transform .2s ease;display:none!important}
  .interaction-hint.hidden{opacity:0;pointer-events:none;transform:translateY(-6px)}
  .stage-arrows{
    position:absolute;
    inset:0;
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    pointer-events:none;
    padding:90px 10px 20px;
    z-index:8
  }
  .stage-arrow{
    pointer-events:auto;
    background:rgba(18,24,36,.38);
    backdrop-filter:blur(14px);
    border:1px solid rgba(255,255,255,.2);
    color:#f0f4ff;
    width:22px;
    height:82px;
    border-radius:14px;
    display:grid;
    place-items:center;
    font-size:18px;
    cursor:pointer;
    transition:background .15s,transform .15s,box-shadow .15s,border-color .15s,opacity .15s;
    box-shadow:0 10px 28px rgba(0,0,0,.28), inset 0 1px 0 rgba(255,255,255,.2);
    opacity:0.8;
  }
  .stage-arrow:hover{
    background:rgba(34,46,66,.52);
    border-color:rgba(255,255,255,.32);
    transform:translateY(-2px);
    box-shadow:0 12px 30px rgba(0,0,0,.38), inset 0 1px 0 rgba(255,255,255,.26);
    opacity:1;
  }
  .pane-arrows{
    position:absolute;
    inset:0;
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    padding:90px 10px 18px;
    pointer-events:none;
    z-index:6
  }
  .pane-arrow{
    pointer-events:auto;
    background:rgba(18,24,36,.38);
    backdrop-filter:blur(14px);
    border:1px solid rgba(255,255,255,.2);
    color:#f0f4ff;
    width:20px;
    height:68px;
    border-radius:12px;
    display:grid;
    place-items:center;
    font-size:16px;
    cursor:pointer;
    transition:background .15s,transform .15s,box-shadow .15s,border-color .15s,opacity .15s;
    box-shadow:0 8px 22px rgba(0,0,0,.28), inset 0 1px 0 rgba(255,255,255,.2);
    opacity:0.82;
  }
  .pane-arrow:hover{
    background:rgba(34,46,66,.52);
    border-color:rgba(255,255,255,.32);
    transform:translateY(-2px);
    box-shadow:0 11px 26px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.25);
    opacity:1;
  }
  .control{background:#0f1522;border:1px solid #1c2636;border-radius:14px;padding:10px;height:100%;display:flex;flex-direction:column}
  .control h3{margin:6px 0 8px}
  .memo-panel{margin-bottom:10px}
  .memo-body{margin-top:6px}
  .memo-body.hidden{display:none}
  .list{padding:10px;max-height:40vh;overflow:auto;border:1px dashed #253146;border-radius:10px}
  .list .item{display:flex;align-items:center;gap:8px;padding:6px;border-radius:8px;cursor:pointer}
  .list .item.active{background:#182132;outline:1px solid #2a3a55}
  .list .item.dragover{outline:2px dashed var(--brand)}
  .split{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .pill{padding:4px 8px;border-radius:999px;background:#0f1624;border:1px solid #223149}
  .star{color:#ffd166}
  .weak{color:#ff6b6b}
  .done{color:#22c55e}
  .toast{position:fixed;right:16px;bottom:16px;background:#0f1726;border:1px solid #2a394f;border-radius:12px;padding:10px 12px;box-shadow:0 10px 30px rgba(0,0,0,.3);min-width:200px}
  .modal{position:fixed;inset:0;background:rgba(4,7,12,.6);backdrop-filter:blur(6px);display:none;align-items:center;justify-content:center;z-index:100}
  .modal.window{background:transparent;backdrop-filter:none;align-items:flex-start;justify-content:flex-end;pointer-events:none;padding:16px;gap:0}
  .modal.window .box{position:fixed;top:76px;right:16px;margin:0;pointer-events:auto;width:min(480px,92vw);padding:14px;border-radius:12px}
  .modal.window.compact .box{width:min(380px,90vw)}
  .modal .box{width:min(640px,90vw);background:#0f1522;border:1px solid #2a394f;border-radius:12px;padding:12px;box-shadow:0 14px 44px rgba(0,0,0,.45)}
  .modal .box h3{margin:0 0 8px}
  .modal .box .box-head{display:flex;align-items:center;justify-content:space-between;margin:-2px 0 10px}
  .modal .box .box-head .mini-menu{padding:4px 8px}
  .snip-preview{background:#0a0f18;border:1px solid #1f2a3a;border-radius:10px;overflow:hidden;padding:6px;display:flex;align-items:center;justify-content:center;margin-bottom:8px}
  .snip-preview{padding:4px;border-radius:10px}
  .snip-preview img{max-width:100%;max-height:220px;display:block;border-radius:8px}
  .snip-meta{font-size:12px;color:var(--muted);margin-bottom:6px}
  .chip-check{display:inline-flex;align-items:center;gap:4px;padding:4px 8px;border:1px solid #2a3a55;border-radius:999px;background:rgba(13,20,32,.7);cursor:pointer;font-size:12px}
  .chip-check input{margin:0}
  .answer-hint{font-size:11px;color:var(--muted);margin-top:4px}
  .tight-row{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
  .answer-target{outline:2px dashed rgba(255,209,102,.8);outline-offset:2px;box-shadow:0 0 0 1px rgba(255,209,102,.35) inset}
  canvas.crop{position:absolute;border:2px dashed var(--accent);pointer-events:none}
  .toolbar{display:flex;gap:6px;flex-wrap:wrap}
  .shelf{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:16px;padding:12px}
  .empty{padding:24px;text-align:center;color:#9fb0c9}
  .viewer{position:relative}
  .book-menu{position:absolute;top:16px;left:16px;width:220px;max-height:72vh;overflow:auto;padding:10px;border-radius:14px;background:rgba(9,14,24,.92);border:1px solid #1f2a3a;box-shadow:0 18px 40px rgba(0,0,0,.55);backdrop-filter:blur(10px);display:none;z-index:40}
  .book-menu.compact{width:200px;padding:8px;border-radius:12px}
  .book-menu.compact .menu-actions{grid-template-columns:1fr;gap:4px}
  .book-menu.compact .menu-actions button{padding:6px 8px;font-size:11px}
  .book-menu.open{display:block}
  .book-menu .menu-header{display:flex;align-items:center;justify-content:space-between;font-size:13px;margin-bottom:6px;cursor:grab}
  .book-menu.dragging .menu-header{cursor:grabbing}
  .book-menu .menu-header button{background:transparent;border:none;color:#93a4c5;font-size:16px;cursor:pointer}
  .book-menu .menu-body{display:flex;flex-direction:column;gap:8px}
  .book-menu .menu-actions{display:grid;grid-template-columns:repeat(2,minmax(80px,1fr));gap:6px}
  .book-menu .menu-actions button{width:100%;padding:6px 0;font-size:12px}
  .book-menu .menu-actions button:disabled{opacity:.4;cursor:not-allowed}
  .book-menu .menu-actions .quick-field{grid-column:span 2;display:flex;gap:6px;align-items:center}
  .book-menu .menu-actions .quick-field input{flex:1;min-width:0}
  .menu-actions .quick-slider{grid-column:span 2;padding:4px 0}
  .menu-actions .quick-slider input{width:100%}
  .linked-answer-bar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:8px 0}
  .linked-answer-chips{display:flex;gap:6px;flex-wrap:wrap}
  .answer-chip{display:flex;align-items:center;gap:4px;padding:4px 8px;border-radius:999px;border:1px solid #253146;background:rgba(13,20,32,.65);font-size:12px}
  .answer-chip strong{max-width:160px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .answer-chip button{background:transparent;border:none;color:#9fb0c9;font-size:12px;cursor:pointer;padding:0 4px;border-radius:6px}
  .answer-chip button:hover{color:#fff;background:rgba(255,255,255,.12)}
  @media(max-width:600px){
    .answer-chip strong{max-width:120px}
  }
  .linked-answer-manage{display:flex;gap:6px;align-items:center;margin:6px 0 10px}
  .linked-answer-manage select{flex:1}
  .linked-answer-manage button{flex:0 0 auto}
  .memo-window{position:absolute;top:160px;left:16px;width:220px;max-height:60vh;padding:10px;border-radius:14px;background:rgba(9,14,24,.92);border:1px solid #1f2a3a;box-shadow:0 18px 40px rgba(0,0,0,.55);backdrop-filter:blur(10px);display:none;flex-direction:column;gap:8px;z-index:38}
  .memo-window.open{display:flex}
  .memo-window.dragging{cursor:grabbing}
  .memo-window textarea{min-height:150px;resize:vertical;background:#0d1420;border:1px solid #263449;border-radius:10px;color:#e6eaf0;padding:10px}
  .compare-window{position:absolute;top:120px;right:16px;width:420px;min-width:240px;min-height:220px;max-width:80vw;max-height:90vh;padding:4px;border-radius:12px;background:rgba(8,12,20,.95);border:1px solid #1f2a3a;box-shadow:0 18px 40px rgba(0,0,0,.55);backdrop-filter:blur(10px);display:none;flex-direction:column;gap:4px;z-index:39;resize:both;overflow:hidden}
  .compare-window.open{display:flex}
  .compare-window.minimized{display:none !important}
  .compare-window.transparent{opacity:0.45;transition:opacity .15s ease}
  .compare-window.transparent:hover{opacity:0.65}
  .compare-window.dragging{cursor:grabbing}
  .compare-window .compare-body{flex:1;display:flex;flex-direction:column;gap:4px;min-height:0}
  .compare-window .compare-header{display:flex;align-items:center;gap:6px;padding:0 4px;cursor:grab;user-select:none}
  .compare-window.dragging .compare-header{cursor:grabbing}
  .compare-window .compare-title{font-size:12px;color:#cfd7eb;flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .compare-window .compare-quick{display:flex;align-items:center;gap:4px;flex-wrap:nowrap;justify-content:flex-end;white-space:nowrap;overflow-x:auto;padding:2px 0}
  .compare-window .compare-quick::-webkit-scrollbar{display:none}
  .compare-window .compare-controls{display:flex;align-items:center;gap:4px;flex-wrap:nowrap;justify-content:space-between;padding:2px 4px}
  .compare-window .compare-stage{background:#05070d;border:1px solid #1b2432;border-radius:10px;padding:4px;display:flex;align-items:center;justify-content:center;min-height:0;flex:1;position:relative;cursor:grab;overflow:hidden;touch-action:none}
  .compare-window .compare-stage.grabbing{cursor:grabbing}
  .compare-window .compare-stage.pan-disabled{cursor:auto}
  .compare-window .compare-stage img{width:100%;height:100%;object-fit:contain;border-radius:8px;display:block;transform-origin:center center;transition:transform .08s ease-out;pointer-events:none}
  .compare-window .compare-placeholder{color:var(--muted);font-size:12px;text-align:center}
  .compare-window:not(.has-book) .compare-stage img{display:none}
  .compare-window.has-book .compare-placeholder{display:none}
  .compare-window .mini-menu,
  .compare-window .btn.small{padding:3px 8px;font-size:10px;line-height:1.1}
  .compare-window .input{padding:4px 6px;font-size:11px}
  
  .memo-header{display:flex;align-items:center;justify-content:space-between;font-size:13px;cursor:grab}
  .memo-header button{background:transparent;border:none;color:#93a4c5;font-size:16px;cursor:pointer}
  img{ -webkit-user-drag:none; user-select:none }
  .stage, .stage *{ -webkit-user-drag:none; user-select:none }
  /* box viewer: maximize stage usage in non-slice mode */
  .box-viewer .stage-host,
  .box-viewer #stageSingle,
  .box-viewer .stage-inner{height:100%}
  .box-viewer #stageHost:not(.slice-view) .stage{display:grid}
  .box-viewer #stageHost:not(.slice-view) .stage-inner{align-items:stretch;justify-items:stretch}
  .box-viewer #stageHost:not(.slice-view) #pageImg{
    width:100%;
    height:100%;
    max-width:none;
    max-height:none;
    object-fit:contain;
  }
  .mainmode .side,.mainmode2 .side{display:none}
  .mainmode .layout,.mainmode2 .layout{grid-template-columns:1fr}
  .mainmode .tabs,.mainmode2 .tabs{display:none}
  .mainmode #main,.mainmode2 #main{padding:0}
  .mainmode2 .viewer{grid-template-columns:1fr}
  .mainmode2 .control{display:none}
  .mainmode2 .topbar{position:relative;top:auto;background:rgba(10,14,22,.35);border-bottom:1px solid rgba(255,255,255,.08);box-shadow:none}
  .mainmode2 .topbar-inner{padding:4px 8px;gap:6px;max-width:900px}
  .mainmode2 .brand{gap:6px}
  .mainmode2 .logo{width:20px;height:20px}
  .mainmode2 .brand h1{font-size:12px}
  .mainmode2 .actions{gap:4px}
  .mainmode2 .actions .btn{padding:4px 8px;font-size:11px;border-radius:8px}
  .mainmode2 .actions .btn.primary{padding:4px 10px}
  .mainmode2 .brand h1{display:none}
  .mainmode2 .layout{max-width:100%;width:100%;padding:0;margin:0 auto;}
  .mainmode2 .viewer{height:calc(100vh - 48px);}
  body.reading .side{display:none}
  body.reading .layout{grid-template-columns:1fr;max-width:100%;width:100%;padding:0 8px}
  body.reading .viewer{grid-template-columns:1fr var(--control-width,340px);}
  body.reading.mainmode2 .viewer{grid-template-columns:1fr;}
  .floatbar{position:absolute;left:12px;right:12px;bottom:12px;display:flex;gap:8px;justify-content:center;z-index:20}
  .floatbar .btn{backdrop-filter:blur(6px);background:rgba(16,24,38,.35);border-color:#2a3a55;transition:background .15s, opacity .15s}
  .selecting .stage{touch-action:none}
  .stage-buttons .page-badge{
    position:static;
    z-index:14;
    background:rgba(255,255,255,.85);
    border:1px solid rgba(0,0,0,.12);
    border-radius:999px;
    padding:2px 6px;
    font-size:10px;
    letter-spacing:.02em;
    line-height:1.2;
    margin-left:4px;
    color:#000;
  }
  .control-resizer{position:absolute;top:0;bottom:0;right:calc(var(--control-width,340px) + 6px);width:12px;margin-right:-6px;cursor:col-resize;z-index:16;background:transparent}
  .statebar{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px}
  .statebar .toggle{gap:6px}
  .tag{display:inline-flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;border:1px solid #2a3a55;background:#0f1624;font-size:12px}
  .tag .x{cursor:pointer;opacity:.8}
  .thumbGrid{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px}
  .thumbCell{border:1px solid #253146;border-radius:8px;padding:4px;display:flex;flex-direction:column;gap:4px}
  @media(max-width:1100px){
    .layout{display:flex;flex-direction:column}
    .topbar-inner{flex-wrap:wrap;justify-content:flex-start}
    .actions{width:100%}
    .actions .search{flex:1;min-width:200px}
  }
  @media(max-width:720px){
    .viewer{grid-template-columns:1fr}
  }
  .thumbCell img{width:100%;height:auto;display:block}
  .thumbCell .small{font-size:11px;color:#9fb0c9}

  .dual {position:relative; display:flex; gap:10px; align-items:stretch; padding:10px}
  .pane {position:relative; flex:1; background:#0a0f18; border:1px solid #1b2432; border-radius:14px; overflow:hidden; display:grid; place-items:center; cursor:grab}
  .pane.is-panning{cursor:grabbing}
  .pane img{display:block; max-width:100%; height:auto;transition:transform .08s ease-out;will-change:transform}
  .pane .pane-badge{position:absolute; top:8px; right:10px; background:rgba(16,24,38,.5); border:1px solid #2a3a55; border-radius:999px; padding:3px 8px; font-size:12px}
  .pane .pane-controls{display:none}
  .dual .pane canvas.crop{position:absolute}
  .pane.hidden-content img{opacity:0; filter:blur(3px)}
  .pane.hidden-content::after{content:'右側は非表示';position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(8,11,22,.8);color:#e5e9f5;font-size:14px;font-weight:600;letter-spacing:.05em;border-radius:inherit}
  .pane-divider{position:absolute;top:8px;bottom:8px;width:12px;margin-left:-6px;border-radius:12px;background:rgba(255,255,255,.05);cursor:col-resize;display:flex;align-items:center;justify-content:center;z-index:13;transition:background .15s}
  .pane-divider::after{content:'';width:2px;height:40px;background:rgba(255,255,255,.5);border-radius:1px}
  .pane-divider.active{background:rgba(79,140,255,.18)}


  /* Translucent inputs on overlay bars */
  .floatbar .input, .pane-controls .input{
    background: rgba(13,20,32,.35);
    border-color: #2a3a55;
    outline: none;
  }
  .floatbar .input::placeholder, .pane-controls .input::placeholder{ color:#9fb0c9 }
  .floatbar .input:focus, .pane-controls .input:focus{
    background: rgba(13,20,32,.6);
    border-color: #3a5aa0;
  }
  /* Hover brings a bit more opacity for better readability */
  .floatbar:hover .btn{ background: rgba(16,24,38,.55); }
  .pane-controls:hover{ background: rgba(16,24,38,.5); }
  /* Reset flash */
  .reset-anim{
    animation:resetFlash .32s ease, resetScale .28s ease;
  }
  @keyframes resetFlash{
    0%{box-shadow:0 0 0 0 rgba(79,140,255,.0);}
    40%{box-shadow:0 0 0 10px rgba(79,140,255,.35);}
    100%{box-shadow:0 0 0 0 rgba(79,140,255,.0);}
  }
  @keyframes resetScale{
    0%{transform:scale(1.02);}
    100%{transform:scale(1);}
  }

  /* Performance friendly mode (viewerは除外) */
  .performance-mode body{background:#0b0e13!important;}
  .performance-mode body::before,
  .performance-mode body::after{content:none!important;display:none!important;}
  /* プランナー/設定/リストなど限定でアニメ無効＆軽量化 */
  .performance-mode #plannerApp *,
  .performance-mode #plannerApp *::before,
  .performance-mode #plannerApp *::after,
  .performance-mode #settingsView *,
  .performance-mode #libraryView *,
  .performance-mode #boxesView *,
  .performance-mode #uploadView *,
  .performance-mode #sidebar *,
  .performance-mode .topbar,
  .performance-mode .topbar *{
    animation-duration:0.01ms!important;
    animation-iteration-count:1!important;
    transition-duration:0ms!important;
    transition-delay:0ms!important;
    box-shadow:none!important;
    backdrop-filter:none!important;
  }
  .performance-mode .tabs::before,
  .performance-mode #plannerApp .tabs::before{display:none!important;}
  .performance-mode .logo{box-shadow:none!important;}
  .performance-mode #plannerApp main,
  .performance-mode .tab-content{animation:none!important;}
  .performance-mode .tabs,
  .performance-mode #plannerApp .tabs{backdrop-filter:none!important;}
  .performance-mode .hud-pill,
  .performance-mode .btn,
  .performance-mode button{box-shadow:none!important;}
  .performance-mode .notification{animation:none!important;}
  .performance-mode .drag-hint{display:none!important;}
  .performance-mode .timeline-container{border-color:#1f2a3a!important;}
  .performance-mode .timeline-container .timeline-scroll{scroll-behavior:auto!important;}


</style>

  <!-- Planner styles -->
<style data-planner-style="1" media="not all">
  :root{
    --bg:#0d1015; --fg:#e8e8eb; --muted:#a7adba;
    --face:#0d1015; --ring:#222834; --tickMajor:#3a4150; --tickMinor:#262c37;
    --handH:#ffffff; --handM:#e2e5ea; --handS:#4da3ff; --accent:#4da3ff;
    --arcShadow: drop-shadow(0 2px 3px rgba(0,0,0,.4));
    --ease-soft:cubic-bezier(.4,0,.2,1);
    --ease-emph:cubic-bezier(.15,.75,.25,1);
    --dur-xs:.18s;
    --dur-sm:.28s;
    --dur-md:.45s;
    --dur-lg:.8s;
    --glass:rgba(15,18,26,.7);
  }
  .theme-minimal{}
  .theme-classic{
    --bg:#f1f2f6; --fg:#1b1f28; --muted:#5a6477;
    --face:#f7f8fb; --ring:#cfd6e3; --tickMajor:#7e8aa1; --tickMinor:#b6bfce;
    --handH:#1b1f28; --handM:#2b3240; --handS:#d1382f; --accent:#2b7cff;
  }
  .theme-neon{
    --bg:#0a0b10; --fg:#eaf2ff; --muted:#8aa7ff;
    --face:#0a0b10; --ring:#162036; --tickMajor:#1e2a4a; --tickMinor:#121a30;
    --handH:#eaf2ff; --handM:#b7c7ff; --handS:#00eaff; --accent:#7b5cff;
    --arcShadow: drop-shadow(0 0 8px rgba(123,92,255,.75)) drop-shadow(0 0 14px rgba(0,234,255,.45));
  }
  .theme-paper{
    --bg:#faf7f0; --fg:#2c2a25; --muted:#6f6a5e;
    --face:#fffaf0; --ring:#e7ddc5; --tickMajor:#b9ac8e; --tickMinor:#d9cfb7;
    --handH:#2c2a25; --handM:#444136; --handS:#b76e79; --accent:#b76e79;
  }
  .theme-glass{
    --bg:#0b0f14; --fg:#e7f2ff; --muted:#9fb7d6;
    --face:rgba(255,255,255,.06); --ring:#2a3544; --tickMajor:#3b4a61; --tickMinor:#253042;
    --handH:#e7f2ff; --handM:#bcd4f3; --handS:#79c2ff; --accent:#79c2ff;
    backdrop-filter: blur(8px);
  }
  .theme-pudding{
    --bg:#fef6e4; --fg:#5a4a2f; --muted:#a89268;
    --face:#fff9ea; --ring:#e6d5a8; --tickMajor:#d4b77a; --tickMinor:#e8ddb8;
    --handH:#5a4a2f; --handM:#7a6a4f; --handS:#d4a574; --accent:#d4a574;
  }
  .theme-metal{
    --bg:#1a1d23; --fg:#e4e7ec; --muted:#8a909d;
    --face:#2a2d35; --ring:#3f454f; --tickMajor:#5a616e; --tickMinor:#434952;
    --handH:#e4e7ec; --handM:#c5c9d1; --handS:#4db8ff; --accent:#4db8ff;
  }

  *{box-sizing:border-box}
  html,body{height:100%; margin:0}
  body{
    background:var(--bg); color:var(--fg);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    overflow-x:hidden;
    min-height:100%;
  }
  body::before, body::after{
    content:""; position:fixed; inset:0; pointer-events:none; z-index:-1;
    background:radial-gradient(circle at 20% 20%, rgba(77,163,255,.15), transparent 45%),
               radial-gradient(circle at 80% 0%, rgba(123,92,255,.18), transparent 40%);
    animation: bgPulse 18s ease-in-out infinite alternate;
    opacity:.8;
  }
  body::after{
    background:radial-gradient(circle at 70% 80%, rgba(0,214,255,.12), transparent 45%),
               radial-gradient(circle at 10% 60%, rgba(255,255,255,.06), transparent 35%);
    mix-blend-mode:screen;
    filter:blur(30px);
    animation-duration:24s;
  }
  @keyframes bgPulse{
    0%{transform:translate3d(-2%,0,0) scale(1);}
    50%{transform:translate3d(2%,1%,0) scale(1.05);}
    100%{transform:translate3d(-1%,0,0) scale(1);}
  }
  #plannerApp header{padding:12px; border-bottom:1px solid var(--ring); position:sticky; top:0; backdrop-filter:blur(10px); background:rgba(5,7,12,.85); z-index:50; animation:slideDown var(--dur-md) var(--ease-soft) both;}
  #plannerApp header h1{margin:0; font-size:18px; font-weight:700; letter-spacing:.05em}
  #plannerApp .tabs{
    display:flex; gap:4px; padding:8px 12px; background:rgba(0,0,0,.25); flex-wrap:wrap;
    position:relative; width:100%; margin:0 auto 8px; border-bottom:1px solid rgba(255,255,255,.05);
    backdrop-filter:blur(18px);
  }
  #plannerApp .tabs::before{
    content:""; position:absolute; inset:0; background:linear-gradient(90deg, rgba(255,255,255,.06), transparent 30%, transparent 70%, rgba(255,255,255,.06));
    opacity:.35; pointer-events:none;
  }
  #plannerApp .tab{
    padding:10px 16px; cursor:pointer; border-radius:10px;
    background:transparent; color:var(--muted); border:none; font-size:14px;
    position:relative; transition:color var(--dur-xs) var(--ease-soft), transform var(--dur-xs) var(--ease-soft);
  }
  #plannerApp .tab::after{
    content:""; position:absolute; inset:0; border-radius:inherit;
    background:rgba(255,255,255,.08); opacity:0; transition:opacity var(--dur-xs) var(--ease-soft); pointer-events:none;
  }
  #plannerApp .tab:hover{color:var(--fg); transform:translateY(-1px);}
  #plannerApp .tab:hover::after{opacity:.35;}
  #plannerApp .tab.active{color:#fff;}
  #plannerApp .tab.active::after{opacity:.9; background:linear-gradient(120deg, rgba(77,163,255,.45), rgba(123,92,255,.4));}
  #plannerApp .tab-indicator{
    position:absolute; bottom:4px; left:0; height:3px; background:linear-gradient(90deg, var(--accent), rgba(255,255,255,.88));
    border-radius:999px; transform-origin:left center; transition:transform var(--dur-sm) var(--ease-emph), width var(--dur-sm) var(--ease-emph);
    pointer-events:none; z-index:2;
  }
  /* Unify planner header/tabs with slim reader style */
  #plannerApp > header{display:none;}
  #tabs{
    display:flex;
    gap:4px;
    flex-wrap:wrap;
    flex:0 0 auto;
    padding:0;
    background:transparent;
    border:none;
  }
  #plannerApp .tabs{
    padding:6px 4px;
    background:transparent;
    border-bottom:1px solid #1b2432;
    gap:4px;
    flex-wrap:wrap;
  }
  #plannerApp .tab{
    padding:4px 10px;
    border:1px solid #223047;
    background:#0e1420;
    border-radius:7px;
    color:var(--muted);
    font-size:12px;
  }
  #plannerApp .tab::after{display:none;}
  #plannerApp .tab.active{
    border-color:var(--brand);
    box-shadow:0 0 0 1px rgba(79,140,255,.2) inset;
    color:var(--text);
    background:rgba(79,140,255,.12);
  }
  #plannerApp .tab-indicator{display:none!important;}
  /* Keep reader top tabs slim even when planner styles are enabled */
  #tabs .tab{
    padding:3px 7px;
    border:1px solid #223047;
    background:#0e1420;
    border-radius:7px;
    cursor:pointer;
    user-select:none;
    font-size:10.5px;
    line-height:1.1;
  }
  #tabs .tab::after{display:none;}
  #tabs .tab.active{
    border-color:var(--brand);
    box-shadow:0 0 0 1px rgba(79,140,255,.2) inset;
    color:#fff;
    background:rgba(79,140,255,.12);
  }
  #plannerApp .tab-content{
    display:none; padding:12px; opacity:0; transform:translateY(12px);
    transition:opacity var(--dur-sm) var(--ease-soft), transform var(--dur-sm) var(--ease-soft);
  }
  #plannerApp .tab-content.active{display:block; opacity:1; transform:translateY(0);}
  #plannerApp main{max-width:1200px; margin:0 auto; padding:40px 0 80px; animation:fadeSlideUp var(--dur-lg) var(--ease-soft) both;}
  @media (max-width:640px){
    #plannerApp main{padding-top:56px;}
  }

  .card{
    background:rgba(255,255,255,.04); border:1px solid var(--ring); border-radius:14px; padding:16px; margin-bottom:12px;
    position:relative; overflow:hidden;
    transition:transform var(--dur-sm) var(--ease-soft), border-color var(--dur-xs), box-shadow var(--dur-sm);
    animation:cardFloat var(--dur-lg) var(--ease-soft) both;
  }
  .card::after{
    content:""; position:absolute; inset:-40% 0 60% 0;
    background:linear-gradient(120deg, rgba(255,255,255,.08), transparent 65%);
    opacity:.08; transform:translateX(-80%); filter:blur(8px);
    transition:transform 1.6s var(--ease-soft), opacity 1.4s var(--ease-soft); pointer-events:none;
  }
  .card:hover{transform:translateY(-6px); border-color:rgba(255,255,255,.2); box-shadow:0 18px 45px rgba(0,0,0,.45);}
  .card:hover::after{transform:translateX(-10%); opacity:.2;}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px}
  select,input[type="time"],input[type="text"],input[type="color"],input[type="number"]{
    background:rgba(0,0,0,.3); color:var(--fg); border:1px solid var(--ring); border-radius:8px; padding:8px; font-size:14px;
    transition:border-color var(--dur-xs), box-shadow var(--dur-xs);
  }
  select:focus-visible,
  input:focus-visible{
    outline:none; border-color:rgba(77,163,255,.8);
    box-shadow:0 0 0 2px rgba(77,163,255,.25), 0 12px 26px rgba(0,0,0,.45);
  }
  button,.btn{
    appearance:none; border:none; border-radius:999px; padding:10px 16px; font-size:13px; color:#fff; background:var(--accent);
    cursor:pointer; position:relative; overflow:hidden;
    transition:transform var(--dur-xs) var(--ease-soft), box-shadow var(--dur-xs), background var(--dur-xs), color var(--dur-xs);
    box-shadow:0 8px 20px rgba(77,163,255,.35);
  }
  button::before,.btn::before{
    content:""; position:absolute; inset:0; background:linear-gradient(120deg, rgba(255,255,255,.35), transparent 60%);
    opacity:0; transition:opacity var(--dur-xs); pointer-events:none;
  }
  button:hover::before,.btn:hover::before{opacity:.7;}
  button:hover,.btn:hover{transform:translateY(-1px) scale(1.01);}
  button:active,.btn:active{transform:translateY(1px) scale(.98);}
  button.ghost{background:transparent; color:var(--fg); border:1px solid var(--ring); box-shadow:none;}
  button.ghost::before{display:none;}
  button.danger{background:#e74c3c; box-shadow:0 10px 20px rgba(231,76,60,.45);}
  .list{display:flex; flex-direction:column; gap:8px; max-height:300px; overflow:auto}
  .item{
    display:flex; align-items:center; justify-content:space-between; gap:8px; background:rgba(0,0,0,.2); border:1px solid var(--ring); border-radius:10px; padding:10px;
    transition:transform var(--dur-xs), border-color var(--dur-xs), box-shadow var(--dur-xs);
  }
  .item:hover{transform:translateX(6px); border-color:rgba(255,255,255,.2); box-shadow:0 10px 24px rgba(0,0,0,.35);}
  .badge{width:14px; height:14px; border-radius:50%; flex-shrink:0}
  .tiny{font-size:12px; color:var(--muted)}
  .notification{
    animation:slideDown var(--dur-sm) var(--ease-emph) both, pulseGlow 2.4s ease-out infinite;
  }
  @keyframes fadeSlideUp{
    0%{opacity:0; transform:translate3d(0,16px,0);}
    100%{opacity:1; transform:translate3d(0,0,0);}
  }
  @keyframes cardFloat{
    0%{opacity:0; transform:translateY(14px);}
    60%{opacity:1;}
    100%{opacity:1; transform:translateY(0);}
  }
  @keyframes slideDown{
    0%{opacity:0; transform:translateY(-10px);}
    100%{opacity:1; transform:translateY(0);}
  }
  @keyframes pulseGlow{
    0%,100%{box-shadow:0 12px 30px rgba(77,163,255,.25);}
    50%{box-shadow:0 14px 40px rgba(255,255,255,.35);}
  }
  @keyframes fadeBackdrop{
    0%{opacity:0;}
    100%{opacity:1;}
  }
  @keyframes popCard{
    0%{opacity:0; transform:translateY(12px) scale(.95);}
    60%{opacity:1;}
    100%{opacity:1; transform:translateY(0) scale(1);}
  }
  @media (prefers-reduced-motion:reduce){
    *, *::before, *::after{
      animation-duration:.01ms !important;
      animation-iteration-count:1 !important;
      transition-duration:.01ms !important;
    }
    body::before, body::after{animation:none;}
  }
  .clock-wrap{position:relative; display:flex; align-items:center; justify-content:center; padding:20px; position:relative; flex-direction:column}
  svg{max-width:500px; width:100%; height:auto; display:block; touch-action:none}
  .drag-hint{position:absolute; bottom:30px; background:var(--accent); color:#fff; padding:10px 16px; border-radius:8px; font-size:18px; font-weight:700; pointer-events:none; opacity:0; transition:.2s}
  .drag-hint.show{opacity:1}
  #plannerDirectGroup{pointer-events:none;}
  #plannerDirectGroup .guide-fill{fill:rgba(77,163,255,0.28);filter:url(#shadow);}
  #plannerDirectGroup .guide-edge{fill:none;stroke:rgba(255,255,255,0.95);stroke-width:2.2;stroke-dasharray:10 6;}
  .planner-direct-label{
    position:absolute;
    top:16px;
    right:16px;
    padding:6px 12px;
    border-radius:10px;
    background:rgba(6,10,18,.65);
    border:1px solid rgba(255,255,255,.2);
    color:var(--fg);
    font-size:13px;
    font-weight:700;
    letter-spacing:.02em;
    display:none;
    backdrop-filter:blur(6px);
  }
  
  .timer-item,.sw-item{
    background:rgba(0,0,0,.2); border:1px solid var(--ring); border-radius:10px; padding:16px; margin-bottom:8px;
    transition:transform var(--dur-sm), border-color var(--dur-xs), box-shadow var(--dur-sm);
    animation:fadeSlideUp var(--dur-md) var(--ease-soft) both;
  }
  .timer-item:hover,.sw-item:hover{transform:translateY(-4px); border-color:rgba(255,255,255,.2); box-shadow:0 12px 28px rgba(0,0,0,.35);}
  .timer-display{font-size:clamp(56px, 9vw, 120px); font-weight:700; text-align:center; margin:16px 0; font-family:monospace; line-height:1.05; letter-spacing:0.04em}
  .timer-gauge{width:100%; height:10px; background:rgba(0,0,0,.3); border-radius:10px; overflow:hidden; margin:12px 0; position:relative}
  .timer-gauge-fill{height:100%; transition:width .3s linear; position:absolute; left:0; top:0}
  .timer-btns{display:flex; gap:8px; justify-content:center; flex-wrap:wrap}
  
  .sw-time{font-size:32px; font-weight:700; text-align:center; margin:8px 0; font-family:monospace}
  .sw-btns{display:flex; gap:8px; justify-content:center; margin-top:12px}
  
  .status-bar{background:rgba(0,0,0,.3); border:1px solid var(--ring); border-radius:10px; padding:12px; margin-top:12px; text-align:center; font-size:16px; font-weight:700; font-family:monospace}
  
  @keyframes pulse{0%,100%{transform:scale(1)} 50%{transform:scale(1.05)}}
  @keyframes shake{0%,100%{transform:translateX(0)} 25%{transform:translateX(-10px)} 75%{transform:translateX(10px)}}
  .alert{animation:pulse .5s ease-in-out 4}
  .notification{position:fixed; top:20px; left:50%; transform:translateX(-50%); background:var(--accent); color:#fff; padding:16px 32px; border-radius:12px; font-weight:700; z-index:1000; box-shadow:0 4px 20px rgba(0,0,0,.3); animation:shake .5s}
  
  .study-panel{display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:12px}
  .study-stat{background:rgba(0,0,0,.2); border:1px solid var(--ring); border-radius:10px; padding:12px; text-align:center}
  .study-stat-value{font-size:28px; font-weight:700; color:var(--accent); margin:4px 0}
  .study-stat-label{font-size:11px; color:var(--muted)}
  
  .page-grid{display:grid; grid-template-columns:repeat(auto-fill, minmax(60px, 1fr)); gap:6px; margin-top:12px; max-height:300px; overflow:auto; padding:4px}
  .page-btn{padding:12px 8px; background:rgba(0,0,0,.2); border:1px solid var(--ring); border-radius:8px; cursor:pointer; transition:.2s; text-align:center; font-size:13px}
  .page-btn:hover{background:rgba(0,0,0,.4)}
  .page-btn.completed{background:var(--accent); color:#fff; border-color:var(--accent)}
  
  .timeline-container{position:relative; width:100%; height:120px; background:rgba(0,0,0,.3); border:1px solid var(--ring); border-radius:10px; overflow:hidden; margin-top:12px}
  .timeline-scroll{position:relative; width:100%; height:100%; overflow-x:auto; scroll-behavior:smooth}
  
  .hp-bar-container{
    width:100%; max-width:400px; margin:16px auto; display:none;
  }
  .hp-bar-container.active{display:block}
  .hp-bar-outer{
    width:100%; height:40px; background:rgba(0,0,0,.5); border:3px solid #2a5;
    border-radius:20px; overflow:hidden; position:relative;
    box-shadow: inset 0 2px 8px rgba(0,0,0,.6), 0 0 20px rgba(42,170,85,.4);
  }
  .hp-bar-bg{
    position:absolute; width:100%; height:100%;
    background: linear-gradient(180deg, rgba(255,255,255,.1) 0%, transparent 50%, rgba(0,0,0,.2) 100%);
  }
  .hp-bar-fill{
    position:absolute; height:100%; transition:width .5s cubic-bezier(0.4, 0, 0.2, 1);
    background: linear-gradient(90deg, #2a5 0%, #3c7 50%, #2a5 100%);
    box-shadow: inset 0 2px 4px rgba(255,255,255,.3), 0 0 15px rgba(42,170,85,.8);
  }
  .hp-bar-afterglow{
    position:absolute; height:100%; transition:all .8s ease-out; opacity:0;
    background: linear-gradient(90deg, transparent, #6f8);
    pointer-events:none;
  }
  .hp-bar-shine{
    position:absolute; height:100%; width:200%; top:0; left:-200%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,.4), transparent);
    animation: shine 3s infinite;
  }
  @keyframes shine{
    0%{left:-200%}
    50%{left:100%}
    100%{left:100%}
  }
  @keyframes hpShake{
    0%,100%{transform:translateX(0)}
    25%{transform:translateX(-4px)}
    50%{transform:translateX(4px)}
    75%{transform:translateX(-2px)}
  }
  .hp-bar-container.hit{animation:hpShake .4s}
  .hp-bar-label{
    text-align:center; margin-top:8px; font-weight:700; font-size:14px;
    text-shadow: 0 0 10px rgba(42,170,85,.8);
  }

  .pomo-panel{margin-top:12px; padding:12px; border:1px solid var(--ring); border-radius:12px; background:rgba(255,255,255,.04); display:none; flex-direction:column; gap:10px}
  .pomo-panel input[type="number"]{width:80px; padding:6px; border-radius:8px; border:1px solid var(--ring); background:rgba(0,0,0,.15); color:var(--fg)}
  .pomo-panel .row{width:100%; margin-bottom:0}
  .pomo-panel .btn{flex:1}
  #pomoClockHUD{margin-top:8px; display:none}
  .nl-row{position:relative}
  
  
  .page-complete-btn.active{display:block}
  .page-complete-btn:hover{transform:translateY(-2px); box-shadow: 0 12px 32px rgba(102,126,234,.6)}
  .page-complete-btn:active{transform:translateY(0)}
  
  @media(max-width:600px){
    .study-panel{grid-template-columns:1fr}
  }

#hpBarContainer{display:none!important}

  .study-overall{
    font-family:monospace;
    font-weight:700;
    text-align:center;
    margin:0 0 8px 0;
    padding:8px 12px;
    border:1px solid var(--ring);
    border-radius:10px;
    background:rgba(0,0,0,.2);
  }


  /* --- Numberline (integrated) --- */
  .nl-row{display:grid;grid-template-columns:64px 1fr;gap:10px;align-items:center;margin:14px 0;padding-bottom:30px;animation:fadeSlideUp var(--dur-md) var(--ease-soft) both}
  .nl-hourBadge{justify-self:end;font-size:13px;color:var(--muted);background:rgba(255,255,255,.04);border:1px solid var(--ring);border-radius:12px;padding:6px 8px;letter-spacing:.04em}
  .nl-rail{position:relative;height:130px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0)) , rgba(0,0,0,.25);border:1px solid var(--ring);padding:18px 12px 14px;overflow:hidden}
  .nl-scale{position:relative;height:70px;margin:0;border-radius:10px}
  .nl-lane{position:absolute;left:18px;right:18px;top:0;bottom:0}
  .nl-track{position:absolute;left:0;right:0;top:50%;height:4px;background:rgba(255,255,255,.14);transform:translateY(-50%);border-radius:999px;box-shadow:0 2px 8px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.04)}
  .nl-ticks{position:absolute;left:0;right:0;top:0;bottom:0}
  .nl-tick{ position:absolute; width:1px; background: var(--tickMinor, rgba(255,255,255,0.35)); top:40%; height:28%; transform:translateX(-50%);}
  .nl-tick.major{ width:3px; background: var(--tickMajor, rgba(255,255,255,0.85)); top:30%; height:40%; }
  .nl-label{position:absolute;top:0;transform:translateX(-50%);font-size:12px;color:var(--muted);font-variant-numeric:tabular-nums}
  .nl-cap{position:absolute;top:36px;left:18px;right:18px;display:flex;justify-content:space-between;color:var(--muted);font-size:12px}
  .nl-hand{position:absolute;top:8px;bottom:8px;width:0;transform:translateX(-50%);pointer-events:none; z-index:3}
  .nl-hand.m::after{content:"";display:block;height:100%;width:6px;border-radius:3px;background:var(--accent)}
  .nl-hand::after{ transform:translateX(-50%); }
  .nl-hand.s::after{content:"";display:block;height:100%;width:4px;border-radius:2px;background:var(--handS)}
  .nl-hand.s::after{ margin-left:-0.5px }
  .nl-bars{position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none;z-index:2}
  .nl-bar{
    position:absolute;
    top:50%;
    height:100%;
    transform:translateY(-50%);
    border-radius:8px;
    color:#0b1020;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    font-weight:700;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    backdrop-filter:saturate(120%) blur(.3px);
    border:1px solid rgba(255,255,255,.35);
    box-shadow:0 6px 16px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.2);
  }
  .nl-direct-guide{
    position:absolute;
    top:8px;
    bottom:8px;
    border-radius:12px;
    background:linear-gradient(90deg, rgba(77,163,255,.2), rgba(77,163,255,.45));
    border:1px dashed rgba(77,163,255,.85);
    box-shadow:0 12px 24px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.12);
    opacity:0;
    pointer-events:none;
    transition:opacity .12s ease;
  }
  .nl-direct-guide.show{opacity:1;}


  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}
  /* === Timer HUD (no bars/gauges) === */
  .hud-pill{display:inline-block; padding:6px 10px; border-radius:8px; 
    background: var(--ring); color: var(--muted); border:1px solid rgba(255,255,255,.15);
    font-size:14px; letter-spacing:.02em; user-select:none; cursor:pointer;
    font-variant-numeric: tabular-nums; box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
  }
  .hud-pill.strong{ color: var(--fg); background: rgba(77,163,255,0.12); border-color: rgba(77,163,255,0.35); }
  .hud-pill.warn{ color:#eab308; border-color:rgba(234,179,8,.35); }
  .hud-pill.danger{ color:#f97316; border-color:rgba(249,115,22,.35); }
  .hud-note{ font-size:12px; color: var(--muted); margin-left:6px }


  /* Planner ETA position tweak: a bit higher than numberline */
  #plEta.nl-eta{ bottom:-8px; }


  /* === Horror Theme (Upgraded) === */
  .theme-horror{
    --bg:#09090b; --face:#111114; --ring:rgba(255,255,255,0.06);
    --muted:#e5e5ea; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.18); --tickMajor:rgba(255,255,255,0.92);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible; }
  .theme-horror #clock{ filter:drop-shadow(0 4px 18px rgba(193,18,31,.35)); }

  /* Aura: slow rotating radial glow */
  .theme-horror .h-aura{
    position:absolute; inset:-12% -12% -12% -12%; border-radius:50%;
    background: conic-gradient(from 0deg, rgba(193,18,31,.12), transparent 35%, rgba(255,255,255,.06) 50%, transparent 65%, rgba(193,18,31,.12));
    animation: aura-rot 18s linear infinite, aura-flicker 2.6s ease-in-out infinite;
    filter: blur(18px);
    pointer-events:none;
  }
  @keyframes aura-rot { to{ transform: rotate(360deg); } }
  @keyframes aura-flicker { 0%,100%{ opacity:.35 } 45%{ opacity:.6 } 55%{ opacity:.25 } }

  /* Fog layers: slow parallax drift */
  .theme-horror .h-fog{
    position:absolute; inset:-8% -8% -8% -8%; pointer-events:none;
    background: radial-gradient(60% 60% at 40% 50%, rgba(255,255,255,.035), transparent 60%),
                radial-gradient(50% 50% at 70% 60%, rgba(255,255,255,.03), transparent 65%),
                radial-gradient(70% 70% at 30% 40%, rgba(255,255,255,.04), transparent 70%);
    filter: blur(16px);
    opacity:.55;
  }
  .theme-horror .h-fog.f1{ animation:fog-drift-1 40s linear infinite; }
  .theme-horror .h-fog.f2{ animation:fog-drift-2 55s linear infinite; opacity:.35; filter: blur(22px); }
  @keyframes fog-drift-1 { 0%{ transform:translate3d(-2%,0,0) } 50%{ transform:translate3d(2%,1%,0) } 100%{ transform:translate3d(-2%,0,0) } }
  @keyframes fog-drift-2 { 0%{ transform:translate3d(1%,0,0) } 50%{ transform:translate3d(-3%,-1%,0) } 100%{ transform:translate3d(1%,0,0) } }

  /* Vignette & scanlines */
  .theme-horror .h-vignette{
    position:absolute; inset:-10% -10% -10% -10%; pointer-events:none;
    background: radial-gradient(60% 60% at 50% 50%, transparent 55%, rgba(0,0,0,.35) 85%, rgba(0,0,0,.55));
    mix-blend-mode:multiply; animation:vignette-pulse 6s ease-in-out infinite;
  }
  @keyframes vignette-pulse{ 0%,100%{ opacity:.85 } 50%{ opacity:.7 } }

  .theme-horror .h-scan{
    position:absolute; inset:0; pointer-events:none;
    background: repeating-linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.03) 1px, transparent 2px, transparent 4px);
    opacity:.18; animation:scan-flicker 3.5s linear infinite;
  }
  @keyframes scan-flicker{ 0%,100%{ opacity:.14 } 40%{ opacity:.22 } 55%{ opacity:.1 } }

  /* Subtle hand heartbeat (minute & second hands) */
  .theme-horror #hands{ transform-origin:250px 250px; animation:hand-breath 5.2s ease-in-out infinite; }
  @keyframes hand-breath{ 0%,100%{ transform:scale(1)} 50%{ transform:scale(1.01)} }

/* Planner top complete button */
  #pageCompleteBtn{position:absolute; top:8px; left:50%; transform:translateX(-50%); z-index:50;}
  /* Unify design with numberline button */
  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .nl-digital-toggle{display:inline-flex;gap:6px;flex-wrap:wrap}
  .nl-digital-toggle .btn.active{background:var(--accent);color:#fff}
  .nl-digital-row,.nl-digital-inline{display:flex;justify-content:center;align-items:center;width:100%}
  .nl-digital-row{padding:18px;margin:10px 0;border-radius:16px;border:1px solid var(--ring);background:rgba(255,255,255,.04);box-shadow:inset 0 1px 0 rgba(255,255,255,.08)}
  .nl-digital-inline{margin:-6px auto 6px;padding:0 12px;width:100%;max-width:520px}
  .nl-digital-face{display:flex;align-items:flex-end;gap:10px;font-family:'SFMono-Regular','Roboto Mono',monospace;font-weight:700;
    color:var(--fg);padding:14px 28px;border-radius:18px;background:linear-gradient(135deg, rgba(77,163,255,.25), rgba(123,92,255,.15));
    box-shadow:0 14px 26px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.4)}
  .nl-digital-inline .nl-digital-face{padding:10px 20px;border-radius:14px;box-shadow:0 10px 20px rgba(0,0,0,.28), inset 0 1px 0 rgba(255,255,255,.35)}
  .nl-digital-time{font-size:48px;letter-spacing:0.12em}
  .nl-digital-inline .nl-digital-time{font-size:34px}
  .nl-digital-sec{font-size:20px;opacity:.85}
  @media (max-width:640px){
    .nl-digital-time{font-size:38px}
    .nl-digital-inline .nl-digital-time{font-size:30px}
  }
  .nl-planner-clock-wrap{
    margin:-8px 0 32px;
    padding:0;
    border:none;
    background:transparent;
    box-shadow:none;
  }
  .nl-planner-clock-host{
    display:flex;
    justify-content:center;
    align-items:center;
    pointer-events:none;
    overflow:visible;
  }
  .nl-planner-clock-host .clock-wrap{
    margin:0;
    transform:translateY(-28px) scale(1.24);
    transform-origin:top center;
    pointer-events:none;
  }
  .nl-planner-clock-host .clock-wrap svg{
    max-width:620px;
  }
  .nl-planner-clock-host #hint,
  .nl-planner-clock-host #plEta,
  .nl-planner-clock-host .hud-pill,
  .nl-planner-clock-host #plannerDirectLabel{
    display:none !important;
  }
  @media (max-width:640px){
    .nl-planner-clock-host .clock-wrap{transform:translateY(-14px) scale(.95); margin:0;}
  }
  .btn.ghost.active{background:var(--accent);color:#fff;border-color:transparent}
  .quick-dialog-backdrop{position:fixed;inset:0;background:rgba(5,8,12,.75);display:flex;align-items:center;justify-content:center;z-index:4000;padding:12px;animation:fadeBackdrop var(--dur-md) var(--ease-soft) both}
  .quick-dialog-card{background:var(--face);color:var(--fg);border:1px solid var(--ring);border-radius:18px;min-width:280px;max-width:min(420px,92vw);padding:22px;box-shadow:0 30px 60px rgba(0,0,0,.55);animation:popCard var(--dur-sm) var(--ease-emph) both}
  .quick-dialog-card h3{margin:0 0 12px 0;font-size:18px}
  .quick-dialog-card label{display:block;font-size:12px;color:var(--muted);margin-top:12px}
  .quick-dialog-card input[type="text"],
  .quick-dialog-card input[type="datetime-local"],
  .quick-dialog-card input[type="color"]{width:100%;margin-top:4px;padding:8px;border-radius:10px;border:1px solid var(--ring);background:rgba(0,0,0,.15);color:var(--fg)}
  .quick-dialog-card input[type="color"]{height:42px;padding:4px}
  .quick-dialog-actions{display:flex;gap:10px;margin-top:18px}
  .quick-dialog-actions button{flex:1}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Unify planner complete button with numberline style */
  #pageCompleteBtn.btn.small{
    background: var(--ring);
    color: var(--muted);
    border:1px solid rgba(255,255,255,.35);
    box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.2);
    backdrop-filter: saturate(140%) blur(6px);
    -webkit-backdrop-filter: saturate(140%) blur(6px);
  }

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}



  /* === Overall Study Indicators === */
  .overall-study{
    display:flex; gap:12px; align-items:center; justify-content:center;
    margin:8px 0 4px 0; padding:14px 14px 12px; /* 少し下げる */
    border:1px solid var(--ring); border-radius:12px;
    background:rgba(0,0,0,.25); font-weight:700; font-family:monospace;
  }
  .overall-study #osiRemain{ color:var(--accent); font-size:14px; transform:translateY(2px) }
  .overall-study #osiEnd{ color:var(--fg); font-size:14px; transform:translateY(2px) }

  .nl-overall{
    position:absolute; right:10px; top:14px; /* 少し下げる */
    padding:10px 12px 8px; border:1px solid var(--ring); border-radius:10px;
    background:rgba(0,0,0,.35); font-weight:700; font-size:13px; line-height:1.1;
    pointer-events:auto; z-index:5;
  }
  .nl-overall div, .nl-overall small{ transform:translateY(1px) }
  .nl-overall small{ display:block; color:var(--muted); font-weight:600; margin-top:2px }


  /* Inline overall indicator next to per-event ETA in numberline */
  .nl-overall-inline{
    position:absolute;
    bottom:-24px; /* align with nl-eta */
    left: calc(50% + 120px); /* a bit to the right of centered eta */
    transform: translateX(0);
    font-size:12px;
    font-weight:700;
    background: rgba(0,0,0,.28);
    border: 1px solid var(--ring);
    border-radius: 8px;
    padding: 3px 6px;
    color: var(--fg);
    pointer-events:auto;
    z-index: 6;
    font-family: monospace;
  }

</style><style data-planner-style="1" media="not all">.nl-bars{padding:0;border:0;box-sizing:border-box;left:0;right:0;top:0;bottom:0;pointer-events:none;z-index:2;}
  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Planner top complete button */
  #pageCompleteBtn{position:absolute; top:8px; left:50%; transform:translateX(-50%); z-index:50;}
  /* Unify design with numberline button */
  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Unify planner complete button with numberline style */
  #pageCompleteBtn.btn.small{
    background: var(--ring);
    color: var(--muted);
    border:1px solid rgba(255,255,255,.35);
    box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.2);
    backdrop-filter: saturate(140%) blur(6px);
    -webkit-backdrop-filter: saturate(140%) blur(6px);
  }

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}


</style><style data-planner-style="1" media="not all">.nl-tick,.nl-label{transform:translateX(-50%);} .nl-hand{transform:translateX(-50%);}
  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Planner top complete button */
  #pageCompleteBtn{position:absolute; top:8px; left:50%; transform:translateX(-50%); z-index:50;}
  /* Unify design with numberline button */
  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Unify planner complete button with numberline style */
  #pageCompleteBtn.btn.small{
    background: var(--ring);
    color: var(--muted);
    border:1px solid rgba(255,255,255,.35);
    box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.2);
    backdrop-filter: saturate(140%) blur(6px);
    -webkit-backdrop-filter: saturate(140%) blur(6px);
  }

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}


</style><style data-planner-style="1" media="not all">/* nl-bar override */.nl-bar{height:22px;position:absolute;top:56%;transform:translateY(-50%);border-radius:6px;}
  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Planner top complete button */
  #pageCompleteBtn{position:absolute; top:8px; left:50%; transform:translateX(-50%); z-index:50;}
  /* Unify design with numberline button */
  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Unify planner complete button with numberline style */
  #pageCompleteBtn.btn.small{
    background: var(--ring);
    color: var(--muted);
    border:1px solid rgba(255,255,255,.35);
    box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.2);
    backdrop-filter: saturate(140%) blur(6px);
    -webkit-backdrop-filter: saturate(140%) blur(6px);
  }

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}


</style><style data-planner-style="1" media="not all">
/* numberline tick visibility tweaks */
.nl-scale{ position: relative; }
.nl-lane{ position:absolute; left:18px; right:18px; top:0; bottom:0; }
.nl-tick{ position:absolute; width:1px; background: var(--tickMinor, rgba(255,255,255,0.35)); top:40%; height:28%; transform:translateX(-50%);}
.nl-tick.major{ width:3px; background: var(--tickMajor, rgba(255,255,255,0.85)); top:30%; height:40%; }

  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Planner top complete button */
  #pageCompleteBtn{position:absolute; top:8px; left:50%; transform:translateX(-50%); z-index:50;}
  /* Unify design with numberline button */
  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Unify planner complete button with numberline style */
  #pageCompleteBtn.btn.small{
    background: var(--ring);
    color: var(--muted);
    border:1px solid rgba(255,255,255,.35);
    box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.2);
    backdrop-filter: saturate(140%) blur(6px);
    -webkit-backdrop-filter: saturate(140%) blur(6px);
  }

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}


</style><style data-planner-style="1" media="not all">
/* 仮（Aqua風）テーマ */
body.kari{
  --bg: radial-gradient(120% 100% at 50% 0%, #eef6ff 0%, #d9ecff 40%, #cfe8ff 60%, #c5e2ff 80%, #badaff 100%);
  --card: rgba(255,255,255,0.65);
  --muted: #366080;
  --tickMinor: rgba(70,100,130,0.35);
  --tickMajor: rgba(40,80,120,0.9);
}
body.kari{ background: var(--bg); }
body.kari .panel{ background: var(--card); backdrop-filter: blur(8px) saturate(140%); box-shadow: 0 10px 30px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.6); }
body.kari #clock{ filter: drop-shadow(0 10px 18px rgba(0,0,0,0.15)); }
body.kari .badge{ border: 1px solid rgba(255,255,255,0.6); }
body.kari .tab.active{ background: linear-gradient(#ffffff,#eaf4ff); border: 1px solid rgba(0,0,0,0.08); box-shadow: inset 0 1px 0 rgba(255,255,255,0.8); }
body.kari .tab{ background: linear-gradient(#f6fbff,#e8f3ff); border: 1px solid rgba(0,0,0,0.06); }
body.kari .nl-bar{ box-shadow: inset 0 1px 2px rgba(255,255,255,0.85), inset 0 -1px 2px rgba(0,0,0,0.12), 0 6px 14px rgba(0,0,0,0.18); }

  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Planner top complete button */
  #pageCompleteBtn{position:absolute; top:8px; left:50%; transform:translateX(-50%); z-index:50;}
  /* Unify design with numberline button */
  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Unify planner complete button with numberline style */
  #pageCompleteBtn.btn.small{
    background: var(--ring);
    color: var(--muted);
    border:1px solid rgba(255,255,255,.35);
    box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.2);
    backdrop-filter: saturate(140%) blur(6px);
    -webkit-backdrop-filter: saturate(140%) blur(6px);
  }

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}


</style><style data-planner-style="1" media="not all">
/* migrated from テーマ.html */
@keyframes waterRipple {
  0% { background-position: 0 0, 0 0; }
  100% { background-position: 200% 0, -200% 0; }
}

@keyframes auroraFlow {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

body.water{
  --bg1: radial-gradient(120% 90% at 50% -10%, rgba(180,220,255,0.9), rgba(120,180,255,0.5), rgba(30,120,200,0.35));
  --bg2: repeating-linear-gradient( to right, rgba(255,255,255,0.15) 0 2px, rgba(0,0,0,0) 2px 6px );
  background-image: var(--bg1), var(--bg2);
  background-size: 200% 100%, 300% 100%;
  animation: waterRipple 18s linear infinite;
}

body.water .panel{ background: rgba(255,255,255,0.6); backdrop-filter: blur(10px) saturate(140%); box-shadow: 0 8px 24px rgba(0,0,0,0.2); }

body.aurora{
  background: linear-gradient(120deg, #091540, #102a68, #183a72, #2a628f, #1b998b, #6ed0ff);
  background-size: 400% 400%;
  animation: auroraFlow 22s ease-in-out infinite;
}

body.aurora .panel{ background: rgba(255,255,255,0.5); backdrop-filter: blur(12px) saturate(140%); }

  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Planner top complete button */
  #pageCompleteBtn{position:absolute; top:8px; left:50%; transform:translateX(-50%); z-index:50;}
  /* Unify design with numberline button */
  .btn.small{font-size:12px;padding:6px 10px;border-radius:6px; background:var(--ring); color:var(--muted); border:1px solid rgba(255,255,255,.15); cursor:pointer}

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}

  .btn.small:hover{filter:brightness(1.1)}
  .btn.small.danger{background:#5b1e1e;color:#fff;border-color:#9e2a2a}

  /* Unify planner complete button with numberline style */
  #pageCompleteBtn.btn.small{
    background: var(--ring);
    color: var(--muted);
    border:1px solid rgba(255,255,255,.35);
    box-shadow: 0 6px 16px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.2);
    backdrop-filter: saturate(140%) blur(6px);
    -webkit-backdrop-filter: saturate(140%) blur(6px);
  }

  /* === Horror Theme === */
  .theme-horror{
    --bg:#0b0b0d; --face:#121216; --ring:rgba(255,255,255,0.08);
    --muted:#d0cfd4; --accent:#c1121f; --handH:#fafafa; --handM:#ff3b3b; --handS:#ff3b3b;
    --tickMinor:rgba(255,255,255,0.15); --tickMajor:rgba(255,255,255,0.9);
  }
  .theme-horror .clock-wrap{ position:relative; overflow:visible;}
  .theme-horror #clock{ filter:drop-shadow(0 2px 8px rgba(193,18,31,.5)); }
  .theme-horror .bleed{ position:absolute; left:50%; top:-8px; width:6px; height:18px; background:#c1121f;
    border-radius:3px; transform:translateX(-50%); animation:drip 2.2s infinite ease-in; box-shadow:0 0 8px rgba(193,18,31,.6); }
  @keyframes drip { 0%{ transform:translate(-50%,0) scaleY(0.6);} 70%{ transform:translate(-50%,20px) scaleY(1);} 100%{ transform:translate(-50%,0) scaleY(0.6);} }
  .theme-horror .pulse { position:absolute; inset:auto 0 0 0; height:2px; background:linear-gradient(90deg, transparent, rgba(193,18,31,.65), transparent);
    animation:pulse 1.8s infinite ease-in-out; }
  @keyframes pulse { 0%,100%{ opacity:.2 } 50%{ opacity:1 } }


  .nl-eta{position:absolute;left:50%;bottom:-24px;transform:translateX(-50%);padding:4px 14px;border-radius:999px;background:rgba(0,0,0,.35);color:var(--muted);font-size:16px;font-weight:700;line-height:1;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.08);pointer-events:none}
  .nl-fullscreen{position:fixed;inset:0;background:var(--bg);
    display:flex;align-items:center;justify-content:center;z-index:9999;padding:24px}
  .nl-fullscreen .nl-row{width:min(1400px,95vw)}
  .nl-row{padding-bottom:30px}
  .nl-fs-close{position:fixed;top:16px;right:16px;background:var(--ring);border:1px solid rgba(255,255,255,.1);
    color:var(--muted);border-radius:999px;padding:8px 12px;font-size:14px}


</style><style data-planner-style="1" media="not all">
/* --- injected: place delay counter to the right of remaining time --- */
.remaining-time-row{display:flex;align-items:center;gap:.5rem;flex-wrap:nowrap}
.remaining-time-row .delay-counter{font-variant-numeric:tabular-nums;opacity:.85}
.remaining-time-row .delay-counter.negative{color:inherit}
.remaining-time-row .delay-counter.positive{}
/* compact on mobile */
@media (max-width: 540px){
  .remaining-time-row{gap:.35rem}
}
</style><style data-planner-style="1" media="not all">
/* upload→変更ボタンUI */
.sound-file-hidden{ display:none !important; }
.sound-file-btn{ padding:6px 10px; border-radius:8px; border:1px solid #666; background:transparent; cursor:pointer; }
.sound-file-btn:hover{ opacity:.85; }
</style>
</head>
<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand"><div class="logo"></div><h1>統合版（電子書籍＋プランナー）</h1></div>
      <div class="tabs" id="tabs">
        <div class="tab active" data-tab="library">ライブラリ</div>
        <div class="tab" data-tab="boxes">ボックス</div>
        <div class="tab" data-tab="uploader">新しい本を作成</div>
        <div class="tab" data-tab="settings">設定/バックアップ</div>
        <div class="tab" data-tab="planner">📅 プランナー</div>
      </div>
      <div class="open-tabs" id="openTabs"></div>
      <div class="actions">
        <div class="search">
          <input id="searchInput" class="input" placeholder="本・タグ・ボックスを検索…" />
        </div>
        <button class="btn ghost" id="mainModeBtn">メイン</button>
        <button class="btn primary" id="quickMake">+ 本を作成</button>
      </div>
    </div>
  </div>

  <div class="layout" id="readerLayout">
    <aside class="panel side" id="sidebar">
      <h3>表示・並べ替え</h3>
      <div class="toggle">
        <button class="btn small" data-view="grid">棚ビュー</button>
        <button class="btn small" data-view="list">リスト</button>
        <button class="btn small" data-view="tree">ファイル風</button>
      </div>
      <div class="hr" style="height:1px;background:#1d2738;margin:10px 0"></div>
      <label class="helper">並べ替え</label>
      <select id="sortSelect">
        <option value="-createdAt">新しい順</option>
        <option value="title">タイトルA→Z</option>
        <option value="pages">ページ数多い順</option>
      </select>
      <div class="hr" style="height:1px;background:#1d2738;margin:10px 0"></div>
      <h3>タグ/ジャンル</h3>
      <div id="tagArea"></div>
      <div class="hr" style="height:1px;background:#1d2738;margin:10px 0"></div>
      <h3>フォルダ</h3>
      <div class="tree" id="folderTree"></div>
      <div class="hr" style="height:1px;background:#1d2738;margin:10px 0"></div>
      <h3>その他</h3>
      <label class="row" style="gap:8px;align-items:center;font-size:13px">
        <input type="checkbox" id="showAnswersToggle" />
        解答も表示
        <span class="muted" id="hiddenAnswersInfo" style="font-size:11px"></span>
      </label>
    </aside>

    <main class="panel" id="main">
      <div id="libraryView">
        <div id="libraryGrid" class="grid"></div>
        <div id="libraryShelf" class="shelf hidden"></div>
        <div id="libraryList" class="list hidden"></div>
      </div>

      <div id="boxesView" class="hidden" style="padding:10px">
        <div class="toolbar" style="margin-bottom:8px">
          <input id="boxSearch" class="input" placeholder="ボックス/切り取り検索…" style="max-width:260px">
          <select id="boxSort" class="input" style="max-width:180px">
            <option value="-createdAt">新しい順</option>
            <option value="name">名前A→Z</option>
            <option value="-items">件数多い順</option>
            <option value="-weak">苦手が多い順</option>
          </select>
          <label class="row" style="gap:6px"><input id="onlyWeakBox" type="checkbox"> 苦手含むのみ</label>
          <button class="btn small" id="newBoxToolbar">+ 新規ボックス</button>
        </div>
        <div class="grid" id="boxGrid"></div>
        <div id="boxEmpty" class="empty hidden">まだボックスがありません。選択モードで切り取り後、「新規ボックス」を作成してください。</div>
      </div>

      <div id="uploadView" class="hidden" style="padding:14px 14px 20px;">
        <div class="row space" style="margin-bottom:10px">
          <h3 style="margin:0">本を作成</h3>
          <div class="muted">プレビュー側でドラッグ＆ドロップで順番変更できます</div>
        </div>
        <div class="split">
          <div class="panel" style="padding:12px">
            <div class="row" style="gap:10px;align-items:center;margin-bottom:8px">
              <input id="bookTitle" class="input" placeholder="タイトル" />
            </div>
            <div class="row" style="gap:8px;margin-bottom:8px">
              <input id="bookTags" class="input" placeholder="タグ（カンマ区切り）" />
            </div>
            <div class="row" style="gap:8px;margin-bottom:8px">
              <input id="bookFolder" class="input" placeholder="フォルダ" />
            </div>
            <div class="row" style="gap:8px;margin-bottom:8px">
              <input type="file" id="imagePicker" accept="image/*" multiple />
              <button class="btn ghost" id="clearImages">クリア</button>
            </div>
            <div id="dropZone" class="list" style="height:220px">ここに画像をドロップ…</div>
            <div class="row space" style="margin-top:8px">
              <div class="muted">サムネをドラッグして順番変更</div>
              <button class="btn primary" id="createBook">保存</button>
            </div>
          </div>
          <div class="panel" style="padding:12px">
            <h3 style="margin:0 0 6px">プレビュー（並べ替え可）</h3>
            <div id="previewArea" class="grid" style="grid-template-columns:repeat(auto-fill,minmax(120px,1fr));max-height:420px;overflow:auto"></div>
          </div>
        </div>
      </div>

      <div id="settingsView" class="hidden" style="padding:14px;display:grid;gap:12px">
        <div class="panel" style="padding:12px">
          <h3>バックアップ</h3>
          <div class="row" style="gap:8px;flex-wrap:wrap">
            <button class="btn" id="exportBtn">データを書き出し(JSON)</button>
            <input type="file" id="importFile" accept="application/json" class="hidden" />
            <button class="btn" id="importBtn">データを読み込み(JSON)</button>
          </div>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
            <button class="btn danger" id="resetAllBtn">全データをリセット</button>
            <button class="btn danger ghost" id="resetLibraryBtn">ライブラリのみリセット</button>
            <button class="btn danger ghost" id="resetBoxesBtn">ボックスのみリセット</button>
          </div>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
            <button class="btn ghost" id="importBookSingleBtn">本をインポート(1件)</button>
            <input type="file" id="importBookSingleFile" accept="application/json" class="hidden" />
            <button class="btn ghost" id="importBoxSingleBtn">ボックスをインポート(1件)</button>
            <input type="file" id="importBoxSingleFile" accept="application/json" class="hidden" />
          </div>
          <p class="muted">※ IndexedDB に保存。端末変更時はエクスポート/インポートを使用。</p>
        </div>
      <div class="panel" style="padding:12px">
        <h3>クイックメニュー設定</h3>
        <p class="muted">メニューに表示する操作を選択してください。</p>
        <div id="menuActionSettings" class="list" style="max-height:220px;overflow:auto"></div>
      </div>
        <div class="panel" style="padding:12px">
          <h3>パフォーマンス</h3>
          <label class="row" style="gap:8px;align-items:center">
            <input type="checkbox" id="perfModeToggle">
            軽量モードを有効にする
          </label>
          <p class="muted" style="margin:4px 0 0">アニメーションやぼかしを抑え、低スペック環境での負荷を軽減します。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>キー操作設定</h3>
          <p class="muted">矢印やズームキーの割り当てやスピードを調整できます。</p>
          <div class="grid" style="grid-template-columns:1fr 1fr;gap:8px" id="keyNavSettingsForm">
            <label>移動量(px)<input id="keyPanStep" type="number" min="10" step="5" class="input" /></label>
            <label>ズーム倍率<input id="keyZoomStep" type="number" min="1.01" step="0.01" class="input" /></label>
            <label>長押し間隔(ms)<input id="keyHoldMs" type="number" min="40" step="10" class="input" /></label>
            <label>左キー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyLeftKeys" class="input" placeholder="例: ArrowLeft, A" />
                <button type="button" class="mini-menu" id="keyLeftCapture">設定</button>
              </div>
            </label>
            <label>右キー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyRightKeys" class="input" placeholder="例: ArrowRight, D" />
                <button type="button" class="mini-menu" id="keyRightCapture">設定</button>
              </div>
            </label>
            <label>上キー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyUpKeys" class="input" placeholder="例: ArrowUp, W" />
                <button type="button" class="mini-menu" id="keyUpCapture">設定</button>
              </div>
            </label>
            <label>下キー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyDownKeys" class="input" placeholder="例: ArrowDown, S" />
                <button type="button" class="mini-menu" id="keyDownCapture">設定</button>
              </div>
            </label>
            <label>ズームインキー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyZoomInKeys" class="input" placeholder="例: ., /" />
                <button type="button" class="mini-menu" id="keyZoomInCapture">設定</button>
              </div>
            </label>
            <label>ズームアウトキー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyZoomOutKeys" class="input" placeholder="例: \\, _" />
                <button type="button" class="mini-menu" id="keyZoomOutCapture">設定</button>
              </div>
            </label>
            <label>表示リセットキー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyResetKeys" class="input" placeholder="例: , , R" />
                <button type="button" class="mini-menu" id="keyResetCapture">設定</button>
              </div>
            </label>
            <label style="grid-column:span 2;display:flex;align-items:center;gap:8px">
              <input id="keyClamp" type="checkbox"/> 電子書籍で画像外に出ない（限界を適用）
            </label>
            <button class="btn primary" id="keyNavSave" style="grid-column:span 2">保存</button>
          </div>
        </div>
      </div>

      <div id="viewerView" class="hidden" style="padding:12px"></div>
    </main>
  </div>

    <!-- Planner App (Clock Planner) -->
  <div id="plannerApp" class="hidden">
<header>
    <h1>🕐 Clock Planner v6</h1>
  </header>
  
  <div class="tabs">
    <button class="tab active" data-tab="planner">📅 プランナー</button>
    <button class="tab" data-tab="timer">⏲️ タイマー</button>
    <button class="tab" data-tab="stopwatch">⏱️ ストップウォッチ</button>
    <button class="tab" data-tab="timeline">📊 タイムライン</button>
    <button class="tab" data-tab="digital">🔢 デジタル</button>
    <button class="tab" data-tab="numberline">📏 数直線</button>
    <button class="tab" data-tab="study">📚 勉強管理</button>
    <button class="tab" data-tab="sound">🔊 サウンド</button>
  </div>

  <main>
    <div class="tab-content active" data-content="planner">
      <div class="card">
        <div class="hp-bar-container" id="hpBarContainer">
          <div class="hp-bar-outer">
            <div class="hp-bar-afterglow" id="hpAfterGlow"></div>
            <div class="hp-bar-fill" id="hpBarFill">
              <div class="hp-bar-shine"></div>
            </div>
            <div class="hp-bar-bg"></div>
          </div>
          <div class="hp-bar-label" id="hpLabel">残り: 100%</div>
        </div>
        
        <button class="btn small" id="pageCompleteBtn">📖 ページ完了 0/0</button>
        
        
        <!-- ▼ Overall (study) total remain/end; visible only when study auto-generated exists -->
        <div id="overallStudyInfo" class="overall-study" style="display:none">
          <span id="osiRemain">残り --</span>
          <span id="osiEnd">終了 --:--</span>
        </div>

        <div class="clock-wrap">
<svg id="clock" viewBox="0 0 500 500">
            <defs>
              <filter id="shadow">
                <feDropShadow dx="0" dy="2" stdDeviation="2" flood-opacity=".3"/>
              </filter>
              <linearGradient id="glassGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:rgba(255,255,255,.3)"/>
                <stop offset="100%" style="stop-color:rgba(255,255,255,0)"/>
              </linearGradient>
              <filter id="glow">
                <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
              <linearGradient id="arcGrad1" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" id="arcGradStart1"/>
                <stop offset="100%" id="arcGradEnd1"/>
              </linearGradient>
              <linearGradient id="arcGrad2" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" id="arcGradStart2"/>
                <stop offset="50%" id="arcGradMid2"/>
                <stop offset="100%" id="arcGradEnd2"/>
              </linearGradient>
            </defs>
            <circle cx="250" cy="250" r="235" fill="var(--face)" stroke="var(--ring)" stroke-width="2"/>
            <g id="ticks"></g>
            <g id="numbers"></g>
            <g id="arcs"></g>
            <g id="timerArcs" style="pointer-events:none"></g>
            <g id="outerArcs1"></g>
            <g id="outerArcs2"></g>
            <g id="hands" filter="url(#shadow)">
              <line id="hHand" x1="250" y1="250" x2="250" y2="110" stroke="var(--handH)" stroke-width="8" stroke-linecap="round"/>
              <line id="mHand" x1="250" y1="250" x2="250" y2="65" stroke="var(--handM)" stroke-width="5" stroke-linecap="round"/>
              <line id="sHand" x1="250" y1="250" x2="250" y2="50" stroke="var(--handS)" stroke-width="3" stroke-linecap="round"/>
            </g>
            <circle cx="250" cy="250" r="8" fill="var(--handS)"/>
          </svg>
          <div id="plEta" class="nl-eta">--</div>
          <div id="plTimerHUD" class="hud-pill">--</div>
          <div id="pomoClockHUD" class="hud-pill">--</div>
          <div id="hint" class="drag-hint"></div>
</div>
</div>

      <div class="card">
        <div class="row">
          <label>テーマ</label>
          <select id="theme">
              
              
              <option value="water">水（アニメ）</option>
              <option value="aurora">オーロラ（アニメ）</option>
              
              <option value="kari">仮（Aqua風）</option>
            <option value="theme-minimal" selected>Minimal</option>
            <option value="theme-classic">Classic</option>
            <option value="theme-neon">Neon</option>
            <option value="theme-horror">Horror</option>
            <option value="theme-paper">Paper</option>
            <option value="theme-glass">Glass</option>
            <option value="theme-pudding">Pudding</option>
            <option value="theme-metal">Metal</option>
          </select>
          <label>表示</label>
          <select id="mode">
            <option value="day">12時間</option>
            <option value="hour" selected>60分</option>
          </select>
          <label>針の動き</label>
          <select id="motion">
            <option value="smooth">スムーズ</option>
            <option value="tick" selected>カチカチ</option>
          </select>
          <label>倍速</label>
          <select id="timeScale">
  <option value="1" selected>1x</option>
  <option value="2">2x</option>
  <option value="4">4x</option>
  <option value="8">8x</option>
  <option value="10">10x</option>
  <option value="20">20x</option>
  <option value="40">40x</option>
  <option value="80">80x</option>
  <option value="160">160x</option>
  <option value="320">320x</option>
  <option value="1000">1000x</option>
  <option value="5000">5000x</option>
  <option value="10000">10000x</option>
  <option value="20000">20000x</option>
  <option value="50000">50000x</option>
</select>

          <label>バー形</label>
          <select id="shape">
            <option value="arc">アーク</option>
            <option value="wedge">くさび</option>
            <option value="bar" selected>帯</option>
            <option value="triangle">三角</option>
          </select>
          <label>バー見た目</label>
          <select id="style">
            <option value="solid" selected>ソリッド</option>
            <option value="glass">ガラス</option>
            <option value="glow">発光</option>
            <option value="metal">メタル</option>
            <option value="gradient">グラデ</option>
            <option value="rainbow">レインボー</option>
          </select>
          <label>時計デザイン</label>
          <select id="clockDesign">
            <option value="classic" selected>Classic</option>
            <option value="minimal">Minimal</option>
            <option value="neon">Neon</option>
            <option value="frost">Frost</option>
            <option value="blueprint">Blueprint</option>
            <option value="highcontrast">High-Contrast</option>
          </select> <span class="tiny" style="margin-left:10px;opacity:.8;display:inline-flex;gap:6px;align-items:center"><input type="checkbox" id="plShowSeconds"> プランナーの残り秒まで表示</span>
        
          <label>スナップ</label>
          <select id="snap">
            <option value="1">1分</option>
            <option value="5" selected>5分</option>
            <option value="10">10分</option>
            <option value="15">15分</option>
          </select>
        </div>
        
        <div class="row">
          <label>針の動き</label>
          <select id="motion">
            <option value="smooth">スムーズ</option>
            <option value="tick" selected>カチカチ</option>
          </select>
          <label>形状</label>
          <select id="shape">
            <option value="arc">アーク</option>
            <option value="wedge">三角</option>
            <option value="bar" selected>バー</option>
            <option value="triangle">中央三角</option>
          </select>
          <label>見た目</label>
          <select id="style">
            <option value="solid">ソリッド</option>
            <option value="glass">ガラス</option>
            <option value="glow">グロー</option>
            <option value="metal">メタル</option>
            <option value="gradient">グラデーション</option>
            <option value="rainbow">レインボー</option>
          </select>
        </div>

        <div class="row">
          <label>開始</label>
          <input id="start" type="time" value="09:00">
          <label>終了</label>
          <input id="end" type="time" value="10:00">
          <input id="label" type="text" placeholder="ラベル" style="flex:1">
          <input id="color" type="color" value="#4da3ff">
          <button id="add">追加</button>
          <button id="plannerDirectToggle" class="ghost">直接モード:OFF</button>
        </div>
        <div class="row" style="align-items:center;gap:10px">
          <label>バー透明度</label>
          <input id="plannerOpacity" type="range" min="0.2" max="1" step="0.05" value="0.9" style="width:160px">
          <span id="plannerOpacityVal" class="tiny" style="color:var(--muted)">0.90</span>
          <label>バー高さ</label>
          <input id="plannerHeight" type="range" min="8" max="80" step="2" value="24" style="width:160px">
          <span id="plannerHeightVal" class="tiny" style="color:var(--muted)">24px</span>
        </div>
        <div class="row" style="align-items:center;gap:10px">
          <label>ゲージデザイン</label>
          <select id="plannerGaugeStyle">
            <option value="standard" selected>通常</option>
            <option value="guide">直接ゲージ風</option>
          </select>
          <span class="tiny" style="opacity:.75">※数直線の直接モード風デザイン</span>
        </div>

        <div class="tiny">💡 タップ→長押しドラッグ→離して確定</div>
        
        <div style="margin:12px 0; display:flex; gap:8px; flex-wrap:wrap">
          <button id="undo" class="ghost">↶ 元に戻す</button>
          <button id="clear" class="ghost danger">🗑️ 全削除</button>
          <button id="export" class="ghost">💾 保存</button>
          <button id="import" class="ghost">📂 読込</button>
          <input id="file" type="file" accept=".json" style="display:none">
        </div>

        <div class="tiny" style="margin-top:12px">📋 予定一覧</div>
        <div id="list" class="list"></div>
      </div>
    </div>

    <div class="tab-content" data-content="timer">
      <div class="card">
        <button id="tAdd" style="width:100%">➕ タイマー追加</button>
        <div style="margin-top:16px; padding-top:16px; border-top:1px solid var(--ring)">
          <button id="pomo" class="ghost" style="width:100%">🍅 ポモドーロ開始</button>
          <button id="pomoStop" class="ghost danger" style="width:100%; margin-top:8px; display:none">⏹️ ポモドーロ終了</button>
          <div id="pomoInfo" class="tiny" style="text-align:center; margin-top:8px"></div>
          <div id="pomoPanel" class="pomo-panel">
            <div class="row">
              <label>集中(分)</label><input id="pomoFocus" type="number" min="1" value="25">
              <label>休憩(分)</label><input id="pomoBreak" type="number" min="1" value="5">
              <label>長休憩(分)</label><input id="pomoLongBreak" type="number" min="1" value="15">
              <label>長休憩まで</label><input id="pomoLongEvery" type="number" min="1" value="4">
            </div>
            <div class="row">
              <button id="pomoStartBtn">▶ 開始</button>
              <button id="pomoPauseBtn" class="ghost" style="display:none">⏸ 一時停止</button>
              <button id="pomoSkipBtn" class="ghost">⏭ 次へ</button>
            </div>
            <div id="pomoStatus" class="tiny" style="text-align:center; color:var(--muted)">設定を確認してください</div>
          </div>
        </div>
        
        <div class="card" style="margin-top:12px">
          <div class="row">
            <label>終了時刻</label>
            <input id="tUntilTime" type="time" step="60" style="width:120px">
            <label>表示</label>
            <select id="tUntilMode">
              <option value="direct">直接配置</option>
              <option value="outer">外周</option>
            </select>
            <label>色</label>
            <input id="tUntilColor" type="color" value="#4da3ff" style="width:50px">
            <button id="tUntilStart">⏲️ 〜まで開始</button>
          </div>
          <div class="tiny">今の時刻から選んだ終了時刻までの差分でタイマーを自動設定します（終了が現在より前の場合は翌日扱い）。</div>
        </div>

        <div id="timerList" style="margin-top:16px"></div>
      </div>
    </div>

    <div class="tab-content" data-content="stopwatch">
      <div class="card">
        <button id="swAdd" style="width:100%">➕ ストップウォッチ追加</button>
        <div id="swList" style="margin-top:16px"></div>
      </div>
    </div>

    <div class="tab-content" data-content="timeline">
      <div class="card">
        <div class="row">
          <label>表示範囲</label>
          <select id="tlRange">
            <option value="60">60分</option>
            <option value="180">3時間</option>
            <option value="360">6時間</option>
            <option value="720">12時間</option>
            <option value="1440">24時間</option>
          </select>
          <label>自動更新</label>
          <select id="tlAuto">
            <option value="0">なし</option>
            <option value="1" selected>あり</option>
          </select>
        </div>
        <div class="timeline-container">
        </div>
        <div class="tiny" style="margin-top:8px">現在時刻を中心に予定を時系列表示</div>
      </div>
    </div>

    <div class="tab-content" data-content="digital">
      <div class="card">
        <div style="text-align:center">
          <div id="digitalTime" style="font-size:72px; font-weight:700; font-family:monospace; margin:24px 0"></div>
          <div id="digitalDate" style="font-size:24px; color:var(--muted); margin-bottom:24px"></div>
        </div>
      </div>
    </div>

    
    <div class="tab-content" data-content="numberline">
      <div class="card">
        <h3 style="margin:0 0 12px 0">📏 数直線ビュー（プランナーと同期）</h3>
        <div class="row">
          <label>表示する時間数</label>
          <select id="nlRowCount">
<option>1</option>
<option selected>2</option>
<option>3</option>
<option>4</option>
<option>5</option>
<option>6</option>
<option>7</option>
<option>8</option>
<option>9</option>
<option>10</option>
<option>11</option>
<option>12</option>
<option>13</option>
<option>14</option>
<option>15</option>
<option>16</option>
<option>17</option>
<option>18</option>
<option>19</option>
<option>20</option>
<option>21</option>
<option>22</option>
<option>23</option>
<option>24</option>
<option>25</option>
<option>26</option>
<option>27</option>
<option>28</option>
<option>29</option>
<option>30</option>
</select>
          <button id="nlSync" class="ghost">境界に同期（分・秒）</button> <button id="nlFullscreenBtn" class="ghost">全画面</button> <label class="tiny" style="margin-left:8px;display:inline-flex;gap:6px;align-items:center"><input type="checkbox" id="nlShowSeconds"> 残り秒まで表示</label>
          <div class="tiny">※ 先頭行は現在の時。以降は+1時間ずつ。</div>
        </div>
        <div class="row" id="nlDigitalControls" style="align-items:center; gap:6px; flex-wrap:wrap">
          <label style="margin-right:4px">時計表示</label>
          <div class="nl-digital-toggle">
            <button type="button" class="btn ghost" data-nl-digital-mode="off">OFF</button>
            <button type="button" class="btn ghost" data-nl-digital-mode="planner">プランナー時計</button>
            <button type="button" class="btn ghost" data-nl-digital-mode="mode1">切り替え1</button>
            <button type="button" class="btn ghost" data-nl-digital-mode="mode2">切り替え2</button>
          </div>
          <span class="tiny" style="color:var(--muted)">※配置を切り替えても予定は維持されます</span>
        </div>

        <div class="row">
          <input id="nlTitle" type="text" placeholder="予定タイトル" style="flex:1">
          <label>開始</label><input id="nlStart" type="time" step="60" style="width:120px">
          <label>終了</label><input id="nlEnd" type="time" step="60" style="width:120px">
          <label>色</label><input id="nlColor" type="color" value="#7dd3fc" style="width:54px">
          <button id="nlAdd">プランナーに追加</button>
          <button id="nlDirectToggle" class="ghost">直接モード:OFF</button>
          <span id="nlMsg" class="tiny" style="color:#ef4444"></span>
        </div>

        <div id="nlRows"></div>
        <div class="tiny" style="margin-top:12px">📋 予定一覧</div>
        <div id="nlList" class="list"></div>
        <div style="margin-top:8px"><div id="nlTimerHUD" class="hud-pill">--</div><span class="hud-note">（タップで一時停止／再開。0分以下はタップで終了）</span></div>
      </div>
    </div>

<div class="tab-content" data-content="study">
      <div class="card">
        <h3 style="margin:0 0 12px 0">📚 学習進捗管理</h3>
        <div class="row">
          <label>総ページ数</label>
          <input id="studyTotal" type="number" min="1" value="20" style="width:80px">
          <label>1ページあたり(分)</label>
          <input id="studyPerPage" type="number" min="1" value="5" style="width:80px">
          <button id="studyGenerateCount">📖 ページ数で生成</button>
          <button id="studyForceEnd" class="btn small danger">⛔ 強制終了</button>
        </div>
        <div class="row">
          <label>ページ範囲</label>
          <input id="studyPageFrom" type="number" min="1" placeholder="開始" style="width:80px">
          <span>〜</span>
          <input id="studyPageTo" type="number" min="1" placeholder="終了" style="width:80px">
          <button id="studyGenerateRange" class="ghost">📖 範囲から生成</button>
          <span class="tiny" style="color:var(--muted)">※範囲モードでは開始〜終了ページを含めた予定を生成</span>
        </div>
        <div class="study-panel">
          <div class="study-stat">
            <div class="study-stat-label">総ページ数</div>
            <div class="study-stat-value" id="statTotal">20</div>
          </div>
          <div class="study-stat">
            <div class="study-stat-label">残りページ数</div>
            <div class="study-stat-value" id="statRemain">20</div>
          </div>
          <div class="study-stat">
            <div class="study-stat-label">進捗率</div>
            <div class="study-stat-value" id="statProgress">0%</div>
          </div>
          <div class="study-stat">
            <div class="study-stat-label">推定残り時間</div>
            <div class="study-stat-value" id="statTime">100分</div>
          </div>
        </div>
        <div class="tiny" style="margin-top:12px">💡 ページをクリックして完了マーク</div>
      </div>
      <div class="card">
        <h3 style="margin:0 0 12px 0">📊 学習進捗(全ページ)</h3>
        <div id="studyLog" class="page-grid"></div>
      </div>
    </div>
  
    <div class="tab-content" data-content="sound">
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;">
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button class="btn" id="soundEnableBtn">▶️ サウンド有効化</button>
            <button class="btn ghost" id="soundTestAllBtn">全テスト</button>
            <button class="btn ghost" id="soundStopAllBtn">全停止</button>
          </div>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button class="btn" id="soundExportBtn">エクスポート</button>
            <label class="btn"><input id="soundImportInput" type="file" accept="application/json" style="display:none">インポート</label>
          </div>
        </div>
        <div class="tiny">※ ブラウザの制限により、最初に「サウンド有効化」を押してください。以降、自動再生が可能になります。</div>
      </div>
      <div class="card">
        <h3 style="margin:0 0 10px 0;font-size:16px;opacity:.85">イベント別サウンド設定</h3>
        <div id="soundRoot"></div>
      </div>
      <div class="card">
        <h3 style="margin:0 0 10px 0;font-size:16px;opacity:.85">BGM / 環境音（任意）</h3>
        <div class="row" id="bgmRow">
          <input type="file" id="bgmFile" accept="audio/*">
          <label style="font-size:12px;opacity:.8">音量</label>
          <input type="range" id="bgmVol" min="0" max="1" step="0.01" value="0.3" style="width:140px">
          <label style="font-size:12px;opacity:.8">ループ</label>
          <input type="checkbox" id="bgmLoop" checked>
          <button class="btn" id="bgmPlay">再生</button>
          <button class="btn ghost" id="bgmStop">停止</button>
        </div>
      </div>
    </div>

  </main>

<script>
// Planner integration helpers (style toggle & tab activation)
(function(){
  const plannerRoot=document.getElementById('plannerApp');
  const headStyles=[...document.querySelectorAll('style[data-planner-style]')];
  const inlineStyles=plannerRoot ? [...plannerRoot.querySelectorAll('style')] : [];
  inlineStyles.forEach(s=>{ s.setAttribute('data-planner-style','1'); s.media='not all'; });
  const PLANNER_TAB_KEY='planner-active-tab';
  let plannerLastTab = (()=>{ try{ return localStorage.getItem(PLANNER_TAB_KEY)||'planner'; }catch(e){ return 'planner'; }})();
  const setPlannerStylesEnabled=(on=true)=>{
    [...headStyles,...inlineStyles].forEach(node=>{
      if(!node) return;
      try{ node.media = on ? 'all' : 'all'; }catch(e){}
    });
  };
  function setPlannerTheme(theme){
    const t = theme || (plannerRoot?.querySelector('#theme')?.value) || 'theme-minimal';
    if(plannerRoot){ plannerRoot.dataset.theme = t; plannerRoot.className = plannerRoot.className.replace(/\btheme-[^\\s]+/g,'').trim(); plannerRoot.classList.add(t); }
  }
  function resetPlannerBody(){}
  function persistPlannerTab(id){
    if(!id) return;
    plannerLastTab=id;
    try{ localStorage.setItem(PLANNER_TAB_KEY,id); }catch(e){}
  }
  function activatePlannerTab(id){
    if(!plannerRoot) return;
    const target=plannerRoot.querySelector(`.tab[data-tab=\"${id||plannerLastTab}\"]`);
    if(target){ target.click(); }
    persistPlannerTab(id||plannerLastTab);
  }
  plannerRoot?.addEventListener('click',(e)=>{
    const tab=e.target.closest('.tab');
    if(tab?.dataset.tab){ persistPlannerTab(tab.dataset.tab); }
  });
  setPlannerStylesEnabled(true);
  window.__plannerStyles={enable:()=>setPlannerStylesEnabled(true),disable:()=>setPlannerStylesEnabled(true)};
  window.__setPlannerTheme=setPlannerTheme;
  window.__resetPlannerBody=resetPlannerBody;
  window.__activatePlannerTab=activatePlannerTab;
  window.__plannerLastTab=()=>plannerLastTab;
})();
</script>

<script>
(()=>{
  // ================================
  // Numberline-first Data Store
  // ================================
  // 単一の真実 (Single Source of Truth) : NLStore.events (絶対時刻ベース)
  // {id, title, start:number(ms since epoch), end:number(ms), color, kind?}
  const LS_KEY = "nl_events_v1";
  const $ = (id)=>document.getElementById(id);
  const plannerRoot = document.getElementById('plannerApp');
  const clamp = (v,min,max)=>Math.max(min, Math.min(max,v));
  const NL_DIGITAL_MODE_KEY = 'nl_digital_mode';
  let nlDigitalState = { mode:'off', displays:[] };
  let nlPlannerMirrorHost = null;

  const NLStore = {
    events: [],
    load(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        this.events = raw ? JSON.parse(raw) : [];
      }catch(e){
        this.events = [];
      }
      // 正常化: end<=start を避ける、色/タイトルの既定値
      this.events = this.events.map(ev=>{
        const start = Number(ev.start)||0, end = Number(ev.end)||0;
        return {
          id: ev.id || (Date.now()+Math.random()),
          title: (ev.title||"予定").trim(),
          start: Math.max(0,start),
          end: Math.max(Math.max(0,start+60*1000), end), // 最短1分
          color: ev.color || "#4da3ff",
          kind: ev.kind || "normal"
        };
      }).sort((a,b)=>a.start-b.start);
    },
    save(){
      localStorage.setItem(LS_KEY, JSON.stringify(this.events));
    },
    clear(){
      this.events = [];
      this.save();
    },
    addAbs(startDate, endDate, title, color, kind){
      const s = (startDate instanceof Date) ? startDate.getTime() : Number(startDate);
      const e = (endDate   instanceof Date) ? endDate.getTime()   : Number(endDate);
      if(!isFinite(s) || !isFinite(e)) return null;
      const ev = {
        id: Date.now()+Math.random(),
        title: (title||"予定").trim() || "予定",
        start: Math.min(s,e),
        end: Math.max(s,e),
        color: color || "#4da3ff",
        kind: kind || "normal"
      };
      this.events.push(ev);
      this.events.sort((a,b)=>a.start-b.start);
      this.save();
      return ev;
    },
    removeById(id){
      this.events = this.events.filter(ev=>ev.id!==id);
      this.save();
    },
    listBetween(winStart, winEnd){
      // [winStart, winEnd) に重なるイベントを返す
      return this.events.filter(ev => ev.end>winStart && ev.start<winEnd);
    }
  };
  NLStore.load();

  // 外部から開始できる簡易API: StudyStart(ids)
  window.StudyStart = function(ids){ StudyMgr.active=true; StudyMgr.pageIds = ids.slice(); StudyMgr.save(); StudyUI.update(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 if(window.updateOverallStudyUI) updateOverallStudyUI(); setCompleteBtnText(); drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    StudyUI.update(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 setCompleteBtnText(); nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 }; if(window.updateOverallStudyUI) updateOverallStudyUI(); if(window.__startOverallTicker) window.__startOverallTicker();


  // ============== 時刻ヘルパ ==============
  function now(){ return (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date())); }
  function pad2(n){ return (n<10?"0":"")+n; }
  function toHM(d){ return pad2(d.getHours())+":"+pad2(d.getMinutes()); }
  function formatDuration(ms){
    ms = Math.max(0, ms|0);
    const totalSec = Math.floor(ms/1000);
    const mm = Math.floor(totalSec/60);
    const ss = totalSec%60;
    return `${mm}:${String(ss).padStart(2,'0')}`;
  }
  let clockPulseMs = null;
  function setClockPulseDate(src){
    if(src==null) return;
    const ms = src instanceof Date ? src.getTime() : Number(src);
    if(!Number.isFinite(ms)) return;
    clockPulseMs = ms;
    window.__clockPulseMs = ms;
    window.__clockPulseDate = new Date(ms);
  }
  function getClockPulseDate(){
    if(clockPulseMs==null) return null;
    return new Date(clockPulseMs);
  }
  function getSyncedNow(opts){
    const preferPulse = !!(opts && opts.preferPulse);
    if(preferPulse){
      const pulse = getClockPulseDate();
      if(pulse) return pulse;
    }
    return now();
  }
  window.__setClockPulseDate = setClockPulseDate;
  window.__getClockPulseDate = getClockPulseDate;
  window.__getSyncedNow = getSyncedNow;

  // ============== 既存UIへの最小限バインド ==============
  // 1) プランナー: 円形時計 (hour/day) を NLStore から描画
  // 2) 数直線: NLStore を直接描画（基盤）
  // 3) 追加ボタン類は NLStore へ追加 → 双方向同期不要

  // DOM
  const svg = document.getElementById('clock');
  const plannerClockWrap = document.querySelector('.clock-wrap');
  const ticks = document.getElementById('ticks');
  const numbers = document.getElementById('numbers');
  const arcs = document.getElementById('arcs');
  const outerArcs1 = document.getElementById('outerArcs1');
  const outerArcs2 = document.getElementById('outerArcs2');
  const timerArcs = document.getElementById('timerArcs');
  const hHand = document.getElementById('hHand');
  const mHand = document.getElementById('mHand');
  const sHand = document.getElementById('sHand');
  const PLANNER_OPACITY_KEY = 'planner_bar_opacity';
  const PLANNER_HEIGHT_KEY = 'planner_bar_height';
  const PLANNER_GUIDE_KEY = 'planner_bar_guide';
  function loadPlannerOpacity(){
    try{
      const v = parseFloat(localStorage.getItem(PLANNER_OPACITY_KEY));
      if(isFinite(v)) return Math.max(0.2, Math.min(1, v));
    }catch(e){}
    return 0.9;
  }
  function savePlannerOpacity(v){
    try{ localStorage.setItem(PLANNER_OPACITY_KEY, String(v)); }catch(e){}
  }
  function loadPlannerThickness(){
    try{
      const v = parseFloat(localStorage.getItem(PLANNER_HEIGHT_KEY));
      if(isFinite(v)) return Math.max(8, Math.min(80, v));
    }catch(e){}
    return 24;
  }
  function savePlannerThickness(v){
    try{ localStorage.setItem(PLANNER_HEIGHT_KEY, String(v)); }catch(e){}
  }
  function loadPlannerGuideStyle(){
    try{ return localStorage.getItem(PLANNER_GUIDE_KEY) === 'guide'; }catch(e){}
    return false;
  }
  function savePlannerGuideStyle(flag){
    try{ localStorage.setItem(PLANNER_GUIDE_KEY, flag ? 'guide' : 'standard'); }catch(e){}
  }
  const plannerBarStyle = {
    opacity: loadPlannerOpacity(),
    thickness: loadPlannerThickness(),
    guideLook: loadPlannerGuideStyle()
  };

  // 軽量なユーティリティ(SVG)
  function mk(tag){ return document.createElementNS('http://www.w3.org/2000/svg', tag); }
  function pol(r,a){ return {x:250+r*Math.cos(a), y:250+r*Math.sin(a)}; }
  function rot(el,deg){ if(el) el.setAttribute('transform',`rotate(${deg} 250 250)`); }
  function updatePlannerHandRotation(date, motionValue){
    if(!date) return;
    const mode = motionValue || (($('motion') && $('motion').value) || 'smooth');
    const smooth = mode === 'smooth';
    const secBase = date.getSeconds();
    const sec = smooth ? (secBase + date.getMilliseconds()/1000) : secBase;
    const minBase = date.getMinutes();
    const min = smooth ? (minBase + sec/60) : minBase;
    const hourBase = date.getHours()%12;
    const hour = smooth ? (hourBase + min/60) : (hourBase + minBase/60);
    rot(sHand, sec*6);
    rot(mHand, min*6);
    rot(hHand, hour*30);
  }
  window.__updatePlannerHandRotation = updatePlannerHandRotation;

  function minToAng(min, total){
    return (min%total)/total*2*Math.PI - Math.PI/2;
  }
  function arcPath(r,a1,a2,strokeWidth=24){
    while(a2<a1) a2+=2*Math.PI;
    const large = (a2-a1)>Math.PI?1:0;
    const p1 = pol(r,a1), p2 = pol(r,a2);
    return `M ${p1.x} ${p1.y} A ${r} ${r} 0 ${large} 1 ${p2.x} ${p2.y}`;
  }


  // === Planner control bindings & defaults ===
  (function(){
    const KEY = 'planner_prefs_v1';
    function loadPrefs(){
      try{ return JSON.parse(localStorage.getItem(KEY)||'{}'); }catch(e){ return {}; }
    }
    function savePrefs(p){ try{ localStorage.setItem(KEY, JSON.stringify(p)); }catch(e){} }
    const els = {
      mode: document.getElementById('mode'),
      motion: document.getElementById('motion'),
      shape: document.getElementById('shape'),
      style: document.getElementById('style'),
      clockDesign: document.getElementById('clockDesign')
    };
    const pref = loadPrefs();
    // Apply defaults if not saved
    if(!pref.mode) pref.mode = 'hour';
    if(!pref.motion) pref.motion = 'tick';
    if(!pref.shape) pref.shape = 'bar';
    // Sync UI
    if(els.mode) els.mode.value = pref.mode;
    if(els.motion) els.motion.value = pref.motion;
    if(els.shape) els.shape.value = pref.shape;
    if(els.style && pref.style) els.style.value = pref.style;
    if(els.clockDesign && pref.clockDesign) els.clockDesign.value = pref.clockDesign;
    // Bind changes
    Object.entries(els).forEach(([k,el])=>{
      if(!el) return;
      el.addEventListener('change', ()=>{
        const p = loadPrefs();
        p[k] = el.value;
        savePrefs(p);
        drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

      });
    });
    // initial draw (ensures new defaults take effect)
    drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

  })();

  // ============== プランナー描画（NLStore → 相対化） ==============
  
  // ===== 時計デザイン適用 =====
  function applyClockDesign(design){
    const root = document.documentElement.style;
    const set = (k,v)=>root.setProperty(k, v);
    const theme = design||'classic';
    if(theme==='classic'){
      set('--face', '#0b1724'); set('--ring','#2b4a6a');
      set('--tickMajor','#9fb5c9'); set('--tickMinor','#6183a3'); set('--muted','#b7c7d6');
      set('--handH','#e0e6ed'); set('--handM','#9cc3ff'); set('--handS','#ff6b6b');
    }else if(theme==='minimal'){
      set('--face', '#101013'); set('--ring','#282828');
      set('--tickMajor','#cccccc'); set('--tickMinor','#4a4a4a'); set('--muted','#bdbdbd');
      set('--handH','#eaeaea'); set('--handM','#eaeaea'); set('--handS','#eaeaea');
    }else if(theme==='neon'){
      set('--face', '#05060a'); set('--ring','#0f172a');
      set('--tickMajor','#61dafb'); set('--tickMinor','#22d3ee'); set('--muted','#a5f3fc');
      set('--handH','#22d3ee'); set('--handM','#a78bfa'); set('--handS','#f472b6');
    }else if(theme==='frost'){
      set('--face', 'rgba(255,255,255,0.06)'); set('--ring','rgba(255,255,255,0.25)');
      set('--tickMajor','rgba(255,255,255,0.85)'); set('--tickMinor','rgba(255,255,255,0.45)'); set('--muted','rgba(255,255,255,0.9)');
      set('--handH','rgba(255,255,255,0.95)'); set('--handM','rgba(255,255,255,0.95)'); set('--handS','rgba(255,255,255,0.95)');
    }else if(theme==='blueprint'){
      set('--face', '#081a33'); set('--ring','#93c5fd');
      set('--tickMajor','#bfdbfe'); set('--tickMinor','#60a5fa'); set('--muted','#e0f2fe');
      set('--handH','#e0f2fe'); set('--handM','#93c5fd'); set('--handS','#60a5fa');
    }else if(theme==='highcontrast'){
      set('--face', '#000'); set('--ring','#fff');
      set('--tickMajor','#fff'); set('--tickMinor','#aaa'); set('--muted','#fff');
      set('--handH','#fff'); set('--handM','#fff'); set('--handS','#ff3b3b');
    }
    // Optional: add class to SVG
    const svg = document.getElementById('clock');
    if(svg){ svg.setAttribute('data-design', theme); }
  }
function drawPlanner(){
    const mode = $('mode') ? $('mode').value : 'day';
    const cd = $('clockDesign') ? $('clockDesign').value : 'classic';
    applyClockDesign(cd);
 // 'hour' or 'day'
    // 目盛り
    ticks.innerHTML=''; numbers.innerHTML='';
    for(let i=0;i<=60;i++){
      const a = i/60*2*Math.PI - Math.PI/2;
      const r1 = i%5===0 ? 205 : 220;
      const r2 = i%5===0 ? 232 : 236;
      const l = mk('line');
      l.setAttribute('x1', pol(r1,a).x); l.setAttribute('y1', pol(r1,a).y);
      l.setAttribute('x2', pol(r2,a).x); l.setAttribute('y2', pol(r2,a).y);
      l.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue(i%5===0?'--tickMajor':'--tickMinor').trim());
      l.setAttribute('stroke-width', i%5===0?2:1);
      ticks.appendChild(l);
    }
    if(mode==='day'){
      for(let i=1;i<=12;i++){
        const a = i/12*2*Math.PI - Math.PI/2;
        const p = pol(185,a);
        const t = mk('text');
        t.setAttribute('x',p.x); t.setAttribute('y',p.y);
        t.setAttribute('fill', getComputedStyle(document.documentElement).getPropertyValue('--muted').trim());
        t.setAttribute('font-size','20'); t.setAttribute('font-weight','700');
        t.setAttribute('text-anchor','middle'); t.setAttribute('dominant-baseline','middle');
        t.textContent = i;
        numbers.appendChild(t);
      }
    }else{  for(let i=1;i<=12;i++){    const a = i/12*2*Math.PI - Math.PI/2; const p = pol(185,a); const t = mk('text');    t.setAttribute('x',p.x); t.setAttribute('y',p.y);    t.setAttribute('fill', getComputedStyle(document.documentElement).getPropertyValue('--muted').trim());    t.setAttribute('font-size','20'); t.setAttribute('font-weight','700');    t.setAttribute('text-anchor','middle'); t.setAttribute('dominant-baseline','middle');    t.textContent = i; numbers.appendChild(t); } }
    // 針
    const motion = ($('motion') ? $('motion').value : 'smooth');
    const nowD = now();
    updatePlannerHandRotation(nowD, motion);
    hHand.style.opacity = (mode==='day')?1:0.2;

    // イベント描画 (絶対→相対)
    arcs.innerHTML=''; outerArcs1.innerHTML=''; outerArcs2.innerHTML=''; timerArcs.innerHTML='';
    const nowMs = nowD.getTime();
    let winStart, winEnd, totalMin;
    if(mode==='hour'){
      const base = new Date(nowD); base.setMinutes(0,0,0);
      winStart = base.getTime();
      winEnd   = winStart + 60*60000;
      totalMin = 60;
    }else{ // day(12h)
      const half = (nowD.getHours()>=12?12:0);
      const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), half, 0, 0, 0);
      winStart = base.getTime();
      winEnd   = winStart + 12*60*60000;
      totalMin = 720;
    }
    
const defsEl = svg.querySelector('defs');
const styleSel = $('style') ? $('style').value : 'solid';
const shapeSel = $('shape') ? $('shape').value : 'arc';
const guideLook = !!plannerBarStyle.guideLook;
const thickness = Math.max(8, Math.min(80, plannerBarStyle.thickness||24));
const baseRadius = 200;
const barOuterRadius = baseRadius + thickness/2;
const barInnerRadius = Math.max(40, baseRadius - thickness/2);
const wedgeOuterRadius = baseRadius + thickness*0.75;
const wedgeInnerRadius = Math.max(0, wedgeOuterRadius - Math.max(40, thickness*1.2));
const triangleHalfWidth = Math.max(16, thickness*0.6);
const triangleLength = 150 + (thickness-24)*1.1;

function hexToRgb(hex){ hex = (hex||'#4da3ff').replace('#',''); return {r:parseInt(hex.substr(0,2),16), g:parseInt(hex.substr(2,2),16), b:parseInt(hex.substr(4,2),16)}; }
function rgba({r,g,b},a){ return `rgba(${r},${g},${b},${a})`; }
function shade({r,g,b}, k){ const f = (v)=>Math.round(Math.max(0, Math.min(50000,v*(1+k)))); return {r:f(r), g:f(g), b:f(b)}; }
function ensureLinearGrad(id, stops){
  let g = defsEl.querySelector('#'+id);
  if(!g){
    g = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
    g.setAttribute('id', id);
    g.setAttribute('x1','0%'); g.setAttribute('y1','0%');
    g.setAttribute('x2','0%'); g.setAttribute('y2','100%');
    defsEl.appendChild(g);
  }
  while(g.firstChild) g.removeChild(g.firstChild);
  stops.forEach(([off, col, op])=>{
    const s = document.createElementNS('http://www.w3.org/2000/svg','stop');
    s.setAttribute('offset', off);
    s.setAttribute('stop-color', col);
    if(op!=null) s.setAttribute('stop-opacity', op);
    g.appendChild(s);
  });
  return `url(#${id})`;
}
function sectorPath(cx,cy,rOuter,rInner,a1,a2){
  while(a2<a1) a2+=Math.PI*2;
  const large = (a2-a1)>Math.PI ? 1 : 0;
  const p1o={x:cx+rOuter*Math.cos(a1), y:cy+rOuter*Math.sin(a1)};
  const p2o={x:cx+rOuter*Math.cos(a2), y:cy+rOuter*Math.sin(a2)};
  const p1i={x:cx+rInner*Math.cos(a2), y:cy+rInner*Math.sin(a2)};
  const p2i={x:cx+rInner*Math.cos(a1), y:cy+rInner*Math.sin(a1)};
  if(rInner<=0){
    return `M ${cx} ${cy} L ${p1o.x} ${p1o.y} A ${rOuter} ${rOuter} 0 ${large} 1 ${p2o.x} ${p2o.y} Z`;
  }else{
    return `M ${p1o.x} ${p1o.y} A ${rOuter} ${rOuter} 0 ${large} 1 ${p2o.x} ${p2o.y} L ${p1i.x} ${p1i.y} A ${rInner} ${rInner} 0 ${large} 0 ${p2i.x} ${p2i.y} Z`;
  }
}
function drawStyledArc(g, a1, a2, color){
  const rgb = hexToRgb(color||'#4da3ff');
  const baseOpacity = Math.max(0.2, Math.min(1, plannerBarStyle.opacity||0.95));
  const baseCol = rgba(rgb, baseOpacity);
  const guideFillAlpha = Math.min(0.65, Math.max(0.15, baseOpacity*0.8));
  const guideFill = `rgba(${rgb.r},${rgb.g},${rgb.b},${guideFillAlpha})`;
  const guideEdgeCol = `rgba(${shade(rgb,0.15).r},${shade(rgb,0.15).g},${shade(rgb,0.15).b},0.9)`;
  const dashWidth = Math.max(1.5, Math.min(6, thickness*0.18));
  const guideDash = '12 7';
  if(shapeSel==='arc'){
    if(guideLook){
      const track = mk('path');
      track.setAttribute('d', arcPath(baseRadius, a1, a2, thickness));
      track.setAttribute('fill','none');
      track.setAttribute('stroke', guideFill);
      track.setAttribute('stroke-width', thickness);
      track.setAttribute('stroke-linecap','round');
      track.setAttribute('filter','url(#shadow)');
      const dash = mk('path');
      dash.setAttribute('d', arcPath(baseRadius, a1, a2, thickness+3));
      dash.setAttribute('fill','none');
      dash.setAttribute('stroke', guideEdgeCol);
      dash.setAttribute('stroke-width', Math.max(2, Math.min(8, thickness*0.35)));
      dash.setAttribute('stroke-linecap','round');
      dash.setAttribute('stroke-linejoin','round');
      dash.setAttribute('stroke-dasharray', guideDash);
      const inner = mk('path');
      inner.setAttribute('d', arcPath(baseRadius, a1, a2, Math.max(2, thickness*0.45)));
      inner.setAttribute('fill','none');
      inner.setAttribute('stroke','rgba(255,255,255,0.35)');
      inner.setAttribute('stroke-linecap','round');
      inner.setAttribute('stroke-width', Math.max(1, thickness*0.25));
      g.appendChild(track);
      g.appendChild(dash);
      g.appendChild(inner);
      return;
    }
    const base = mk('path');
    base.setAttribute('d', arcPath(baseRadius, a1, a2, thickness));
    base.setAttribute('fill','none');
    base.setAttribute('stroke-linecap','round');
    if(styleSel==='gradient'){
      const gId = 'grad-' + Math.random().toString(36).slice(2);
      const c1 = `rgba(${shade(rgb,0.25).r},${shade(rgb,0.25).g},${shade(rgb,0.25).b},1)`;
      const c2 = baseCol;
      base.setAttribute('stroke', ensureLinearGrad(gId, [['0%', c1, 1], ['100%', c2, 1]]));
    }else if(styleSel==='rainbow'){
      const gId = 'rainbow-' + Math.random().toString(36).slice(2);
      ensureLinearGrad(gId, [
        ['0%','#ff6b6b',1],['20%','#ffd43b',1],['40%','#51cf66',1],
        ['60%','#4dabf7',1],['80%','#845ef7',1],['100%','#f783ac',1]
      ]);
      base.setAttribute('stroke', `url(#${gId})`);
    }else{
      base.setAttribute('stroke', baseCol);
    }
    base.setAttribute('stroke-width', thickness);
    const outHi = mk('path'); outHi.setAttribute('d', arcPath(baseRadius,a1,a2,thickness+3)); outHi.setAttribute('fill','none'); outHi.setAttribute('stroke','rgba(255,255,255,0.22)'); outHi.setAttribute('stroke-linecap','round'); outHi.setAttribute('stroke-width',3);
    const outLo = mk('path'); outLo.setAttribute('d', arcPath(baseRadius,a1,a2,Math.max(2,thickness-2))); outLo.setAttribute('fill','none'); outLo.setAttribute('stroke','rgba(0,0,0,0.18)'); outLo.setAttribute('stroke-linecap','round'); outLo.setAttribute('stroke-width',2);
    g.appendChild(outHi);
    g.appendChild(base);
    g.appendChild(outLo);

    if(styleSel==='glass'){
      const hl = mk('path');
      hl.setAttribute('d', arcPath(baseRadius, a1, a2, Math.max(8,thickness*0.52)));
      hl.setAttribute('fill','none');
      hl.setAttribute('stroke','url(#glassGrad)');
      hl.setAttribute('stroke-opacity','0.9');
      hl.setAttribute('stroke-linecap','round');
      hl.setAttribute('stroke-width', Math.max(8,thickness*0.52));
      g.appendChild(hl);
      const edge = mk('path');
      edge.setAttribute('d', arcPath(baseRadius, a1, a2, thickness+2));
      edge.setAttribute('fill','none');
      edge.setAttribute('stroke', `rgba(${shade(rgb,-0.5).r},${shade(rgb,-0.5).g},${shade(rgb,-0.5).b},0.25)`);
      edge.setAttribute('stroke-linecap','round');
      edge.setAttribute('stroke-width', 2);
      g.appendChild(edge);
    }
    if(styleSel==='metal'){
      const top = mk('path');
      top.setAttribute('d', arcPath(baseRadius, a1, a2, thickness*0.55));
      top.setAttribute('fill','none');
      top.setAttribute('stroke', `rgba(${shade(rgb,0.35).r},${shade(rgb,0.35).g},${shade(rgb,0.35).b},0.9)`);
      top.setAttribute('stroke-linecap','round');
      top.setAttribute('stroke-width', thickness*0.55);
      g.appendChild(top);
      const bot = mk('path');
      bot.setAttribute('d', arcPath(baseRadius, a1, a2, thickness));
      bot.setAttribute('fill','none');
      bot.setAttribute('stroke', `rgba(${shade(rgb,-0.25).r},${shade(rgb,-0.25).g},${shade(rgb,-0.25).b},0.9)`);
      bot.setAttribute('stroke-linecap','round');
      bot.setAttribute('stroke-width', 2);
      g.appendChild(bot);
    }
    if(styleSel==='glow'){ g.setAttribute('filter','url(#glow)'); }
  }else if(shapeSel==='wedge'){
    const pathD = sectorPath(250,250, wedgeOuterRadius, guideLook ? wedgeInnerRadius : 0, a1, a2);
    if(guideLook){
      const fill = mk('path');
      fill.setAttribute('d', pathD);
      fill.setAttribute('fill', guideFill);
      fill.setAttribute('filter','url(#shadow)');
      const edge = mk('path');
      edge.setAttribute('d', pathD);
      edge.setAttribute('fill','none');
      edge.setAttribute('stroke', guideEdgeCol);
      edge.setAttribute('stroke-width', dashWidth);
      edge.setAttribute('stroke-dasharray', guideDash);
      edge.setAttribute('stroke-linecap','round');
      arcs.appendChild(fill);
      arcs.appendChild(edge);
      return;
    }
    const p = mk('path');
    p.setAttribute('d', pathD);
    p.setAttribute('fill', baseCol);
    if(styleSel==='glass'){
      const gId = 'wglass-' + Math.random().toString(36).slice(2);
      p.setAttribute('fill', ensureLinearGrad(gId, [['0%','rgba(255,255,255,0.7)',1],['20%', 'rgba(255,255,255,0.35)',1],['100%', baseCol,1]]));
      p.setAttribute('stroke', `rgba(${shade(rgb,-0.4).r},${shade(rgb,-0.4).g},${shade(rgb,-0.4).b},0.3)`);
      p.setAttribute('stroke-width','1.5');
    }else if(styleSel==='gradient'){
      const gId = 'wgrad-' + Math.random().toString(36).slice(2);
      const c1 = `rgba(${shade(rgb,0.25).r},${shade(rgb,0.25).g},${shade(rgb,0.25).b},1)`;
      const c2 = baseCol;
      p.setAttribute('fill', ensureLinearGrad(gId, [['0%',c1,1],['100%',c2,1]]));
    }else if(styleSel==='rainbow'){
      const gId = 'wrain-' + Math.random().toString(36).slice(2);
      p.setAttribute('fill', ensureLinearGrad(gId, [
        ['0%','#ff6b6b',1],['20%','#ffd43b',1],['40%','#51cf66',1],
        ['60%','#4dabf7',1],['80%','#845ef7',1],['100%','#f783ac',1]
      ]));
    }else if(styleSel==='metal'){
      const gId = 'wmetal-' + Math.random().toString(36).slice(2);
      p.setAttribute('fill', ensureLinearGrad(gId, [
        ['0%','rgba(255,255,255,0.25)',1],['20%', baseCol,1],
        ['80%', `rgba(${shade(rgb,-0.25).r},${shade(rgb,-0.25).g},${shade(rgb,-0.25).b},0.95)`,1],['100%','rgba(255,255,255,0.2)',1]
      ]));
    }
    arcs.appendChild(p);
    if(styleSel==='glow'){ p.setAttribute('filter','url(#glow)'); }
  }else if(shapeSel==='bar'){
    const pathD = sectorPath(250,250, barOuterRadius, barInnerRadius, a1, a2);
    if(guideLook){
      const fill = mk('path');
      fill.setAttribute('d', pathD);
      fill.setAttribute('fill', guideFill);
      fill.setAttribute('filter','url(#shadow)');
      const edge = mk('path');
      edge.setAttribute('d', pathD);
      edge.setAttribute('fill','none');
      edge.setAttribute('stroke', guideEdgeCol);
      edge.setAttribute('stroke-width', dashWidth);
      edge.setAttribute('stroke-dasharray', guideDash);
      edge.setAttribute('stroke-linecap','round');
      const inner = mk('path');
      inner.setAttribute('d', pathD);
      inner.setAttribute('fill','none');
      inner.setAttribute('stroke','rgba(255,255,255,0.25)');
      inner.setAttribute('stroke-width',1);
      arcs.appendChild(fill);
      arcs.appendChild(edge);
      arcs.appendChild(inner);
      return;
    }
    const p = mk('path');
    p.setAttribute('d', pathD);
    p.setAttribute('fill', baseCol);
    if(styleSel==='glass'){
      const gId = 'bglass-' + Math.random().toString(36).slice(2);
      p.setAttribute('fill', ensureLinearGrad(gId, [['0%','rgba(255,255,255,0.7)',1],['20%','rgba(255,255,255,0.35)',1],['100%', baseCol,1]]));
      p.setAttribute('stroke', `rgba(${shade(rgb,-0.4).r},${shade(rgb,-0.4).g},${shade(rgb,-0.4).b},0.35)`);
      p.setAttribute('stroke-width','1.5');
    }else if(styleSel==='gradient'){
      const gId = 'bgrad-' + Math.random().toString(36).slice(2);
      const c1 = `rgba(${shade(rgb,0.25).r},${shade(rgb,0.25).g},${shade(rgb,0.25).b},1)`;
      const c2 = baseCol;
      p.setAttribute('fill', ensureLinearGrad(gId, [['0%',c1,1],['100%',c2,1]]));
    }else if(styleSel==='rainbow'){
      const gId = 'brain-' + Math.random().toString(36).slice(2);
      p.setAttribute('fill', ensureLinearGrad(gId, [
        ['0%','#ff6b6b',1],['20%','#ffd43b',1],['40%','#51cf66',1],
        ['60%','#4dabf7',1],['80%','#845ef7',1],['100%','#f783ac',1]
      ]));
    }else if(styleSel==='metal'){
      const gId = 'bmetal-' + Math.random().toString(36).slice(2);
      p.setAttribute('fill', ensureLinearGrad(gId, [
        ['0%','rgba(255,255,255,0.25)',1],['20%', baseCol,1],
        ['80%', `rgba(${shade(rgb,-0.25).r},${shade(rgb,-0.25).g},${shade(rgb,-0.25).b},0.95)`,1],['100%','rgba(255,255,255,0.2)',1]
      ]));
    }
    arcs.appendChild(p);
    if(styleSel==='glow'){ p.setAttribute('filter','url(#glow)'); }
  }else if(shapeSel==='triangle'){
    const mid = (a1+a2)/2;
    const len = triangleLength;
    const base = triangleHalfWidth;
    const tip = {x:250+len*Math.cos(mid), y:250+len*Math.sin(mid)};
    const left = {x:250+base*Math.cos(mid+Math.PI/2), y:250+base*Math.sin(mid+Math.PI/2)};
    const right= {x:250+base*Math.cos(mid-Math.PI/2), y:250+base*Math.sin(mid-Math.PI/2)};
    const points = `${left.x},${left.y} ${right.x},${right.y} ${tip.x},${tip.y}`;
    if(guideLook){
      const poly = mk('polygon');
      poly.setAttribute('points', points);
      poly.setAttribute('fill', guideFill);
      poly.setAttribute('filter','url(#shadow)');
      const edge = mk('polygon');
      edge.setAttribute('points', points);
      edge.setAttribute('fill','none');
      edge.setAttribute('stroke', guideEdgeCol);
      edge.setAttribute('stroke-width', dashWidth);
      edge.setAttribute('stroke-dasharray', guideDash);
      arcs.appendChild(poly);
      arcs.appendChild(edge);
      return;
    }
    const poly = mk('polygon');
    poly.setAttribute('points', points);
    poly.setAttribute('fill', baseCol);
    if(styleSel==='glass'){
      const gId = 'tglass-' + Math.random().toString(36).slice(2);
      poly.setAttribute('fill', ensureLinearGrad(gId, [['0%','rgba(255,255,255,0.8)',1],['100%', baseCol,1]]));
      poly.setAttribute('stroke', `rgba(${shade(rgb,-0.35).r},${shade(rgb,-0.35).g},${shade(rgb,-0.35).b},0.35)`);
      poly.setAttribute('stroke-width','1.2');
    }
    if(styleSel==='glow'){ poly.setAttribute('filter','url(#glow)'); }
    arcs.appendChild(poly);
  }
}

const list = NLStore.listBetween(winStart, winEnd);
list.forEach(ev=>{
  const sMs = Math.max(ev.start, winStart);
  const eMs = Math.min(ev.end,   winEnd);
  if(eMs<=sMs) return;
  const relS = (sMs - winStart)/60000;
  const relE = (eMs - winStart)/60000;
  const a1 = minToAng(relS, totalMin);
  const a2 = minToAng(relE, totalMin);
  const gArc = mk('g');
  drawStyledArc(gArc, a1, a2, ev.color||'#4da3ff');
  arcs.appendChild(gArc);
});
  }

  // ============== 数直線描画（基盤） ==============

  // ===== Tick (メモリ) style settings =====
  const nlTickStyle = {
    minorLen: 28, minorThick: 1, minorColor: '#9fb5c9',
    majorLen: 40, majorThick: 3, majorColor: '#285078',
    glow: 6, shadow: 6, shape: 'line'
  };
  function setTickStyleFromUI(){
    const g = id=>document.getElementById(id);
    const mLen = g('tickMinorLen'), mTh = g('tickMinorThick'), mCol = g('tickMinorColor');
    const MLen = g('tickMajorLen'), MTh = g('tickMajorThick'), MCol = g('tickMajorColor');
    const gl = g('tickGlow'), sh = g('tickShadow'), shp = g('tickShape');
    if(mLen){ nlTickStyle.minorLen = parseInt(mLen.value)||28; const v=g('tickMinorLenVal'); if(v) v.textContent = nlTickStyle.minorLen+'%'; }
    if(mTh){ nlTickStyle.minorThick = parseInt(mTh.value)||1; const v=g('tickMinorThickVal'); if(v) v.textContent = nlTickStyle.minorThick+'px'; }
    if(mCol){ nlTickStyle.minorColor = mCol.value||'#9fb5c9'; }
    if(MLen){ nlTickStyle.majorLen = parseInt(MLen.value)||40; const v=g('tickMajorLenVal'); if(v) v.textContent = nlTickStyle.majorLen+'%'; }
    if(MTh){ nlTickStyle.majorThick = parseInt(MTh.value)||3; const v=g('tickMajorThickVal'); if(v) v.textContent = nlTickStyle.majorThick+'px'; }
    if(MCol){ nlTickStyle.majorColor = MCol.value||'#285078'; }
    if(gl){ nlTickStyle.glow = parseInt(gl.value)||0; const v=g('tickGlowVal'); if(v) v.textContent = nlTickStyle.glow; }
    if(sh){ nlTickStyle.shadow = parseInt(sh.value)||0; const v=g('tickShadowVal'); if(v) v.textContent = nlTickStyle.shadow; }
    if(shp){ nlTickStyle.shape = shp.value; }
  }
  function applyTickStyleToRow(row){
    const laneBounds = row.querySelector('.nl-lane')?.getBoundingClientRect();
    const laneHeight = laneBounds ? laneBounds.height : 100;
    const pxToPercent = laneHeight ? (100 / laneHeight) : 0;
    const ticksWrap = row.querySelector('.nl-ticks');
    if(!ticksWrap) return;
    // minor
    ticksWrap.querySelectorAll('.nl-tick').forEach(el=>{
      const isMajor = el.classList.contains('major');
      const len = (isMajor? nlTickStyle.majorLen : nlTickStyle.minorLen);
      const thick = (isMajor? nlTickStyle.majorThick : nlTickStyle.minorThick);
      const color = (isMajor? nlTickStyle.majorColor : nlTickStyle.minorColor);
      // baseline around center: make top so that it crosses center line and extends upward
      const center = 50;
      const top = center - (len*0.55); // slightly more above to keep readable when bars are below
      el.style.top = top + '%';
      el.style.height = len + '%';
      el.style.width = thick + 'px';
      el.style.background = color;
      // effects
      const glow = nlTickStyle.glow;
      const shadow = nlTickStyle.shadow;
      const glowCol = color + (color.length===7 ? '80' : '');
      el.style.filter = `drop-shadow(0 0 ${glow}px ${color})`;
      el.style.boxShadow = shadow>0 ? `0 1px ${shadow}px rgba(0,0,0,0.35)` : 'none';
      // shape
      el.style.borderRadius = '0';
      el.style.transform = 'translateX(-50%)';
      el.style.clipPath = 'none';
      if(nlTickStyle.shape==='rounded'){
        el.style.borderRadius = (thick/2)+'px';
      }else if(nlTickStyle.shape==='diamond'){
        // make it a square rotated 45deg; set width=height in px domain via CSS variable
        el.style.height = (thick*2)+'px';
        el.style.width  = (thick*2)+'px';
        el.style.top = (center - (thick*2)*pxToPercent/2) + '%';
        el.style.background = color;
        el.style.transform = 'translateX(-50%) rotate(45deg)';
      }else if(nlTickStyle.shape==='dot'){
        const size = Math.max(4, thick*3);
        el.style.height = size+'px';
        el.style.width  = size+'px';
        el.style.top = (center - size*pxToPercent/2) + '%';
        el.style.borderRadius = '999px';
      }
    });
  }
  function applyTickStyleAll(){
    document.querySelectorAll('.nl-row').forEach(row=>applyTickStyleToRow(row));
  }

  // バー見た目設定（グローバル）
  const nlBarStyle = { opacity: 0.8, theme: 'glass', shape: 'pill', height: 30, guide: false };
  function setBarStyleFromUI(){
    const o = document.getElementById('nlOpacity');
    const t = document.getElementById('nlTheme');
    const s = document.getElementById('nlShape');
    const h = document.getElementById('nlBarHeight');
    const g = document.getElementById('nlGaugeStyle');
    if(o){ nlBarStyle.opacity = Math.max(0.2, Math.min(1, parseFloat(o.value)||0.8)); const v=document.getElementById('nlOpacityVal'); if(v) v.textContent = nlBarStyle.opacity.toFixed(2); }
    if(t){ nlBarStyle.theme = t.value; }
    if(s){ nlBarStyle.shape = s.value; }
    if(h){
      const hv = Math.max(12, Math.min(120, parseFloat(h.value)||nlBarStyle.height||30));
      nlBarStyle.height = hv;
      const hvLabel = document.getElementById('nlHeightVal');
      if(hvLabel) hvLabel.textContent = Math.round(hv) + 'px';
    }
    if(g){ nlBarStyle.guide = (g.value === 'guide'); }
  }
  function hexToRgb(hex){ hex = (hex||'#7dd3fc').replace('#',''); return {r:parseInt(hex.substr(0,2),16), g:parseInt(hex.substr(2,2),16), b:parseInt(hex.substr(4,2),16)}; }
  function applyBarStyle(el, color){
    const {r,g,b} = hexToRgb(color||'#7dd3fc');
    const a = Math.max(0.2, Math.min(1, nlBarStyle.opacity||0.8));
    const base = `rgba(${r},${g},${b},${a})`;
    const light = `rgba(255,255,255,${Math.min(0.65, a*0.8)})`;
    const dark = `rgba(0,0,0,${Math.min(0.35, (1-a)*0.8+0.15)})`;
    const heightPx = Math.max(12, Math.min(120, nlBarStyle.height||30));
    el.style.backdropFilter = '';
    el.style.border = 'none';
    el.style.boxShadow = 'none';
    el.style.background = base;
    el.style.outline = 'none';
    el.style.filter = 'none';
    el.style.color = '#0b1020';
    el.style.textShadow = 'none';
    el.style.height = heightPx + 'px';
    el.style.lineHeight = heightPx + 'px';
    el.style.top = '50%';
    el.style.transform = 'translateY(-50%)';
    if(nlBarStyle.guide){
      const fillA = Math.min(0.65, Math.max(0.2, a*0.9));
      el.style.background = `linear-gradient(90deg, rgba(${r},${g},${b},${fillA*0.6}) 0%, rgba(${r},${g},${b},${fillA}) 100%)`;
      el.style.border = `1.6px dashed rgba(${r},${g},${b},0.85)`;
      el.style.boxShadow = '0 12px 24px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.18)';
      el.style.backdropFilter = 'saturate(130%)';
      el.style.borderRadius = Math.max(12, heightPx/2)+'px';
      el.style.color = '#f8fbff';
      el.style.textShadow = '0 1px 2px rgba(0,0,0,0.35)';
      return;
    }
    switch(nlBarStyle.theme){
      case 'glass':
        el.style.background = `linear-gradient(180deg, ${light} 0%, rgba(255,255,255,0.35) 15%, ${base} 55%, rgba(0,0,0,0.18) 100%)`;
        el.style.backdropFilter = 'saturate(140%) blur(6px)';
        el.style.border = '1px solid rgba(255,255,255,0.4)';
        el.style.boxShadow = 'inset 0 1px 2px rgba(255,255,255,0.8), inset 0 -1px 2px rgba(0,0,0,0.15), 0 4px 10px rgba(0,0,0,0.25)';
        break;
      case 'metal':
        el.style.background = `linear-gradient(90deg, rgba(255,255,255,${Math.min(0.20,a)}) 0%, ${base} 12%, rgba(0,0,0,${Math.min(0.18,1-a)}) 50%, ${base} 88%, rgba(255,255,255,${Math.min(0.20,a)}) 100%)`;
        el.style.boxShadow = 'inset 0 1px 0 rgba(255,255,255,0.3), inset 0 -1px 0 rgba(0,0,0,0.25), 0 2px 8px rgba(0,0,0,0.25)';
        el.style.border = '1px solid rgba(255,255,255,0.25)';
        break;
      case 'gradient':
        el.style.background = `linear-gradient(90deg, ${base} 0%, rgba(${r},${g},${b},${Math.max(0.25,a-0.15)}) 100%)`;
        el.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
        break;
      case 'neon':
        el.style.background = base;
        el.style.boxShadow = `0 0 12px rgba(${r},${g},${b},${Math.min(0.9, a)}), 0 0 24px rgba(${r},${g},${b},${Math.min(0.6, a)})`;
        el.style.color = '#0f172a';
        break;
      case 'outline':
        el.style.background = 'transparent';
        el.style.border = `2px solid ${base}`;
        break;
      case 'solid':
      default:
        el.style.background = base;
        el.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
        break;
    }
    switch(nlBarStyle.shape){
      case 'rect':
        el.style.borderRadius='4px';
        break;
      case 'underline':
        el.style.borderRadius='3px';
        el.style.height='8px';
        el.style.lineHeight='8px';
        el.style.top='60%';
        break;
      case 'bevel':
        el.style.borderRadius='10px 4px 10px 4px';
        break;
      case 'pill':
      default:
        el.style.borderRadius=Math.max(8, heightPx/2)+'px';
        break;
    }
  }
  function nlLoadDigitalMode(){
    try{
      const val = localStorage.getItem(NL_DIGITAL_MODE_KEY)||'off';
      return (val==='mode1' || val==='mode2' || val==='planner' || val==='off') ? val : 'off';
    }catch(e){ return 'off'; }
  }
  function nlSaveDigitalMode(v){ try{ localStorage.setItem(NL_DIGITAL_MODE_KEY, v); }catch(e){} }
  nlDigitalState.mode = nlLoadDigitalMode();
  function nlApplyDigitalModeButtons(){
    document.querySelectorAll('[data-nl-digital-mode]').forEach(btn=>{
      btn.classList.toggle('active', (btn.dataset.nlDigitalMode||'off')===nlDigitalState.mode);
    });
  }
  function nlSetDigitalMode(mode){
    const next = mode || 'off';
    if(nlDigitalState.mode === next){
      nlApplyDigitalModeButtons();
      return;
    }
    nlDigitalState.mode = next;
    nlSaveDigitalMode(next);
    nlApplyDigitalModeButtons();
    try{ nlRebuildAll(); }catch(_){}
  }
  function nlRegisterDigitalDisplay(entry){
    nlDigitalState.displays.push(entry);
  }
  function nlCreateDigitalBlock(mode){
    const wrap = document.createElement('div');
    wrap.className = mode==='mode1' ? 'nl-digital-row' : 'nl-digital-inline';
    const face = document.createElement('div');
    face.className = 'nl-digital-face';
    const time = document.createElement('span'); time.className='nl-digital-time'; time.textContent='--:--';
    const sec = document.createElement('span'); sec.className='nl-digital-sec'; sec.textContent='--';
    face.appendChild(time); face.appendChild(sec);
    wrap.appendChild(face);
    nlRegisterDigitalDisplay({time, sec});
    nlUpdateDigitalDisplays(Date.now());
    return wrap;
  }
  function nlMirrorPlannerClock(){
    if(!nlPlannerMirrorHost){
      nlStopPlannerClockMirror();
      return;
    }
    if(!nlPlannerMirrorHost.isConnected){
      return;
    }
    if(!plannerClockWrap) return;
    const clone = plannerClockWrap.cloneNode(true);
    clone.classList.add('nl-planner-clock-clone');
    const hint = clone.querySelector('#hint');
    if(hint && hint.parentNode) hint.remove();
    nlPlannerMirrorHost.innerHTML='';
    nlPlannerMirrorHost.appendChild(clone);
  }
  function nlStopPlannerClockMirror(){
    if(nlPlannerMirrorHost){
      nlPlannerMirrorHost.innerHTML='';
      nlPlannerMirrorHost = null;
    }
  }
  function nlStartPlannerClockMirror(host){
    nlStopPlannerClockMirror();
    if(!host) return;
    nlPlannerMirrorHost = host;
    nlMirrorPlannerClock();
    if(typeof requestAnimationFrame==='function'){
      requestAnimationFrame(()=>{ nlMirrorPlannerClock(); });
    }
  }
  function nlCreatePlannerClockBlock(){
    const wrap = document.createElement('div');
    wrap.className = 'nl-planner-clock-wrap';
    const host = document.createElement('div');
    host.className = 'nl-planner-clock-host';
    wrap.appendChild(host);
    nlStartPlannerClockMirror(host);
    return wrap;
  }
  function nlUpdateDigitalDisplays(nowMs){
    const d = new Date(nowMs || Date.now());
    const hh = pad2(d.getHours());
    const mm = pad2(d.getMinutes());
    const ss = pad2(d.getSeconds());
    nlDigitalState.displays.forEach(entry=>{
      if(entry.time) entry.time.textContent = `${hh}:${mm}`;
      if(entry.sec) entry.sec.textContent = ss;
    });
  }
  function bindNLDigitalControls(){
    const buttons = document.querySelectorAll('[data-nl-digital-mode]');
    if(!buttons.length) return;
    buttons.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        nlSetDigitalMode(btn.dataset.nlDigitalMode || 'off');
      });
    });
    nlApplyDigitalModeButtons();
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bindNLDigitalControls);
  }else{
    bindNLDigitalControls();
  }
  if(nlDigitalState.mode && nlDigitalState.mode!=='off'){
    setTimeout(()=>{ try{ nlRebuildAll(); }catch(_){}; }, 0);
  }
  function initPlannerOpacityControl(){
    const slider = document.getElementById('plannerOpacity');
    const val = document.getElementById('plannerOpacityVal');
    if(!slider) return;
    const setVal = (v)=>{
      const clamped = Math.max(0.2, Math.min(1, v||plannerBarStyle.opacity||0.9));
      plannerBarStyle.opacity = clamped;
      if(val) val.textContent = clamped.toFixed(2);
      savePlannerOpacity(clamped);
      drawPlanner();
    };
    slider.value = String(plannerBarStyle.opacity);
    if(val) val.textContent = Number(plannerBarStyle.opacity).toFixed(2);
    slider.addEventListener('input', ()=>{ setVal(parseFloat(slider.value)||plannerBarStyle.opacity); });
  }
  function initPlannerHeightControl(){
    const slider = document.getElementById('plannerHeight');
    const val = document.getElementById('plannerHeightVal');
    if(!slider) return;
    const clamp = (v)=>Math.max(8, Math.min(80, isFinite(v)?v:(plannerBarStyle.thickness||24)));
    const setVal = (raw)=>{
      const clamped = clamp(raw);
      plannerBarStyle.thickness = clamped;
      if(val) val.textContent = Math.round(clamped) + 'px';
      savePlannerThickness(clamped);
      drawPlanner();
    };
    const initVal = clamp(plannerBarStyle.thickness);
    slider.value = String(initVal);
    if(val) val.textContent = Math.round(initVal) + 'px';
    slider.addEventListener('input', ()=>{ setVal(parseFloat(slider.value)); });
  }
  function initPlannerGaugeStyleControl(){
    const select = document.getElementById('plannerGaugeStyle');
    if(!select) return;
    const apply = (value)=>{
      const isGuide = value === 'guide';
      plannerBarStyle.guideLook = isGuide;
      savePlannerGuideStyle(isGuide);
      drawPlanner();
    };
    select.value = plannerBarStyle.guideLook ? 'guide' : 'standard';
    select.addEventListener('change', ()=>apply(select.value));
  }

  function nlPad(n){ return (n<10?'0':'')+n; }
  function nlHexToRgba(hex,a){
    if(!hex) return `rgba(125,211,252,${a})`;
    const m = hex.replace('#','');
    const r = parseInt(m.substring(0,2),16);
    const g = parseInt(m.substring(2,4),16);
    const b = parseInt(m.substring(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }
  function nlRebuildAll(){
  const cont = $('nlRows');
  nlStopPlannerClockMirror();
  if(!cont) return;
  cont.innerHTML='';
  clearNlDragPreview();
  nlDigitalState.displays = [];
  const digitalMode = nlDigitalState.mode || 'off';
  let digitalPlaced = false;
  const count = parseInt(($('nlRowCount')||{value:2}).value,10);
  const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
  const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
  for(let i=0;i<count;i++){
    const slotStart = new Date(base.getTime() + i*60*60000);
    nlBuildRow(slotStart, i===0);
    if(!digitalPlaced && digitalMode!=='off' && i===0){
      if(digitalMode==='planner'){
        cont.appendChild(nlCreatePlannerClockBlock());
      }else{
        cont.appendChild(nlCreateDigitalBlock(digitalMode));
      }
      digitalPlaced = true;
    }
  }
  applyTickStyleAll();

  // === Responsive: keep bars & hands aligned on resize ===
  (function(){
    const root = document.getElementById('nlRows');
    if(!root || typeof ResizeObserver==='undefined') return;
    const ro = new ResizeObserver(()=>{
      const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
      document.querySelectorAll('.nl-row').forEach(row=>{
        // re-render bars
        nlRenderBarsForHour(row);
        // update hands if current
        const isCurrent = row.classList.contains('current');
        const sHand = row.querySelector('.nl-hand.s');
        const mHand = row.querySelector('.nl-hand.m');
        if(isCurrent){
          if(sHand) sHand.style.left = (nowD.getSeconds()/60*100)+'%';
          if(mHand) mHand.style.left = (nowD.getMinutes()/60*100)+'%';
        }
      });
      nlUpdateETA && nlUpdateETA();
    });
    ro.observe(root);
  })();


  // === ETA seconds toggle ===
  const NL_SEC_KEY = "nl_eta_show_seconds";
  function nlLoadShowSeconds(){ try{ return localStorage.getItem(NL_SEC_KEY)==='1'; }catch(e){ return false; } }
  function nlSaveShowSeconds(v){ try{ localStorage.setItem(NL_SEC_KEY, v?'1':'0'); }catch(e){} }
  (function(){
    const cb = document.getElementById('nlShowSeconds');
    if(cb){ cb.checked = nlLoadShowSeconds(); cb.onchange = ()=>nlSaveShowSeconds(cb.checked); }
  })();


  // ===== Fullscreen handling =====
  function nlEnterFullscreen(){
    const cont = document.createElement('div'); cont.className='nl-fullscreen'; cont.id='nlFS';
    const close = document.createElement('button'); close.className='nl-fs-close'; close.textContent='閉じる';
    close.onclick = ()=>{ const fs=document.getElementById('nlFS'); if(fs) fs.remove(); nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 };
    cont.appendChild(close);
    document.body.appendChild(cont);
    // Build a fresh current-hour row inside fullscreen
    const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
    const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
    const row = nlBuildRow(base, true);
    cont.appendChild(row);
  }
  (function(){ const btn=document.getElementById('nlFullscreenBtn'); if(btn) btn.onclick=nlEnterFullscreen; })();

}
  function nlBuildRow(startDate, isCurrent){
  const wrap = $('nlRows'); if(!wrap) return;
  const row = document.createElement('div'); row.className='nl-row';
  if(isCurrent){ row.classList.add('current'); }
  row.dataset.startTs = startDate.getTime();
  const hour = startDate.getHours();
  const badge = document.createElement('div'); badge.className='nl-hourBadge'; badge.textContent = `${hour}時`;
    const rail  = document.createElement('div'); rail.className='nl-rail';
    const scale = document.createElement('div'); scale.className='nl-scale';
    const lane = document.createElement('div'); lane.className='nl-lane';
    const track = document.createElement('div'); track.className='nl-track';
    const ticks = document.createElement('div'); ticks.className='nl-ticks';
    for(let i=0;i<=60;i++){
      const t = document.createElement('div'); t.className='nl-tick'+(i%5===0?' major':''); ticks.appendChild(t);
      if(i%5===0){ const lab = document.createElement('div'); lab.className='nl-label'; lab.textContent=i; ticks.appendChild(lab); }
    }
    const mHand=document.createElement('div'); mHand.className='nl-hand m';
    const sHand=document.createElement('div'); sHand.className='nl-hand s';
    const bars=document.createElement('div'); bars.className='nl-bars';
    const cap=document.createElement('div'); cap.className='nl-cap'; cap.innerHTML='<span>0</span><span></span>';

    lane.appendChild(track);
lane.appendChild(ticks);
lane.appendChild(bars);
lane.appendChild(mHand);
lane.appendChild(sHand);
    scale.appendChild(lane);
rail.appendChild(scale);
rail.appendChild(cap);
    row.appendChild(badge); row.appendChild(rail);
    wrap.appendChild(row);

    // レイアウト
    const rect = scale.getBoundingClientRect(); const w = rect.width||600;
    // 0〜60（61本）: %配置
    ticks.querySelectorAll('.nl-tick').forEach((el, idx)=>{ el.style.left = (idx/60*100)+'%'; });
    ticks.querySelectorAll('.nl-label').forEach((el, idx)=>{ el.style.left = ((idx*5)/60*100)+'%'; });
// 針
    // bars layer width = scale width (to align coordinate origins)
    // responsive: width via left/right; no fixed px width
const eta = document.createElement('div'); eta.className='nl-eta'; eta.textContent='--';
    lane.appendChild(eta);
const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
    const min = isCurrent ? nowD.getMinutes() : 0;
    const sec = isCurrent ? nowD.getSeconds() : 0;
    mHand.style.left = (min/60*100)+'%'; sHand.style.left=(sec/60*100)+'%';
    // バー
    nlRenderBarsForHour(row);
    return row;
  }
  function nlPosForMinute(row, minute){
    const rect = row.querySelector('.nl-lane')?.getBoundingClientRect();
    if(!rect) return 0;
    return (minute/60)*(rect.width||600);
  }
  function nlRenderBarsForHour(row){
  const barsEl = row.querySelector('.nl-bars'); barsEl.innerHTML='';
  const startTs = Number(row.dataset.startTs||0);
  const hourStart = new Date(startTs);
  const hourEnd   = new Date(startTs + 60*60000);
  const list = NLStore.listBetween(hourStart.getTime(), hourEnd.getTime());
    list.forEach(ev=>{
      const os = new Date(Math.max(ev.start, hourStart.getTime()));
      const oe = new Date(Math.min(ev.end,   hourEnd.getTime()));
      if(oe<=os) return;
      const startMin = (os - hourStart)/60000;
      const endMin   = (oe - hourStart)/60000;
      const leftPct  = (clamp(startMin,0,60)/60)*100;
const rightPct = (clamp(endMin,0,60)/60)*100;
const widthPct = Math.max(0.5, rightPct-leftPct);
const bar = document.createElement('div'); bar.className='nl-bar';
bar.style.left  = leftPct + '%';
bar.style.width = widthPct + '%';
      bar.style.zIndex = '1';
      bar.style.background = nlHexToRgba(ev.color||'#7dd3fc', 0.68);
      bar.style.borderColor = nlHexToRgba('#ffffff', 0.35);
      bar.title = `${ev.title}（${pad2(os.getHours())}:${pad2(os.getMinutes())}〜${pad2(oe.getHours())}:${pad2(oe.getMinutes())}）`;
      bar.textContent = ev.title;
      barsEl.appendChild(bar);
      applyBarStyle(bar, ev.color||'#7dd3fc');
    });
  }
  function nlStepMinute(){
    const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
    document.querySelectorAll('.nl-row').forEach((row,i)=>{
      if(i===0){
        const mHand = row.querySelector('.nl-hand.m');
        const sHand = row.querySelector('.nl-hand.s');
        mHand.style.left = (nowD.getMinutes()/60*100)+'%';
        sHand.style.left = (nowD.getSeconds()/60*100)+'%';
      }
      nlRenderBarsForHour(row);
    });
  }
  function nlStartTimers(){
    // 分境界に同期
    const alignMin = ()=>{
      const n = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date())); const ms = (60-n.getSeconds())*1000 - n.getMilliseconds();
      setTimeout(()=>{ nlStepMinute(); setInterval(nlStepMinute, 60000); }, ms);
    };
    alignMin();
    // 1秒針更新
    setInterval(()=>{
      const rows = Array.from(document.querySelectorAll('.nl-row'));
  rows.forEach(r=>{ r.__nlStack=0; r.__nlOuterStack=0; });
      if(!rows.length) return;
      const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
      rows.forEach(row=>{
        const isCurrent = row.classList.contains('current') || ( ()=>{
          const ts = parseInt(row.dataset.startTs||'0',10);
          const d = new Date(ts);
          return d.getHours()===nowD.getHours() && d.getDate()===nowD.getDate() && d.getMonth()===nowD.getMonth() && d.getFullYear()===nowD.getFullYear();
        })();
        const sHand = row.querySelector('.nl-hand.s');
        const mHand = row.querySelector('.nl-hand.m');
        if(isCurrent){
          if(sHand) sHand.style.left = (nowD.getSeconds()/60*100)+'%';
          if(mHand) mHand.style.left = (nowD.getMinutes()/60*100)+'%';
        }else{
          if(sHand) sHand.style.left = '0%';
          if(mHand) mHand.style.left = '0%';
        }
      });
    }, 1000);
    // 時の境目で行を再生成
    setInterval(()=>{
      const n=(window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
      if(n.getMinutes()===0 && n.getSeconds()<2){ nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 }
    }, 1000);
  }

  
  
  
  function nlUpdateETA(secondAligned){
    const now = secondAligned ? (Date.now() - (Date.now()%1000)) : Date.now();
    const showSec = (function(){ try{ return localStorage.getItem('nl_eta_show_seconds')==='1'; }catch(e){ return false; } })();
    document.querySelectorAll('.nl-row').forEach(row=>{
      const hourStart = parseInt(row.dataset.startTs||'0',10);
      const hourEnd = hourStart + 60*60000;
      const etaEl = row.querySelector('.nl-eta'); if(!etaEl) return;
      const evs = (NLStore.events||[]).filter(ev=> ev.start < ev.end && ev.start < hourEnd && ev.end > hourStart);
      let remainMs = null, curTitle = null;
      for(const ev of evs){
        if(now>=ev.start && now<ev.end){ remainMs = Math.max(0, ev.end - now); curTitle = (ev.title||'予定').toString(); break; }
      }
      if(remainMs===null){ etaEl.style.display='none'; }
      else {
        etaEl.style.display='block';
        if(showSec){
          const totalSec = Math.max(0, Math.floor(remainMs/1000));
          const mm = Math.floor(totalSec/60);
          const ss = totalSec%60;
          const ssPad = String(ss).padStart(2,'0');
          etaEl.textContent = mm>0 ? `${curTitle} (${mm}分${ssPad}秒)` : `${curTitle} (${ssPad}秒)`;
        }else{
          const mins = Math.max(0, Math.ceil(remainMs/60000));
          etaEl.textContent = `${curTitle} (${mins}分)`;
        }
      }
    });
  }
  // ============== 入力 → NLStore 追加 ==============
  function nlAddFromInputs(){
    const title = ($('nlTitle')||{value:''}).value.trim() || "予定";
    const sVal  = ($('nlStart')||{value:''}).value;
    const eVal  = ($('nlEnd')  ||{value:''}).value;
    const color = ($('nlColor')||{value:'#7dd3fc'}).value;
    const msg = $('nlMsg'); if(msg) msg.textContent='';
    if(!sVal || !eVal){ if(msg) msg.textContent='開始と終了を入力してください。'; return; }
    const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
    const [sh,sm] = sVal.split(':').map(Number);
    const [eh,em] = eVal.split(':').map(Number);
    let s = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), sh, sm||0, 0, 0);
    let e = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), eh, em||0, 0, 0);
    if(e <= s){ e = new Date(e.getTime()+24*60*60000); } // 翌日跨ぎに対応
    NLStore.addAbs(s,e,title,color,"normal");
    NLStore.save();
    // 再描画
    drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    // 予定一覧も更新
    renderList();
    try{ scheduleStudyWatchdog(); }catch(e){}

  }

  // ============== 既存「追加」UIも NLStore に接続 ==============
  function addEventFromPlannerInputs(){
    const mode = $('mode') ? $('mode').value : 'day';
    const s = $('start').value.split(':').map(Number);
    const e = $('end').value.split(':').map(Number);
    const label = ($('label')||{value:''}).value.trim() || '予定';
    const color = ($('color')||{value:'#4da3ff'}).value;
    if(s.length<2||e.length<2) { alert('時間を入力'); return; }
    const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
    let start, end;
    if(mode==='hour'){
      // 現在の時間をベースに「分」だけ反映
      const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
      start = new Date(base.getTime() + (s[1]%60)*60000);
      end   = new Date(base.getTime() + (e[1]%60)*60000);
      if(end<=start){ end = new Date(end.getTime()+60*60000); }
    }else{
      // 12時間面: 時分をそのまま絶対化（現在の半日ブロックに投影）
      const half = (nowD.getHours()>=12?12:0);
      start = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), half + (s[0]%12), s[1]%60, 0, 0);
      end   = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), half + (e[0]%12), e[1]%60, 0, 0);
      if(end<=start){ end = new Date(end.getTime()+12*60*60000); }
    }
    NLStore.addAbs(start,end,label,color,"normal");
    NLStore.save();
    ($('label')||{}).value='';
    drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    renderList();
    try{ scheduleStudyWatchdog(); }catch(e){}

  }

  // ============== 予定一覧（削除だけ提供） ==============
  function renderList(){
    const containers = [$('list'), $('nlList')].filter(Boolean);
    if(containers.length===0) return;
    containers.forEach(c=>c.innerHTML='');
    const evs = NLStore.events.slice().sort((a,b)=>a.start-b.start);
    evs.forEach(ev=>{
      containers.forEach(cont=>cont.appendChild(createListItem(ev)));
    });
  }

  function createListItem(ev){
    const div = document.createElement('div'); div.className='item';
    const left = document.createElement('div'); left.style.display='flex'; left.style.gap='8px'; left.style.alignItems='center';
    const badge = document.createElement('div'); badge.className='badge'; badge.style.background=ev.color;
    const txt = document.createElement('div'); txt.textContent = ev.title;
    left.appendChild(badge); left.appendChild(txt);
    const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px'; right.style.alignItems='center';
    const time = document.createElement('span'); time.className='tiny';
    const s = new Date(ev.start), e = new Date(ev.end);
    time.textContent = `${toHM(s)} – ${toHM(e)}`;
    const edit = document.createElement('button'); edit.className='ghost'; edit.textContent='編集';
    edit.style.padding='4px 8px'; edit.style.fontSize='12px';
    edit.onclick = ()=>openEventEditor(ev.id);
    const del = document.createElement('button'); del.className='danger'; del.textContent='削除';
    del.style.padding='4px 8px'; del.style.fontSize='12px';
    del.onclick = ()=>{ NLStore.removeById(ev.id); renderList();
    try{ scheduleStudyWatchdog(); }catch(e){}
 drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 };
    right.appendChild(time); right.appendChild(edit); right.appendChild(del);
    div.appendChild(left); div.appendChild(right);
    return div;
  }

  function openEventEditor(id){
    const ev = NLStore.events.find(e=>e.id===id);
    if(!ev) return;
    openEventDialog({
      heading:'予定を編集',
      title: ev.title,
      color: ev.color || '#4da3ff',
      start: new Date(ev.start),
      end: new Date(ev.end),
      note:`開始 ${formatDateTime(new Date(ev.start))} / 終了 ${formatDateTime(new Date(ev.end))}`,
      onSave:(payload)=>{
        ev.title = payload.title;
        ev.color = payload.color;
        ev.start = payload.start.getTime();
        ev.end = payload.end.getTime();
        NLStore.save();
        drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
        try{ scheduleStudyWatchdog(); }catch(e){}
        nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
        try{ scheduleStudyWatchdog(); }catch(e){}
        renderList();
      }
    });
  }

  function toLocalInputValue(date){
    const d = new Date(date);
    if(isNaN(d)) return '';
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const day = String(d.getDate()).padStart(2,'0');
    const hh = String(d.getHours()).padStart(2,'0');
    const mm = String(d.getMinutes()).padStart(2,'0');
    return `${y}-${m}-${day}T${hh}:${mm}`;
  }

  function fromLocalInputValue(value){
    if(!value) return null;
    const [date, time] = value.split('T');
    if(!date || !time) return null;
    const [y, mo, d] = date.split('-').map(Number);
    const [hh, mm] = time.split(':').map(Number);
    if([y,mo,d,hh,mm].some(v=>isNaN(v))) return null;
    return new Date(y, (mo||1)-1, d||1, hh||0, mm||0, 0, 0);
  }

  function formatDateTime(date){
    const d = new Date(date);
    if(isNaN(d)) return '--';
    return `${d.getMonth()+1}/${d.getDate()} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
  }

  function openEventDialog(opts){
    const {heading='予定を追加', title='新規予定', color='#4da3ff', start=new Date(), end=new Date(Date.now()+1800000), onSave, note=''} = opts || {};
    const overlay = document.createElement('div'); overlay.className='quick-dialog-backdrop';
    const card = document.createElement('div'); card.className='quick-dialog-card';
    const titleInput = document.createElement('input'); titleInput.type='text'; titleInput.value=title;
    const colorInput = document.createElement('input'); colorInput.type='color'; colorInput.value=color||'#4da3ff';
    const startInput = document.createElement('input'); startInput.type='datetime-local'; startInput.step='60'; startInput.value = toLocalInputValue(start);
    const endInput = document.createElement('input'); endInput.type='datetime-local'; endInput.step='60'; endInput.value = toLocalInputValue(end);
    const actionWrap = document.createElement('div'); actionWrap.className='quick-dialog-actions';
    const cancelBtn = document.createElement('button'); cancelBtn.className='ghost'; cancelBtn.textContent='キャンセル';
    const saveBtn = document.createElement('button'); saveBtn.textContent='保存';
    actionWrap.appendChild(cancelBtn); actionWrap.appendChild(saveBtn);
    card.innerHTML = '';
    const headingEl = document.createElement('h3'); headingEl.textContent = heading;
    card.appendChild(headingEl);
    if(note){
      const noteEl = document.createElement('div'); noteEl.className='tiny'; noteEl.style.marginBottom='6px'; noteEl.textContent = note;
      card.appendChild(noteEl);
    }
    const titleLabel = document.createElement('label'); titleLabel.textContent='タイトル';
    card.appendChild(titleLabel); card.appendChild(titleInput);
    const colorLabel = document.createElement('label'); colorLabel.textContent='カラー';
    card.appendChild(colorLabel); card.appendChild(colorInput);
    const startLabel = document.createElement('label'); startLabel.textContent='開始';
    card.appendChild(startLabel); card.appendChild(startInput);
    const endLabel = document.createElement('label'); endLabel.textContent='終了';
    card.appendChild(endLabel); card.appendChild(endInput);
    card.appendChild(actionWrap);
    overlay.appendChild(card);
    document.body.appendChild(overlay);

    function close(){ overlay.remove(); document.removeEventListener('keydown', onKey); }
    function onKey(e){ if(e.key==='Escape'){ close(); } }
    document.addEventListener('keydown', onKey);
    overlay.addEventListener('click', e=>{ if(e.target===overlay) close(); });
    cancelBtn.onclick = close;
    saveBtn.onclick = ()=>{
      const s = fromLocalInputValue(startInput.value);
      const e = fromLocalInputValue(endInput.value);
      if(!s || !e || e<=s){ alert('開始・終了時刻を確認してください。'); return; }
      const payload = {
        title: titleInput.value.trim() || '新規予定',
        color: colorInput.value || '#4da3ff',
        start: s,
        end: e
      };
      if(typeof onSave === 'function'){ onSave(payload); }
      close();
    };
  }

  const plannerDirectState = {
    enabled:false,
    dragging:false,
    startMinute:null,
    currentMinute:null,
    pointerId:null,
    overlayGroup:null,
    overlayFill:null,
    overlayEdge:null,
    label:null
  };
  function getPlannerTotalMinutes(){ const modeSel = $('mode'); return (modeSel && modeSel.value==='hour')?60:720; }
  function getPlannerBaseDate(){
    const nowD = (window.__getNow?window.__getNow():new Date());
    const modeSel = $('mode'); const mode = modeSel ? modeSel.value : 'hour';
    if(mode==='hour'){
      return new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
    }
    const half = nowD.getHours()>=12 ? 12 : 0;
    return new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), half, 0, 0, 0);
  }
  function plannerMinuteToDate(minute){
    const base = getPlannerBaseDate();
    return new Date(base.getTime() + minute*60000);
  }
  function plannerMinuteFromEvent(evt){
    const svg = document.getElementById('clock'); if(!svg) return null;
    const rect = svg.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const mx = evt.clientX;
    const my = evt.clientY;
    const angle = Math.atan2(my - cy, mx - cx) + Math.PI/2;
    let norm = angle;
    if(norm < 0) norm += Math.PI*2;
    const total = getPlannerTotalMinutes();
    const minute = Math.round(norm / (Math.PI*2) * total);
    return Math.max(0, Math.min(total, minute));
  }
  function ensurePlannerOverlay(){
    const svgEl = document.getElementById('clock');
    if(!svgEl) return null;
    let group = plannerDirectState.overlayGroup;
    if(group && !group.isConnected){
      group = null;
      plannerDirectState.overlayGroup = null;
      plannerDirectState.overlayFill = null;
      plannerDirectState.overlayEdge = null;
    }
    if(!group){
      group = document.createElementNS('http://www.w3.org/2000/svg','g');
      group.id = 'plannerDirectGroup';
      const fill = document.createElementNS('http://www.w3.org/2000/svg','path');
      fill.classList.add('guide-fill');
      const edge = document.createElementNS('http://www.w3.org/2000/svg','path');
      edge.classList.add('guide-edge');
      group.appendChild(fill);
      group.appendChild(edge);
      group.style.opacity='0';
      const hands = document.getElementById('hands');
      if(hands && hands.parentNode===svgEl){
        svgEl.insertBefore(group, hands);
      }else{
        svgEl.appendChild(group);
      }
      plannerDirectState.overlayGroup = group;
      plannerDirectState.overlayFill = fill;
      plannerDirectState.overlayEdge = edge;
    }
    return plannerDirectState.overlayGroup;
  }
  function plannerUpdateOverlay(){
    const overlay = ensurePlannerOverlay();
    const fill = plannerDirectState.overlayFill;
    const edge = plannerDirectState.overlayEdge;
    const label = ensurePlannerGuideLabel();
    if(!overlay || !fill || !edge) return;
    if(plannerDirectState.dragging && plannerDirectState.startMinute!=null && plannerDirectState.currentMinute!=null){
      const total = getPlannerTotalMinutes();
      let start = plannerDirectState.startMinute;
      let end = plannerDirectState.currentMinute;
      if(end <= start) end += total;
      const angleStart = minToAng(start, total);
      const angleEnd = minToAng(end, total);
      const pathData = sectorPath(250,250, 228, 188, angleStart, angleEnd);
      fill.setAttribute('d', pathData);
      edge.setAttribute('d', pathData);
      overlay.style.opacity='1';
      if(label){
        const startDate = plannerMinuteToDate(startMin % total);
        const endDate = new Date(startDate.getTime() + duration);
        label.textContent = `${toHM(startDate)} – ${toHM(endDate)} / ${Math.round(duration/60000)}分`;
        label.style.display='block';
      }
    }else{
      overlay.style.opacity='0';
      if(label) label.style.display='none';
    }
  }
  function initPlannerDirectMode(){
    const btn = $('plannerDirectToggle');
    const svg = document.getElementById('clock');
    if(!btn || !svg) return;
    const updateBtn = ()=>{ btn.textContent = plannerDirectState.enabled ? '直接モード:ON' : '直接モード:OFF'; btn.classList.toggle('active', plannerDirectState.enabled); };
    btn.addEventListener('click', ()=>{
      plannerDirectState.enabled = !plannerDirectState.enabled;
      if(!plannerDirectState.enabled){
        plannerDirectState.dragging=false; plannerUpdateOverlay();
      }
      updateBtn();
    });
    updateBtn();
    svg.addEventListener('pointerdown', (e)=>{
      if(!plannerDirectState.enabled) return;
      const minute = plannerMinuteFromEvent(e);
      if(minute===null) return;
      plannerDirectState.dragging = true;
      plannerDirectState.startMinute = minute;
      plannerDirectState.currentMinute = minute;
      plannerDirectState.pointerId = e.pointerId;
      plannerDirectState.dragStartTime = Date.now();
      plannerDirectState.dragTriggerTimer = setTimeout(()=>{
        if(plannerDirectState.dragging && plannerDirectState.pointerId === e.pointerId){
          try{ svg.setPointerCapture(e.pointerId); }catch(_){ }
          plannerUpdateOverlay();
        }
      }, 150);
      e.preventDefault();
    });
    const moveHandler = (e)=>{
      if(!plannerDirectState.dragging || e.pointerId!==plannerDirectState.pointerId) return;
      const minute = plannerMinuteFromEvent(e);
      if(minute===null) return;
      plannerDirectState.currentMinute = minute;
      plannerUpdateOverlay();
    };
    const endHandler = (e)=>{
      if(!plannerDirectState.dragging || e.pointerId!==plannerDirectState.pointerId) return;
      if(plannerDirectState.dragTriggerTimer){
        clearTimeout(plannerDirectState.dragTriggerTimer);
        plannerDirectState.dragTriggerTimer = null;
      }
      if(plannerDirectState.dragStartTime && Date.now() - plannerDirectState.dragStartTime < 120){
        plannerDirectState.dragging = false;
        plannerDirectState.startMinute = null;
        plannerDirectState.currentMinute = null;
        return;
      }
      try{ svg.releasePointerCapture(e.pointerId); }catch(_){}
      plannerDirectState.dragging = false;
      const start = plannerDirectState.startMinute;
      const end = plannerDirectState.currentMinute;
      plannerDirectState.startMinute = null;
      plannerDirectState.currentMinute = null;
      plannerUpdateOverlay();
      if(start==null || end==null || Math.abs(end-start)<1) return;
      const total = getPlannerTotalMinutes();
      let startMin = start;
      let endMin = end;
      if(endMin <= startMin) endMin += total;
      const duration = (endMin - startMin)*60000;
      const startDate = plannerMinuteToDate(startMin%total);
      const endDate = new Date(startDate.getTime() + duration);
      openEventDialog({
        heading:'時計から予定を追加',
        note:`開始 ${formatDateTime(startDate)} / 終了 ${formatDateTime(endDate)}`,
        start:startDate,
        end:endDate,
        onSave:({title,color,start,end})=>{
          NLStore.addAbs(start,end,title,color,"normal");
          NLStore.save();
          drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(err){}
          try{ scheduleStudyWatchdog(); }catch(err){}
          nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(err){}
          try{ scheduleStudyWatchdog(); }catch(err){}
          renderList();
        }
      });
    };
    svg.addEventListener('pointermove', moveHandler);
    svg.addEventListener('pointerup', endHandler);
    svg.addEventListener('pointerleave', (e)=>{
      if(plannerDirectState.dragging){ endHandler(e); }
    });
  }

  const nlDirectState = { enabled:false, dragging:false, startTs:null, currentTs:null, pointerId:null };
  function snapToMinute(ts){ return Math.round(ts/60000)*60000; }
  function getNlTimeFromEvent(e){
    const target = e.target.closest('.nl-row');
    if(!target) return null;
    const lane = target.querySelector('.nl-lane');
    if(!lane) return null;
    const rect = lane.getBoundingClientRect();
    if(rect.width===0) return null;
    const ratio = Math.max(0, Math.min(1, (e.clientX - rect.left)/rect.width));
    const startTs = parseInt(target.dataset.startTs||'0',10);
    const ts = startTs + ratio*60*60000;
    return {timestamp: snapToMinute(ts), row: target};
  }
  function ensureNlGuide(row){
    if(!row) return null;
    const lane = row.querySelector('.nl-lane');
    if(!lane) return null;
    let guide = row.__nlGuide;
    if(guide && !guide.isConnected){ guide = null; row.__nlGuide = null; }
    if(!guide){
      guide = document.createElement('div');
      guide.className='nl-direct-guide';
      lane.appendChild(guide);
      row.__nlGuide = guide;
    }
    return guide;
  }
  function clearNlDragPreview(){
    document.querySelectorAll('.nl-direct-guide').forEach(el=>el.classList.remove('show'));
  }
  function renderNlDragPreview(startMs,endMs){
    clearNlDragPreview();
    const min = Math.min(startMs,endMs);
    const max = Math.max(startMs,endMs);
    if(max - min < 60000) return;
    const rows = document.querySelectorAll('.nl-row');
    rows.forEach(row=>{
      const startTs = parseInt(row.dataset.startTs||'0',10);
      const endTs = startTs + 60*60000;
      const overlapStart = Math.max(startTs, min);
      const overlapEnd = Math.min(endTs, max);
      if(overlapEnd <= overlapStart) return;
      const guide = ensureNlGuide(row);
      if(!guide) return;
      const startRatio = ((overlapStart - startTs)/60000)/60;
      const endRatio = ((overlapEnd - startTs)/60000)/60;
      const left = Math.max(0, Math.min(100, startRatio*100));
      const width = Math.max(1.5, Math.min(100-left, (endRatio-startRatio)*100));
      guide.style.left = left + '%';
      guide.style.width = width + '%';
      guide.classList.add('show');
    });
  }
  function initNlDirectMode(){
    const btn = $('nlDirectToggle');
    const rows = $('nlRows');
    if(!btn || !rows) return;
    const updateBtn = ()=>{ btn.textContent = nlDirectState.enabled ? '直接モード:ON' : '直接モード:OFF'; btn.classList.toggle('active', nlDirectState.enabled); };
    btn.addEventListener('click', ()=>{
      nlDirectState.enabled = !nlDirectState.enabled;
      if(!nlDirectState.enabled){
        nlDirectState.dragging=false; clearNlDragPreview();
      }
      updateBtn();
    });
    updateBtn();
    rows.addEventListener('pointerdown', (e)=>{
      if(!nlDirectState.enabled) return;
      const info = getNlTimeFromEvent(e);
      if(!info) return;
      nlDirectState.dragging = true;
      nlDirectState.startTs = info.timestamp;
      nlDirectState.currentTs = info.timestamp;
      nlDirectState.pointerId = e.pointerId;
      e.target.setPointerCapture(e.pointerId);
      renderNlDragPreview(nlDirectState.startTs, nlDirectState.currentTs);
      e.preventDefault();
    });
    const moveHandler = (e)=>{
      if(!nlDirectState.dragging || e.pointerId!==nlDirectState.pointerId) return;
      const info = getNlTimeFromEvent(e);
      if(!info) return;
      nlDirectState.currentTs = info.timestamp;
      renderNlDragPreview(nlDirectState.startTs, nlDirectState.currentTs);
    };
    const endHandler = (e)=>{
      if(!nlDirectState.dragging || e.pointerId!==nlDirectState.pointerId) return;
      e.target.releasePointerCapture(e.pointerId);
      const start = nlDirectState.startTs;
      const end = nlDirectState.currentTs;
      nlDirectState.dragging=false;
      nlDirectState.startTs=null;
      nlDirectState.currentTs=null;
      clearNlDragPreview();
      if(start==null || end==null) return;
      if(Math.abs(end-start)<60000) return;
      const sDate = new Date(Math.min(start,end));
      const eDate = new Date(Math.max(start,end));
      openEventDialog({
        heading:'数直線から予定を追加',
        note:`開始 ${formatDateTime(sDate)} / 終了 ${formatDateTime(eDate)}`,
        start:sDate,
        end:eDate,
        onSave:({title,color,start,end})=>{
          NLStore.addAbs(start,end,title,color,"normal");
          NLStore.save();
          drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(err){}
          try{ scheduleStudyWatchdog(); }catch(err){}
          nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(err){}
          try{ scheduleStudyWatchdog(); }catch(err){}
          renderList();
        }
      });
    };
    rows.addEventListener('pointermove', moveHandler);
    rows.addEventListener('pointerup', endHandler);
    rows.addEventListener('pointerleave', (e)=>{
      if(nlDirectState.dragging){ endHandler(e); }
    });
  }

  // ============== 勉強管理（安定版の簡潔ロジック） ==============
  const study = { total:20, perPage:5, completed:[], startPage:null, endPage:null };
  function studyPageNumber(idx){
    if(typeof study.startPage === 'number'){
      return study.startPage + idx;
    }
    return idx + 1;
  }
  function getStudyCounts(){
    try{
      if (typeof StudyMgr !== 'undefined' && StudyMgr && StudyMgr.active) {
        const ids = StudyMgr.pageIds||[];
        const remainKeys = new Set();
        ids.forEach(id=>{
          const ev = NLStore.events.find(e=>e.id===id);
          if(ev){ remainKeys.add(ev.pageKey || ev.id); }
        });
        const configuredTotal = (typeof study !== 'undefined' && study && study.total) ? study.total : null;
        const total = configuredTotal!=null ? configuredTotal : remainKeys.size;
        const remain = remainKeys.size;
        const done = Math.max(0, total - remain);
        return {done, total};
      }
    }catch(e){}
    const total = (typeof study !== 'undefined' && study) ? (study.total||0) : 0;
    const done  = (typeof study !== 'undefined' && study) ? (study.completed ? study.completed.length : 0) : 0;
    return {done, total};
  }
  function setCompleteBtnText(){
    var ids = ['pageCompleteBtn','nlCompleteBtn'];
    var p = getStudyCounts();
    ids.forEach(function(id){
      var btn = document.getElementById(id);
      if(btn){ btn.textContent = '📖 ページ完了 ' + p.done + '/' + p.total; }
    });
  }
function updateStudyStats(){
    if($('studyTotal')) $('studyTotal').value = study.total;
    if($('studyPerPage')) $('studyPerPage').value = study.perPage;
    if($('studyPageFrom')) $('studyPageFrom').value = (typeof study.startPage==='number' ? study.startPage : '');
    if($('studyPageTo')) $('studyPageTo').value = (typeof study.endPage==='number' ? study.endPage : '');
    if($('statTotal')){
      let label = String(study.total);
      if(typeof study.startPage==='number' && typeof study.endPage==='number'){
        label += ` (${study.startPage}〜${study.endPage})`;
      }
      $('statTotal').textContent = label;
    }
    if($('statRemain')) $('statRemain').textContent = Math.max(0, study.total - study.completed.length);
    if($('statProgress')){
      const p = study.total>0 ? Math.round(study.completed.length/study.total*100) : 0;
      $('statProgress').textContent = p+'%';
    }
    if($('statTime')){
      const remainTime = Math.max(0, (study.total - study.completed.length)*study.perPage);
      $('statTime').textContent = remainTime + '分';
    }
    const log = $('studyLog'); if(log){
      log.innerHTML='';
      for(let i=0;i<study.total;i++){
        const item = document.createElement('div'); item.className='page-btn';
        const done = study.completed.includes(i);
        if(done) item.classList.add('completed');
        const icon = document.createElement('div'); icon.textContent = done?'✅':'⬜'; icon.style.fontSize='20px'; icon.style.marginBottom='4px';
        const txt  = document.createElement('div'); txt.textContent = `${studyPageNumber(i)}`; txt.style.fontSize='12px'; txt.style.fontWeight='600';
        item.appendChild(icon); item.appendChild(txt);
        item.onclick = ()=>{ togglePage(i); };
        log.appendChild(item);
      }
    }
    if($('pageCompleteBtn')) setCompleteBtnText();
  }
  function togglePage(i){
    if(study.completed.includes(i)){
      study.completed = study.completed.filter(x=>x!==i);
    }else{
      study.completed.push(i);
    }
    updateStudyStats();
  }
  function generateStudy(mode){
    const modeKind = mode || 'count';
    // 既存の学習イベントを掃除してから安定配置
    NLStore.events = NLStore.events.filter(ev => ev.kind!=="study");
    let total = parseInt(($('studyTotal')||{value:20}).value,10);
    const per   = clamp(parseInt(($('studyPerPage')||{value:5}).value,10)||5,1,360);
    const fromEl = $('studyPageFrom');
    const toEl = $('studyPageTo');
    const fromVal = fromEl && fromEl.value!=='' ? parseInt(fromEl.value,10) : NaN;
    const toVal = toEl && toEl.value!=='' ? parseInt(toEl.value,10) : NaN;
    const useRange = (modeKind==='range') && Number.isFinite(fromVal) && Number.isFinite(toVal) && toVal >= fromVal;
    if(modeKind==='range' && !useRange){
      alert('ページ範囲の入力が正しくありません（開始と終了を確認してください）。');
      return;
    }
    if(useRange){
      total = toVal - fromVal + 1;
      if($('studyTotal')) $('studyTotal').value = total;
      study.startPage = fromVal;
      study.endPage = toVal;
    }else{
      if(!Number.isFinite(total) || total<=0){
        alert('総ページ数を正しく入力してください。');
        return;
      }
      study.startPage = null;
      study.endPage = null;
    }
    study.total = total; study.perPage = per; study.completed = [];
    // 現在から順に、休憩などの考慮なしのシンプル連続割付（安定）
    const palette = ['#4da3ff','#ff6b6b','#51cf66','#ffd43b','#a78bfa','#fb7185','#38bdf8','#fb923c'];
    let cursor = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date())); cursor.setSeconds(0,0);
    const newIds = [];
    const batchKey = Date.now();
    for(let i=0;i<total;i++){
      const start = new Date(cursor.getTime());
      const end   = new Date(cursor.getTime() + per*60000);
      const labelNum = studyPageNumber(i);
      const label = String(labelNum);
      const ev = NLStore.addAbs(start,end,label, palette[i%palette.length], "study");
      if(ev){
        ev.pageKey = `page-${batchKey}-${i}`;
        ev.pageIndex = i;
      }
      if(ev && ev.id) newIds.push(ev.id);
      cursor = new Date(end.getTime());
    }
    NLStore.save();
    // 勉強管理を有効化し、生成したIDを登録
    if(window.StudyStart){ StudyStart(newIds); } else { if(window.StudyMgr){ StudyMgr.active=true; StudyMgr.pageIds=newIds; try{StudyMgr.delay={};}catch(e){}  StudyMgr.save&&StudyMgr.save(); } }
    updateStudyStats();
    drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 updateOverallStudyUI(); if(window.__startOverallTicker) window.__startOverallTicker();
    notify('📚 学習予定を生成しました（安定版）');
  }
  function notify(msg){
    const n = document.createElement('div');
    n.className='notification'; n.textContent=msg;
    document.body.appendChild(n);
    setTimeout(()=>n.remove(), 2500);
  }

  // ============== デジタル時計（そのまま） ==============
  function updateDigital(nowOverride){
    const d = nowOverride || now();
    const h = pad2(d.getHours()), m = pad2(d.getMinutes()), s = pad2(d.getSeconds());
    if($('digitalTime')) $('digitalTime').textContent = `${h}:${m}:${s}`;
    const y=d.getFullYear(), mo=pad2(d.getMonth()+1), dd=pad2(d.getDate());
    const days = ['日','月','火','水','木','金','土'];
    if($('digitalDate')) $('digitalDate').textContent = `${y}年${mo}月${dd}日 (${days[d.getDay()]})`;
  }

  // ============== イベント: タブ・ボタン結線 ==============
  
  // ===== 勉強管理（ページ進行／強制終了） =====
  const STUDY_LS_KEY = 'STUDY_MGR';
  const StudyMgr = {
    active:false,
    delay:{},
    pageIds:[], // NLStore上のイベントID配列（順序）
    load(){
      try{
        const o = JSON.parse(localStorage.getItem(STUDY_LS_KEY)||'{}');
        this.active = !!o.active;
        this.pageIds = Array.isArray(o.pageIds)?o.pageIds:[];
        this.delay = (o.delay && typeof o.delay==='object')?o.delay:{};
      }catch(e){ this.active=false; this.pageIds=[]; }
    },
    save(){ localStorage.setItem(STUDY_LS_KEY, JSON.stringify({active:this.active, pageIds:this.pageIds, delay:this.delay})); },
    isStudyEvent(ev){ return ev && this.pageIds.includes(ev.id); },
    currentAndNext(nowMs){
      // 現在進行中ページ and その次のページindex
      const events = this.pageIds.map(id=>NLStore.events.find(e=>e.id===id)).filter(Boolean);
      let curIdx = -1;
      for(let i=0;i<events.length;i++){
        const ev = events[i];
        if(ev.start<=nowMs && nowMs<ev.end){ curIdx=i; break; }
        if(nowMs <= ev.start){ curIdx = i-1; break; }
      }
      if(curIdx===-1 && events.length>0 && nowMs<events[0].start){ curIdx=-1; }
      
      // 追加: すべて過去に流れてしまった場合は最後のページを対象にする
      if(curIdx===-1 && events.length>0 && nowMs>=events[events.length-1].end){ curIdx = events.length-1; }
return {events, curIdx, nextIdx: Math.min(curIdx+1, events.length-1)};
    
    },
    /** 自動延長: ページ完了が押されず終了を迎えたら1分ずつ延長し、後続も1分スライド */
    autoExtendIfNeeded(nowMs){
      if(!this.active) return;
      const ctx = this.currentAndNext(nowMs);
      if(!ctx || ctx.curIdx<0) return;
      const ev = ctx.events[ctx.curIdx];
      if(!ev) return;
      // 初期化
      if(!this.delay) this.delay = {};
      const st = this.delay[ev.id] || { next:null, times:0 };
      // 終了に達していなければ何もしない
      if(nowMs < ev.end){ return; }
      // まだ1回も設定されていない or 次の延長タイミングを超えたら延長
      while(st.next===null || nowMs >= st.next){
        const shift = 60000; // 1分
        if(!this.delay) this.delay={};
        var st0 = this.delay[ev.id]||{next:null,times:0};
        if(!("baseEnd" in st0)){ st0.baseEnd = ev.end; try{ window.SoundMgr && SoundMgr.trigger("study.extend.start"); }catch(e){} } // 元の終了時刻を保持
        this.delay[ev.id]=st0;
        ev.end += shift; try{ window.SoundMgr && SoundMgr.trigger("study.extend.tick"); }catch(e){}
        // 後続の学習イベントを連鎖スライド
        for(let i=ctx.curIdx+1; i<ctx.events.length; i++){
          const e2 = ctx.events[i];
          if(!e2) continue;
          e2.start += shift; e2.end += shift;
        }
        st.times += 1;
        st.next = (st.next===null ? nowMs : st.next) + shift;
        this.delay[ev.id] = st;
        NLStore.save();
        try{ drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 }catch(e){}
        try{ nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 }catch(e){}
        try{ StudyUI.update(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 }catch(e){}
      }
},
    completePageNow(){
      if(!this.active) return;
      const nowMs = Date.now();
      // 0) 現時点までに完了したページをすべて削除（履歴も消す）
      let keptIds = [];
      for(const id of this.pageIds){
        const ev = NLStore.events.find(e=>e.id===id);
        if(!ev) continue;
        if(ev.end<=nowMs){ 
          // 完了済み → 削除
          NLStore.events = NLStore.events.filter(e=>e.id!==id);
        }else{
          keptIds.push(id);
        }
      }
      this.pageIds = keptIds;
      // 1) 進行中ページを特定し、押した瞬間に「完了」として削除する
      let curIdx = -1;
      for(let i=0;i<this.pageIds.length;i++){
        const ev = NLStore.events.find(e=>e.id===this.pageIds[i]);
        if(ev && ev.start<=nowMs && nowMs<ev.end){ curIdx=i; break; }
      }
      if(curIdx>=0){
        const curId = this.pageIds[curIdx];
        try{
          const watcher = window.__studySoundWatcher;
          if(watcher && typeof watcher.markManualComplete==='function'){
            watcher.markManualComplete(curId);
          }else if(window.SoundMgr && SoundMgr.trigger){
            SoundMgr.trigger('study.session.done');
          }
        }catch(_){}
        NLStore.events = NLStore.events.filter(e=>e.id!==curId);
        try{ delete this.delay[curId]; }catch(e){}
        this.pageIds.splice(curIdx,1);
      }
      // 2) 残りを now から順に詰める
      let t = Math.floor(nowMs/60000)*60000;
      for(const id of this.pageIds){
        const ev = NLStore.events.find(e=>e.id===id);
        if(!ev) continue;
        const durRaw = Math.max(60000, ev.end - ev.start);
        const dur = Math.max(60000, Math.round(durRaw/60000)*60000);
        ev.start = t; ev.end = t + dur; t = ev.end;
      }
      if(this.pageIds.length===0){ this.active=false; }
      NLStore.save();
      try{ const x=['plannerDelayBadge','nlDelayBadge','plDelayInline','nlDelayInline']; x.forEach(id=>{ const el=document.getElementById(id); if(el) el.remove(); }); }catch(e){}
      drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

      StudyUI.update(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    setCompleteBtnText(); },
    forceEnd(){
      // 関連イベント削除・状態クリア
      NLStore.events = NLStore.events.filter(ev=>!this.pageIds.includes(ev.id));
      NLStore.save();
      this.active=false; this.pageIds=[]; this.save();
      drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

      StudyUI.update(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    setCompleteBtnText(); }
  };
  StudyMgr.load();

  // ===== UI層（表示/非表示と文言更新） =====
  const StudyUI = {
    ensureButtons(){
      // 既存の planner 用ボタン（#pageCompleteBtn）を流用
      const pc = document.getElementById('pageCompleteBtn');
      if(pc && !pc.dataset.bound){ pc.dataset.bound='1'; pc.onclick = ()=>StudyMgr.completePageNow(); }
      // 数直線パネルの下に専用ボタンを用意
      if(!document.getElementById('studyCtlNL')){
        const rows = document.getElementById('nlRows');
        if(rows){
          const bar = document.createElement('div');
          bar.id = 'studyCtlNL';
          bar.style.display='none';
          bar.style.margin='8px 0 4px 80px';
          bar.style.display='flex'; bar.style.gap='8px'; bar.style.alignItems='center';
          bar.innerHTML = `
            <button id=\"nlCompleteBtn\" class=\"btn small\">📖 ページ完了 0/0</button>
            
          `;
          rows.parentNode.insertBefore(bar, rows);
          document.getElementById('nlCompleteBtn').onclick = ()=>StudyMgr.completePageNow();
          
        }
      }
      // プランナー上にも小さな強制終了ボタンを追加（既存完了ボタンの横）
          },
    update(){
      this.ensureButtons();
      const pc = document.getElementById('pageCompleteBtn');
      const pForce = document.getElementById('plannerForceBtn');
      const nlBar = document.getElementById('studyCtlNL');
      if(StudyMgr.active){
        if(pc){ pc.style.display='inline-flex'; }
        if(pForce){ pForce.style.display='inline-flex'; }
        if(nlBar){ nlBar.style.display='flex'; }
        // 進捗表示 (x/y)
        const total = StudyMgr.pageIds.length;
        let done = 0; const nowMs = Date.now();
        for(const id of StudyMgr.pageIds){
          const ev = NLStore.events.find(e=>e.id===id);
          if(ev && ev.end<=nowMs) done++;
        }
        setCompleteBtnText();
      }else{
        if(pc){ pc.style.display='none'; }
        if(pForce){ pForce.style.display='none'; }
        if(nlBar){ nlBar.style.display='none'; }
      }
    }
  };
function initUI(){
    const tabsWrap = plannerRoot?.querySelector('.tabs');
    if(tabsWrap && !tabsWrap.querySelector('.tab-indicator')){
      const indicator = document.createElement('span');
      indicator.className = 'tab-indicator';
      tabsWrap.appendChild(indicator);
      const moveIndicator = (target)=>{
        if(!target) return;
        const width = target.offsetWidth;
        const left = target.offsetLeft;
        indicator.style.width = `${width}px`;
        indicator.style.transform = `translateX(${left}px)`;
      };
      tabsWrap.__moveIndicator = moveIndicator;
      requestAnimationFrame(()=>moveIndicator(tabsWrap.querySelector('.tab.active') || tabsWrap.querySelector('.tab')));
      window.addEventListener('resize', ()=>moveIndicator(tabsWrap.querySelector('.tab.active')));
    }
    // --- Ensure Numberline Style Panel exists before binding events ---
    const rowsMount = document.getElementById('nlRows');
    if(rowsMount && !document.getElementById('nlStylePanel')){
      const panel = document.createElement('div');
      panel.id = 'nlStylePanel';
      panel.style.display='grid';
      panel.style.gridTemplateColumns='repeat(3, minmax(0,1fr))';
      panel.style.gap='8px';
      panel.style.margin='8px 0 4px 80px';
      panel.style.alignItems='center';
      panel.innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">透明度</label>
          <input id="nlOpacity" type="range" min="0.2" max="1" step="0.05" value="0.8" style="width:140px;">
          <span id="nlOpacityVal" style="font-size:12px;opacity:.8;">0.80</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">見た目</label>
          <select id="nlTheme" style="padding:4px 8px;font-size:12px;">
            <option value="glass">ガラス（高品質）</option>
            <option value="metal">メタル</option>
            <option value="solid">ソリッド</option>
            <option value="gradient">グラデーション</option>
            <option value="neon">ネオン</option>
            <option value="outline">アウトライン</option>
          </select>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">形</label>
          <select id="nlShape" style="padding:4px 8px;font-size:12px;">
            <option value="pill">ピル（丸）</option>
            <option value="rect">角</option>
            <option value="underline">アンダーライン</option>
            <option value="bevel">ベベル</option>
          </select>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">バー高さ</label>
          <input id="nlBarHeight" type="range" min="12" max="120" step="2" value="30" style="width:140px;">
          <span id="nlHeightVal" style="font-size:12px;opacity:.8;">30px</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">ゲージデザイン</label>
          <select id="nlGaugeStyle" style="padding:4px 8px;font-size:12px;">
            <option value="standard" selected>通常</option>
            <option value="guide">目安ゲージ風</option>
          </select>
        </div>`;
      rowsMount.parentNode.insertBefore(panel, rowsMount.nextSibling);
    }
    
    // --- Tick Style Panel (メモリ設定) ---
    if(rowsMount && !document.getElementById('nlTickPanel')){
      const tp = document.createElement('div');
      tp.id = 'nlTickPanel';
      tp.style.display='grid';
      tp.style.gridTemplateColumns='repeat(3, minmax(0,1fr))';
      tp.style.gap='8px';
      tp.style.margin='2px 0 10px 80px';
      tp.style.alignItems='center';
      tp.innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">細目盛 長さ(%)</label>
          <input id="tickMinorLen" type="range" min="10" max="60" step="2" value="28" style="width:140px;">
          <span id="tickMinorLenVal" style="font-size:12px;opacity:.8;">28%</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">細目盛 太さ(px)</label>
          <input id="tickMinorThick" type="range" min="1" max="6" step="1" value="1" style="width:140px;">
          <span id="tickMinorThickVal" style="font-size:12px;opacity:.8;">1px</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">細目盛 色</label>
          <input id="tickMinorColor" type="color" value="#9fb5c9" style="width:44px;height:26px;padding:0;border:none;">
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">太目盛 長さ(%)</label>
          <input id="tickMajorLen" type="range" min="20" max="90" step="2" value="40" style="width:140px;">
          <span id="tickMajorLenVal" style="font-size:12px;opacity:.8;">40%</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">太目盛 太さ(px)</label>
          <input id="tickMajorThick" type="range" min="2" max="10" step="1" value="3" style="width:140px;">
          <span id="tickMajorThickVal" style="font-size:12px;opacity:.8;">3px</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">太目盛 色</label>
          <input id="tickMajorColor" type="color" value="#285078" style="width:44px;height:26px;padding:0;border:none;">
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">グロー(光)</label>
          <input id="tickGlow" type="range" min="0" max="20" step="1" value="6" style="width:140px;">
          <span id="tickGlowVal" style="font-size:12px;opacity:.8;">6</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">影(シャドウ)</label>
          <input id="tickShadow" type="range" min="0" max="20" step="1" value="6" style="width:140px;">
          <span id="tickShadowVal" style="font-size:12px;opacity:.8;">6</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">形</label>
          <select id="tickShape" style="padding:4px 8px;font-size:12px;">
            <option value="line">ライン</option>
            <option value="rounded">丸端</option>
            <option value="diamond">ダイヤ</option>
            <option value="dot">ドット</option>
          </select>
        </div>
      `;
      rowsMount.parentNode.insertBefore(tp, rowsMount.nextSibling);
    }
// テーマ/モード変更で再描画
    if($('theme')) $('theme').onchange = e=>{ if(window.__setPlannerTheme) __setPlannerTheme(e.target.value); drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 };
    // set body class on load if theme preselected
    if($('theme') && $('theme').value){ if(window.__setPlannerTheme) __setPlannerTheme($('theme').value); }
    if($('mode'))  $('mode').onchange  = ()=>drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    // New: planner-specific appearance bindings
    if($('style')) $('style').onchange = ()=>drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    if($('shape')) $('shape').onchange = ()=>drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    if($('motion')) $('motion').onchange = ()=>drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

    if($('clockDesign')) $('clockDesign').onchange = ()=>drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}


    // 既存「追加」ボタンをNLStoreに接続
    if($('add')) $('add').onclick = addEventFromPlannerInputs;

    // 予定一覧表示
    renderList();
    try{ scheduleStudyWatchdog(); }catch(e){}

    // 勉強管理を有効化（自動延長の前提）
    try{ StudyMgr.active=true; StudyMgr.pageIds=newIds; StudyMgr.delay={}; StudyMgr.save&&StudyMgr.save(); StudyUI.update&&StudyUI.update(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 }catch(e){}


    // 数直線タブを開いたら再構築・同期
    (plannerRoot?.querySelectorAll('.tab')||[]).forEach(t=>{
      t.onclick = ()=>{
        (plannerRoot?.querySelectorAll('.tab')||[]).forEach(x=>x.classList.remove('active'));
        (plannerRoot?.querySelectorAll('.tab-content')||[]).forEach(x=>x.classList.remove('active'));
        t.classList.add('active');
        const panel = plannerRoot?.querySelector(`[data-content="${t.dataset.tab}"]`);
        if(panel) panel.classList.add('active');
        if(tabsWrap && typeof tabsWrap.__moveIndicator==='function'){
          tabsWrap.__moveIndicator(t);
        }
        if(t.dataset.tab==='numberline'){
          setBarStyleFromUI(); setTickStyleFromUI();
          nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

          nlStartTimers();
        }
        if(t.dataset.tab==='planner'){
          drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

        }
        if(t.dataset.tab==='study'){
          updateStudyStats();
        }
      };
    });

    // 数直線から追加
    if($('nlAdd')) $('nlAdd').onclick = nlAddFromInputs;
    if($('nlSync')) $('nlSync').onclick = ()=>{ setBarStyleFromUI(); nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 };
    const nlStyleControls = ['nlOpacity','nlTheme','nlShape','nlBarHeight','nlGaugeStyle']
      .map(id=>document.getElementById(id))
      .filter(Boolean);
    nlStyleControls.forEach(ctrl=>{
      const evt = ctrl.tagName==='SELECT' ? 'change' : 'input';
      ctrl.addEventListener(evt, ()=>{
        setBarStyleFromUI();
        nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
      });
    });
    const tmIds=['tickMinorLen','tickMinorThick','tickMinorColor','tickMajorLen','tickMajorThick','tickMajorColor','tickGlow','tickShadow','tickShape'];
    tmIds.forEach(id=>{ const el=document.getElementById(id); if(el){ el.oninput=()=>{ setTickStyleFromUI(); applyTickStyleAll();

  // === Responsive: keep bars & hands aligned on resize ===
  (function(){
    const root = document.getElementById('nlRows');
    if(!root || typeof ResizeObserver==='undefined') return;
    const ro = new ResizeObserver(()=>{
      const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
      document.querySelectorAll('.nl-row').forEach(row=>{
        // re-render bars
        nlRenderBarsForHour(row);
        // update hands if current
        const isCurrent = row.classList.contains('current');
        const sHand = row.querySelector('.nl-hand.s');
        const mHand = row.querySelector('.nl-hand.m');
        if(isCurrent){
          if(sHand) sHand.style.left = (nowD.getSeconds()/60*100)+'%';
          if(mHand) mHand.style.left = (nowD.getMinutes()/60*100)+'%';
        }
      });
      nlUpdateETA && nlUpdateETA();
    });
    ro.observe(root);
  })();


  // === ETA seconds toggle ===
  const NL_SEC_KEY = "nl_eta_show_seconds";
  function nlLoadShowSeconds(){ try{ return localStorage.getItem(NL_SEC_KEY)==='1'; }catch(e){ return false; } }
  function nlSaveShowSeconds(v){ try{ localStorage.setItem(NL_SEC_KEY, v?'1':'0'); }catch(e){} }
  (function(){
    const cb = document.getElementById('nlShowSeconds');
    if(cb){ cb.checked = nlLoadShowSeconds(); cb.onchange = ()=>nlSaveShowSeconds(cb.checked); }
  })();


  // ===== Fullscreen handling =====
  function nlEnterFullscreen(){
    const cont = document.createElement('div'); cont.className='nl-fullscreen'; cont.id='nlFS';
    const close = document.createElement('button'); close.className='nl-fs-close'; close.textContent='閉じる';
    close.onclick = ()=>{ const fs=document.getElementById('nlFS'); if(fs) fs.remove(); nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 };
    cont.appendChild(close);
    document.body.appendChild(cont);
    // Build a fresh current-hour row inside fullscreen
    const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
    const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
    const row = nlBuildRow(base, true);
    cont.appendChild(row);
  }
  (function(){ const btn=document.getElementById('nlFullscreenBtn'); if(btn) btn.onclick=nlEnterFullscreen; })();
 }; }});
    setBarStyleFromUI();

    // 勉強
    if($('studyGenerateCount')) $('studyGenerateCount').onclick = ()=>generateStudy('count');
    if($('studyGenerateRange')) $('studyGenerateRange').onclick = ()=>generateStudy('range');
    try{ initPlannerDirectMode(); }catch(e){}
    try{ initNlDirectMode(); }catch(e){}
    try{ initPlannerOpacityControl(); }catch(e){}
    try{ initPlannerHeightControl(); }catch(e){}
    try{ initPlannerGaugeStyleControl(); }catch(e){}
    try{ initPomodoroUI(); }catch(e){}
  if($('studyForceEnd')) $('studyForceEnd').onclick = ()=>StudyMgr && StudyMgr.forceEnd && StudyMgr.forceEnd();
    if($('pageCompleteBtn')) $('pageCompleteBtn').onclick = ()=>{
      const next = study.completed.length;
      if(next<study.total){ togglePage(next); }
    };

    // エクスポート/インポート/全削除は NLStore に接続
    if($('export')) $('export').onclick = ()=>{
      const blob = new Blob([JSON.stringify(NLStore.events,null,2)],{type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'nl_events.json'; a.click();
    };
    if($('import')) $('import').onclick = ()=>$('file').click();
    if($('file')) $('file').onchange = (e)=>{
      const f = e.target.files[0]; if(!f) return;
      const r = new FileReader();
      r.onload = ()=>{
        try{
          const d = JSON.parse(r.result);
          if(Array.isArray(d)){
            NLStore.events = d; NLStore.save();
            renderList();
    try{ scheduleStudyWatchdog(); }catch(e){}
 drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

          }
        }catch(err){ alert('読込失敗'); }
      };
      r.readAsText(f);
    };
    if($('clear')) $('clear').onclick = ()=>{
      if(confirm('全ての予定を削除しますか？')){
        NLStore.clear(); renderList();
    try{ scheduleStudyWatchdog(); }catch(e){}
 drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

      }
    };
  }


  // === Theme binding (includes horror, upgraded) ===
  (function(){
    const sel = document.getElementById('theme');
    const root = document.documentElement;
    function applyThemeClass(v){
      root.classList.forEach(c=>{ if(c.startsWith('theme-')) root.classList.remove(c); });
      if(v && v.startsWith('theme-')) root.classList.add(v);
      const wrap = document.querySelector('.clock-wrap');
      if(!wrap) return;
      // clear old
      wrap.querySelectorAll('.h-aura,.h-fog,.h-vignette,.h-scan,.bleed,.pulse').forEach(n=>n.remove());
      if(v==='theme-horror'){
        const aura = document.createElement('div'); aura.className='h-aura'; wrap.appendChild(aura);
        const fog1 = document.createElement('div'); fog1.className='h-fog f1'; wrap.appendChild(fog1);
        const fog2 = document.createElement('div'); fog2.className='h-fog f2'; wrap.appendChild(fog2);
        const vig  = document.createElement('div'); vig.className='h-vignette'; wrap.appendChild(vig);
        const scan = document.createElement('div'); scan.className='h-scan'; wrap.appendChild(scan);
      }
    }
    if(sel){
      applyThemeClass(sel.value);
      sel.addEventListener('change', ()=>applyThemeClass(sel.value));
    }
  })();
  
  // === Planner ETA (same design as numberline) ===
  const PL_SEC_KEY = "pl_eta_show_seconds";
  function plLoadShowSeconds(){ try{ return localStorage.getItem(PL_SEC_KEY)==='1'; }catch(e){ return false; } }
  function plSaveShowSeconds(v){ try{ localStorage.setItem(PL_SEC_KEY, v?'1':'0'); }catch(e){} }
  (function(){
    const cb = document.getElementById('plShowSeconds');
    if(cb){ cb.checked = plLoadShowSeconds(); cb.onchange = ()=>plSaveShowSeconds(cb.checked); }
  })();
  function plUpdateETA(secondAligned){
    const now = secondAligned ? (Date.now() - (Date.now()%1000)) : Date.now();
    const etaEl = document.getElementById('plEta'); if(!etaEl) return;
    const showSec = plLoadShowSeconds();
    const ev = (NLStore.events||[]).find(ev => now>=ev.start && now<ev.end);
    if(!ev){ etaEl.style.display='none'; return; }
    const remainMs = Math.max(0, ev.end - now);
    etaEl.style.display='block';
    const title = (ev.title||'予定').toString();
    if(showSec){
      const totalSec = Math.max(0, Math.floor(remainMs/1000));
      const mm = Math.floor(totalSec/60);
      const ss = totalSec%60;
      const ssPad = String(ss).padStart(2,'0');
      etaEl.textContent = mm>0 ? `${title} (${mm}分${ssPad}秒)` : `${title} (${ssPad}秒)`;
    }else{
      const mins = Math.max(0, Math.ceil(remainMs/60000));
      etaEl.textContent = `${title} (${mins}分)`;
    }
  }

  // ===== 予定終了1分前サウンド監視 =====
  const DeadlineSoonWatcher = (function(){
    const MINUTES = Array.from({length:20}, (_,i)=>i+1);
    const state = new Map();
    const STALE_KEEP_MS = 30*60*1000; // keep past state for 30分 to cover再延長
    function cleanup(activeIds, existingIds, nowMs){
      state.forEach((st, id)=>{
        if(activeIds.has(id)) return;
        const exists = existingIds.has(id);
        const lastSeen = st.lastSeen || 0;
        if(!exists || (nowMs - lastSeen) > STALE_KEEP_MS){
          state.delete(id);
        }
      });
    }
    function ensureState(ev, nowMs){
      let st = state.get(ev.id);
      if(!st){
        st = { end: ev.end, fired:{}, lastSeen: nowMs||Date.now() };
        state.set(ev.id, st);
      }else if(st.end !== ev.end){
        // keep past firing flags so auto-extensions don't retrigger countdown sounds immediately
        st.end = ev.end;
      }
      st.lastSeen = nowMs || Date.now();
      return st;
    }
    function triggerForMinute(min){
      const key = min===1 ? 'deadline.soon' : `deadline.soon.m${String(min).padStart(2,'0')}`;
      try{
        if(window.SoundMgr && SoundMgr.trigger){
          SoundMgr.trigger(key);
        }
      }catch(_){}
    }
    function tick(nowMs){
      if(!NLStore || !Array.isArray(NLStore.events)) return;
      const events = NLStore.events.filter(Boolean);
      const activeIds = new Set();
      const existingIds = new Set(events.map(ev=>ev.id));
      events.forEach(ev=>{
        if(!ev) return;
        if(nowMs < ev.start || nowMs >= ev.end) return;
        activeIds.add(ev.id);
        const st = ensureState(ev, nowMs);
        st.end = ev.end;
        const remain = ev.end - nowMs;
        MINUTES.forEach(min=>{
          const upper = min * 60000;
          const lower = (min-1) * 60000;
          const flag = st.fired[min] === true;
          if(remain <= upper && remain > lower){
            if(!flag){
              st.fired[min] = true;
              triggerForMinute(min);
            }
          }
        });
      });
      cleanup(activeIds, existingIds, nowMs);
    }
    return { tick };
  })();

  // ===== 勉強用サウンド監視 =====
  const StudySoundWatcher = (function(){
    const eventState = new Map();
    let lastEventId = null;

    function trigger(key){
      try{ window.SoundMgr && SoundMgr.trigger && SoundMgr.trigger(key); }catch(_){}
    }
    function ensureState(ev){
      if(!ev) return null;
      let st = eventState.get(ev.id);
      if(!st){
        st = { mid:false, last5:false, last1:false, done:false, overtime:false, end:ev.end };
        eventState.set(ev.id, st);
      }else if(st.end !== ev.end){
        st.end = ev.end;
      }
      return st;
    }
    function cleanup(validIds){
      if(!validIds){
        eventState.clear();
        return;
      }
      eventState.forEach((_v, id)=>{
        if(!validIds.has(id)){ eventState.delete(id); }
      });
    }
    function tick(nowMs){
      try{
        if(!window.StudyMgr || !StudyMgr.active){
          lastEventId = null;
          eventState.clear();
          return;
        }
        const ctx = StudyMgr.currentAndNext(nowMs);
        const events = ctx && ctx.events ? ctx.events.filter(Boolean) : [];
        const ev = (ctx && ctx.curIdx>=0) ? ctx.events[ctx.curIdx] : null;
        const validIds = new Set(events.map(e=>e.id));
        if(ev){
          const st = ensureState(ev);
          if(lastEventId !== ev.id){
            trigger('study.session.start');
            lastEventId = ev.id;
          }
          if(st){
            const total = Math.max(1, ev.end - ev.start);
            const elapsed = Math.max(0, nowMs - ev.start);
            const remain = ev.end - nowMs;
            if(!st.mid && elapsed >= total/2){
              st.mid = true; trigger('study.session.mid');
            }
            if(!st.last5 && remain <= 5*60000 && remain > 0){
              st.last5 = true; trigger('study.session.last5');
            }
            if(!st.last1 && remain <= 60000 && remain > 0){
              st.last1 = true; trigger('study.session.last1');
            }
            if(!st.done && nowMs >= ev.end){
              st.done = true; trigger('study.session.done');
            }
            if(!st.overtime && nowMs >= ev.end + 2*60000){
              st.overtime = true; trigger('study.session.overtime');
            }
          }
        }else{
          lastEventId = null;
        }
        cleanup(validIds);
      }catch(_){}
    }
    function markManualComplete(evId){
      if(!evId) return;
      let st = eventState.get(evId);
      if(!st){
        st = { mid:false, last5:false, last1:false, done:false, overtime:false, end:0 };
        eventState.set(evId, st);
      }
      if(!st.done){
        st.done = true;
        trigger('study.session.done');
      }
    }
    return { tick, markManualComplete };
  })();
  window.__studySoundWatcher = StudySoundWatcher;
  // ============== メインループ ==============

  // ===== Second-aligned ticker =====
  (function(){
    if(window.__secAlignedTimer){ clearInterval(window.__secAlignedTimer); window.__secAlignedTimer=null; }
    if(window.__secAlignedKick){ clearTimeout(window.__secAlignedKick); window.__secAlignedKick=null; }
    if(window.__secAlignedFallback){ clearInterval(window.__secAlignedFallback); window.__secAlignedFallback=null; }
    let lastPulseSec = null;
  // ===== Study end-time watchdog =====
  window.__studyWatch && clearTimeout(window.__studyWatch);
  window.__studyWatch = null;
  function scheduleStudyWatchdog(){
    try{
      if(!StudyMgr || !StudyMgr.active) return;
      const cur = now().getTime();
      const ctx = StudyMgr.currentAndNext(cur);
      if(!ctx || ctx.curIdx<0) return;
      const ev = ctx.events[ctx.curIdx];
      if(!ev) return;
      const ms = Math.max(0, ev.end - cur);
      window.__studyWatch = setTimeout(function(){
        try{ StudyMgr.autoExtendIfNeeded(now().getTime()); }catch(e){}
        try{ scheduleStudyWatchdog(); }catch(e){}
      }, Math.max(10, ms/Math.max(1, (typeof window.__getTimeScale==='function' ? window.__getTimeScale() : 1))));
    }catch(e){}
  }

  // ===== 強制延長＆再構築（ハードガード） =====
  // 仕様: 自動生成した勉強予定が、ページ完了ボタン未押下のまま終了時刻に到達したら
  // 1) 現在ページを +1分延長
  // 2) 後続の勉強予定も +1分ずつスライド
  // 3) それに合わせて全勉強予定を「今」から連続再構築（ズレの蓄積を防止）
  function __rebuildStudyChainFrom(nowMs){
    try{
      if(!StudyMgr || !StudyMgr.active) return false;
      const events = StudyMgr.pageIds.map(id=>NLStore.events.find(e=>e.id===id)).filter(Boolean);
      if(events.length===0) return false;
      // 連続再配置: 現在時刻から順に、元の各イベントの「分丸めした長さ」を保って詰め直す
      let t = Math.floor(nowMs/60000)*60000;
      for(const ev of events){
        const durRaw = Math.max(60000, (ev.end - ev.start));
        const dur = Math.max(60000, Math.round(durRaw/60000)*60000);
        ev.start = t; ev.end = t + dur; t = ev.end;
      }
      NLStore.save();
      try{ drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){} }catch(e){}
      try{ nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){} }catch(e){}
      try{ StudyUI.update(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){} }catch(e){}
      return true;
    }catch(e){ return false; }
  }

  function __forceExtendAndRebuild(nowMs){
    try{
      if(!StudyMgr || !StudyMgr.active) return;
      // 現在・直前ページを特定（終了に到達したページを優先）
      const ctx = StudyMgr.currentAndNext(nowMs);
      if(!ctx || !ctx.events || ctx.events.length===0) return;
      let idx = ctx.curIdx;
      let ev = (idx>=0)? ctx.events[idx] : null;
      if(!(ev && ev.end<=nowMs)){
        // 直前に終了したページに切替
        let justEnded = -1, bestEnd = -1;
        for(let i=0;i<ctx.events.length;i++){
          const e = ctx.events[i]; if(!e) continue;
          if(e.end<=nowMs && e.end>bestEnd){ bestEnd=e.end; justEnded=i; }
        }
        if(justEnded>=0){ idx=justEnded; ev=ctx.events[idx]; }
      }
      if(!ev) return;
      if(ev.end > nowMs) return; // まだ終わってない

      // 1分延長（現在ページ）
      const shift = 60000;
      if(!StudyMgr.delay) StudyMgr.delay={};
      var st1 = StudyMgr.delay[ev.id]||{next:null,times:0};
      if(!("baseEnd" in st1)){ st1.baseEnd = ev.end; try{ window.SoundMgr && SoundMgr.trigger("study.extend.start"); }catch(e){} }
      StudyMgr.delay[ev.id]=st1;
      ev.end += shift; try{ window.SoundMgr && SoundMgr.trigger("study.extend.tick"); }catch(e){} try{ window.SoundMgr && SoundMgr.trigger("study.extend.tick"); }catch(e){}
      for(let i=idx+1;i<ctx.events.length;i++){
        const e2 = ctx.events[i]; if(!e2) continue;
        e2.start += shift; e2.end += shift;
      }
      // 今から全体を整列し直す（連続再構築）
      NLStore.save(); try{ drawPlanner(); }catch(e){} try{ nlRebuildAll(); }catch(e){} try{ StudyUI.update(); }catch(e){}
    }catch(e){}
  }

  // ===== 延長表示UI =====
  function __fmtNeg(ms){
    if(ms<0) ms=0;
    const s = Math.floor(ms/1000);
    if(s<60) return `-${s}秒`;
    const m = Math.floor(s/60), ss = s%60;
    if(ss===0) return `-${m}分`;
    return `-${m}分${ss}秒`;
  }
  function updateDelayUI(nowMs){
    try{
      const pBadge = document.getElementById('plannerDelayBadge');
      const nBadge = document.getElementById('nlDelayBadge');
      let showText = '';
      if(StudyMgr && StudyMgr.active){
        const ctx = StudyMgr.currentAndNext(nowMs);
        if(ctx && ctx.events && ctx.events.length>0){
          let idx = ctx.curIdx;
          let ev = (idx>=0)? ctx.events[idx] : null;
          if(!(ev && StudyMgr.delay && StudyMgr.delay[ev.id] && ('baseEnd' in StudyMgr.delay[ev.id]))){
            // 直前終了のページも確認
            let justEnded=-1, bestEnd=-1;
            for(let i=0;i<ctx.events.length;i++){
              const e = ctx.events[i]; if(!e) continue;
              const st = StudyMgr.delay && StudyMgr.delay[e.id];
              if(st && ('baseEnd' in st) && e.end>=st.baseEnd && nowMs>=st.baseEnd){
                if(e.end>bestEnd){ bestEnd=e.end; justEnded=i; }
              }
            }
            if(justEnded>=0){ ev = ctx.events[justEnded]; }
          }
          if(ev && StudyMgr.delay && StudyMgr.delay[ev.id] && ('baseEnd' in StudyMgr.delay[ev.id])){
            const base = StudyMgr.delay[ev.id].baseEnd;
            const dms = nowMs - base;
            if(dms>=0){ showText = __fmtNeg(dms); }
          }
        }
      }
      const show = !!showText;
      if(pBadge){ pBadge.style.display = show? 'inline':'none'; if(show) pBadge.textContent = showText; }
      if(nBadge){ nBadge.style.display = show? 'inline':'none'; if(show) nBadge.textContent = showText; }
    }catch(e){}
  }

  // ===== 延長表示（各予定の残り時間ラベルの右に配置） =====
  function ensureInlineDelaySpans(){
    try{
      const pl = document.getElementById('plEta');
      if(pl && !document.getElementById('plDelayInline')){
        const sp = document.createElement('span');
        sp.id = 'plDelayInline';
        sp.style.marginLeft = '6px';
        sp.style.fontSize = '14px'; sp.style.fontWeight='700'; sp.style.opacity='.95'; sp.style.padding='2px 6px'; sp.style.borderRadius='10px'; sp.style.background='rgba(193,18,31,.18)'; sp.style.color='var(--muted, #fff)'; sp.style.backdropFilter='blur(2px)';
        sp.style.display = 'none';
        pl.parentNode && pl.parentNode.insertBefore(sp, pl.nextSibling);
      }
    }catch(e){}
  }
  function updateDelayInlineUI(nowMs){
    try{ ['plannerDelayBadge','nlDelayBadge'].forEach(id=>{ const el=document.getElementById(id); if(el) el.remove(); }); }catch(e){}

    try{
      ensureInlineDelaySpans();
      const hasDelay = (ev)=>{
        return (StudyMgr && StudyMgr.delay && ev && StudyMgr.delay[ev.id] && ('baseEnd' in StudyMgr.delay[ev.id]));
      };
      const getDelayText = (base)=>{
        const d = nowMs - base; if(d<0) return '';
        const s = Math.floor(d/1000);
        if(s<60) return `-${s}秒`;
        const m = Math.floor(s/60), ss=s%60;
        return ss===0? `-${m}分` : `-${m}分${ss}秒`;
      };
      const ctx = (StudyMgr && StudyMgr.active) ? StudyMgr.currentAndNext(nowMs) : null;
      let curEv = null;
      if(ctx && ctx.events && ctx.events.length){
        curEv = (ctx.curIdx>=0)? ctx.events[ctx.curIdx] : null;
        if(!(curEv && hasDelay(curEv))){
          // try just-ended
          let je=-1, be=-1;
          for(let i=0;i<ctx.events.length;i++){
            const e = ctx.events[i]; if(!e) continue;
            const st = StudyMgr.delay && StudyMgr.delay[e.id];
            if(st && ('baseEnd' in st) && e.end>=st.baseEnd && nowMs>=st.baseEnd){
              if(e.end>be){ be=e.end; je=i; }
            }
          }
          if(je>=0){ curEv = ctx.events[je]; }
        }
      }
      // Planner inline
      const plEta = document.getElementById('plEta');
      const plBadge = document.getElementById('plDelayInline');
      let showTxt = '';
      if(curEv && hasDelay(curEv)){
        const base = StudyMgr.delay[curEv.id].baseEnd;
        showTxt = getDelayText(base);
      }
      if(plEta && plBadge){
        const show = !!showTxt;
        plBadge.style.display = show ? 'inline' : 'none';
        if(show) plBadge.textContent = showTxt;
      }
      // Numberline inline: locate the .nl-eta in current row
      let nlEta = null;
      if(ctx){
        // Prefer row with class 'current', else hour-equal row
        const rows = Array.from(document.querySelectorAll('.nl-row'));
        const nowD = new Date(nowMs);
        let target = rows.find(r=>r.classList.contains('current'));
        if(!target){
          target = rows.find(r=>{
            const ts = parseInt(r.dataset.startTs||'0',10);
            const d = new Date(ts);
            return d.getFullYear()===nowD.getFullYear() && d.getMonth()===nowD.getMonth() &&
                   d.getDate()===nowD.getDate() && d.getHours()===nowD.getHours();
          });
        }
        if(target){ nlEta = target.querySelector('.nl-eta'); }

      if(!nlEta && target){
        nlEta = target.querySelector('.nl-timer-label') || target.querySelector('[data-role="eta"]');
      }

      }
      if(nlEta){
        let sp = nlEta.nextSibling;
        const needId = 'nlDelayInline';
        if(!(sp && sp.nodeType===1 && sp.id===needId)){
          const nsp = document.createElement('span');
          nsp.id = needId;
          nsp.style.marginLeft='6px'; nsp.style.fontSize='14px'; nsp.style.fontWeight='700'; nsp.style.opacity='.95'; nsp.style.display='none'; nsp.style.padding='2px 6px'; nsp.style.borderRadius='10px'; nsp.style.background='rgba(193,18,31,.18)'; nsp.style.color='var(--muted, #fff)'; nsp.style.backdropFilter='blur(2px)';
          nlEta.parentNode.insertBefore(nsp, nlEta.nextSibling);
          sp = nsp;
        }
        const show = !!showTxt;
        sp.style.display = show ? 'inline' : 'none';
        if(show) sp.textContent = showTxt;
      }
    }catch(e){}
  }
  function runSecondAligned(nowD){
      const nms = nowD.getTime();
      try{
        try{ updateDelayInlineUI(nms); }catch(e){} try{ window.SoundMgr && SoundMgr.timeTick(nms); }catch(e){}
        try{ DeadlineSoonWatcher.tick(nms); }catch(e){}
        try{ StudySoundWatcher.tick(nms); }catch(e){}
        try{ nlUpdateDigitalDisplays(nms); }catch(e){}
        try{ updateDelayUI(nms); }catch(e){}
        try{ StudyMgr.autoExtendIfNeeded(nms); }catch(e){}
        const rows = Array.from(document.querySelectorAll('.nl-row'));
  rows.forEach(r=>{ r.__nlStack=0; r.__nlOuterStack=0; });
        setClockPulseDate(nowD);
        updateDigital(nowD);
        const motionSel = document.getElementById('motion');
        const motionVal = motionSel ? motionSel.value : 'smooth';
        if(motionVal !== 'smooth'){ updatePlannerHandRotation(nowD, motionVal); }
        rows.forEach(row=>{
          const ts = parseInt(row.dataset.startTs||'0',10);
          const d = new Date(ts);
          const isCurrent = row.classList.contains('current') ||
            (d.getFullYear()===nowD.getFullYear() && d.getMonth()===nowD.getMonth() &&
             d.getDate()===nowD.getDate() && d.getHours()===nowD.getHours());
          const sHand = row.querySelector('.nl-hand.s');
          const mHand = row.querySelector('.nl-hand.m');
          if(isCurrent){
            if(sHand) sHand.style.left = (nowD.getSeconds()/60*100)+'%';
            if(mHand) mHand.style.left = (nowD.getMinutes()/60*100)+'%';
          }
        });
        if(nlPlannerMirrorHost){
          nlMirrorPlannerClock();
        }
      }catch(e){}

      try{ if(typeof nlUpdateETA==='function') nlUpdateETA(true); }catch(e){}
      try{ if(typeof plUpdateETA==='function') plUpdateETA(true); }catch(e){}
    }

    function ensureSecondAligned(nowSrc){
      const base = nowSrc instanceof Date ? nowSrc : now();
      const sec = Math.floor(base.getTime()/1000);
      if(lastPulseSec===null){
        lastPulseSec = sec;
        runSecondAligned(new Date(sec*1000));
        return;
      }
      if(sec>lastPulseSec){
        while(lastPulseSec<sec){
          lastPulseSec++;
          runSecondAligned(new Date(lastPulseSec*1000));
        }
        return;
      }
      if(sec<lastPulseSec){
        lastPulseSec = sec;
        runSecondAligned(new Date(sec*1000));
      }
    }
    window.__ensureSecondAligned = ensureSecondAligned;
    window.__secAlignedFallback = setInterval(()=>{
      try{ ensureSecondAligned(); }catch(_){}
    }, 200);
    // ハードウォッチドッグ（500ms間隔）: 終了瞬間の取りこぼし防止
    try{
      window.__studyHardWatch && clearInterval(window.__studyHardWatch);
      window.__studyHardWatch = setInterval(function(){
        try{ __forceExtendAndRebuild(now().getTime()); }catch(e){}
      }, 500);
    }catch(e){}

    try{ scheduleStudyWatchdog(); }catch(e){}

  })();

  
  // ===== Overall Study (sum of remaining time & final end) =====
  function __fmtHM(ms){
    ms = Math.max(0, ms|0);
    const totalSec = Math.floor(ms/1000);
    const h = Math.floor(totalSec/3600);
    const m = Math.floor((totalSec%3600)/60);
    if(h>0) return `${h}時間${m}分`;  // 切り捨て表示
    return `${m}分`;                  // 切り捨て表示（予定の残り時間と同じ感覚）
  }
  function __fmtClock(d){
    const pad = (n)=>(''+n).padStart(2,'0');
    return `${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }
  
  function computeOverallStudy(nowMs){
    try{
      let events = [];
      if(window.StudyMgr && StudyMgr.active && Array.isArray(StudyMgr.pageIds) && StudyMgr.pageIds.length>0){
        events = StudyMgr.pageIds
          .map(id=>NLStore.events.find(e=>e.id===id))
          .filter(ev=>ev && ev.end>nowMs);
      }else{
        events = (NLStore.events||[]).filter(ev=>ev && ev.kind==='study' && ev.end>nowMs);
      }
      events.sort((a,b)=>a.start-b.start);
      if(events.length===0){ return null; }
      const lastEnd = events[events.length-1].end;
      const remainMs = Math.max(0, lastEnd - nowMs); // 連続割付前提: 全体は最終終了時刻-現在時刻
      return { remainMs, lastEnd: new Date(lastEnd) };
    }catch(e){ return null; }
  }

  function ensureNlOverallBadge(){
    // find current hour row
    const nowD = (window.__getNow?window.__getNow():new Date());
    const nowHourStart = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0).getTime();
    let currentRow = null;
    document.querySelectorAll('.nl-row').forEach(row=>{ const ts=parseInt(row.dataset.startTs||'0',10); if(ts===nowHourStart) currentRow=row; });
    if(!currentRow) return null;
    const lane = currentRow.querySelector('.nl-lane');
    if(!lane) return null;
    let badge = document.getElementById('nlOverallBadge');
    if(!badge){
      badge = document.createElement('div');
      badge.id = 'nlOverallBadge';
      badge.className = 'nl-overall-inline';
      badge.style.display='none';
      badge.innerHTML = `<span id="nlOverallRemain">残り --</span> <span id="nlOverallEnd">終了 --:--</span>`;
      lane.appendChild(badge);
    }else{
      // ensure it is inside the current row scale
      if(badge.parentNode!==lane){ badge.remove(); lane.appendChild(badge); }
      badge.className = 'nl-overall-inline';
    }
    return badge;
  }
  let __osi_ticking=false;
  function updateOverallStudyUI(){
    if(__osi_ticking) return; __osi_ticking=true; setTimeout(()=>{ __osi_ticking=false; }, 100);
    const now = (window.__getNow?window.__getNow():new Date());
    const info = computeOverallStudy(now.getTime());
    const banner = document.getElementById('overallStudyInfo');
    const badge = ensureNlOverallBadge();
    if(info){
      const rtxt = __fmtHM(info.remainMs);
      const etxt = __fmtClock(info.lastEnd);
      if(banner){
        banner.style.display='flex';
        const r = document.getElementById('osiRemain'), e = document.getElementById('osiEnd');
        if(r) r.textContent = `残り ${rtxt}`;
        if(e) e.textContent = `終了 ${etxt}`;
      }
      if(badge){
        badge.style.display='block';
        const rr = document.getElementById('nlOverallRemain');
        const ee = document.getElementById('nlOverallEnd');
        if(rr) rr.textContent = `残り ${rtxt}`;
        if(ee) ee.textContent = `終了 ${etxt}`;
      }
    }else{
      if(banner) banner.style.display='none';
      const b = document.getElementById('nlOverallBadge');
      if(b) b.style.display='none';
    }
  }

  
  // ===== Overall Study updater: second-aligned interval (rAF非依存) =====
  (function(){
    function startSecondAlignedOverall(){
      try{
        if(window.__overallKick) clearTimeout(window.__overallKick);
        if(window.__overallTimer) clearInterval(window.__overallTimer);
      }catch(e){}
      function kick(){
        if(window.__overallTimer) clearInterval(window.__overallTimer);
        updateOverallStudyUI();
        window.__overallTimer = setInterval(updateOverallStudyUI, 1000);
      }
      var delay = 1000 - (Date.now() % 1000);
      window.__overallKick = setTimeout(kick, delay);
    }
    window.__startOverallTicker = startSecondAlignedOverall;
  })();

  function tick(){
    try{ window.__ensureSecondAligned && window.__ensureSecondAligned(); }catch(_){}
    drawPlanner(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 drawTimerArcs(); nlRenderTimerOverlays(); updateDigital(); updateOverallStudyUI(); requestAnimationFrame(tick); }

  // 初期化
  initUI(); if(window.__startOverallTicker) window.__startOverallTicker(); if(typeof updateHUD==='function') updateHUD();
  if($('studyGenerateCount')) $('studyGenerateCount').onclick = ()=>generateStudy('count');
  if($('studyGenerateRange')) $('studyGenerateRange').onclick = ()=>generateStudy('range');
  if($('studyForceEnd')) $('studyForceEnd').onclick = ()=>StudyMgr && StudyMgr.forceEnd && StudyMgr.forceEnd();
  StudyUI.update(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}

  setCompleteBtnText(); nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 updateOverallStudyUI(); // 先に構築しておく（初回）
  setTickStyleFromUI(); applyTickStyleAll();

  // === Responsive: keep bars & hands aligned on resize ===
  (function(){
    const root = document.getElementById('nlRows');
    if(!root || typeof ResizeObserver==='undefined') return;
    const ro = new ResizeObserver(()=>{
      const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
      document.querySelectorAll('.nl-row').forEach(row=>{
        // re-render bars
        nlRenderBarsForHour(row);
        // update hands if current
        const isCurrent = row.classList.contains('current');
        const sHand = row.querySelector('.nl-hand.s');
        const mHand = row.querySelector('.nl-hand.m');
        if(isCurrent){
          if(sHand) sHand.style.left = (nowD.getSeconds()/60*100)+'%';
          if(mHand) mHand.style.left = (nowD.getMinutes()/60*100)+'%';
        }
      });
      nlUpdateETA && nlUpdateETA();
    });
    ro.observe(root);
  })();


  // === ETA seconds toggle ===
  const NL_SEC_KEY = "nl_eta_show_seconds";
  function nlLoadShowSeconds(){ try{ return localStorage.getItem(NL_SEC_KEY)==='1'; }catch(e){ return false; } }
  function nlSaveShowSeconds(v){ try{ localStorage.setItem(NL_SEC_KEY, v?'1':'0'); }catch(e){} }
  (function(){
    const cb = document.getElementById('nlShowSeconds');
    if(cb){ cb.checked = nlLoadShowSeconds(); cb.onchange = ()=>nlSaveShowSeconds(cb.checked); }
  })();


  // ===== Fullscreen handling =====
  function nlEnterFullscreen(){
    const cont = document.createElement('div'); cont.className='nl-fullscreen'; cont.id='nlFS';
    const close = document.createElement('button'); close.className='nl-fs-close'; close.textContent='閉じる';
    close.onclick = ()=>{ const fs=document.getElementById('nlFS'); if(fs) fs.remove(); nlRebuildAll(); try{ scheduleStudyWatchdog&&scheduleStudyWatchdog(); }catch(e){}
    try{ scheduleStudyWatchdog(); }catch(e){}
 };
    cont.appendChild(close);
    document.body.appendChild(cont);
    // Build a fresh current-hour row inside fullscreen
    const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
    const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
    const row = nlBuildRow(base, true);
    cont.appendChild(row);
  }
  (function(){ const btn=document.getElementById('nlFullscreenBtn'); if(btn) btn.onclick=nlEnterFullscreen; })();


// === Inject style panel for bars ===
(function(){
  const rows = document.getElementById('nlRows');
  if(!rows) return;
  if(!document.getElementById('nlStylePanel')){
    const panel = document.createElement('div');
    panel.id = 'nlStylePanel';
    panel.style.display='grid';
    panel.style.gridTemplateColumns='repeat(3, minmax(0,1fr))';
    panel.style.gap='8px';
    panel.style.margin='8px 0 4px 80px';
    panel.style.alignItems='center';
    panel.innerHTML = `
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:12px;opacity:.8;">透明度</label>
        <input id="nlOpacity" type="range" min="0.2" max="1" step="0.05" value="0.8" style="width:140px;">
        <span id="nlOpacityVal" style="font-size:12px;opacity:.8;">0.80</span>
      </div>
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:12px;opacity:.8;">見た目</label>
        <select id="nlTheme" style="padding:4px 8px;font-size:12px;">
          <option value="glass">ガラス（高品質）</option>
          <option value="metal">メタル</option>
          <option value="solid">ソリッド</option>
          <option value="gradient">グラデーション</option>
          <option value="neon">ネオン</option>
          <option value="outline">アウトライン</option>
        </select>
      </div>
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:12px;opacity:.8;">形</label>
        <select id="nlShape" style="padding:4px 8px;font-size:12px;">
          <option value="pill">ピル（丸）</option>
          <option value="rect">角</option>
          <option value="underline">アンダーライン</option>
          <option value="bevel">ベベル</option>
        </select>
      </div>
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:12px;opacity:.8;">バー高さ</label>
        <input id="nlBarHeight" type="range" min="12" max="120" step="2" value="30" style="width:140px;">
        <span id="nlHeightVal" style="font-size:12px;opacity:.8;">30px</span>
      </div>
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:12px;opacity:.8;">ゲージデザイン</label>
        <select id="nlGaugeStyle" style="padding:4px 8px;font-size:12px;">
          <option value="standard" selected>通常</option>
          <option value="guide">目安ゲージ風</option>
        </select>
      </div>
    `;
    rows.parentNode.insertBefore(panel, rows.nextSibling);
  }
})();

  tick();
})();
</script>

<!-- Timer/Stopwatch & Numberline Overlay Patch v2 -->
<script>
(function(){
  if (window.__timerPatchAppliedV2) return;
  window.__timerPatchAppliedV2 = true;
  const $ = (id)=>document.getElementById(id);
  function triggerTimerSound(key){
    if(!key) return;
    try{ window.SoundMgr && SoundMgr.trigger && SoundMgr.trigger(key); }catch(_){}
  }
  function resetTimerSoundFlags(t){
    t._soundFlags = { half:false, last60:false, last10:false, last01:false, complete:false };
  }
  function ensureTimerFlags(t){
    if(!t._soundFlags) resetTimerSoundFlags(t);
    return t._soundFlags;
  }
  function handleTimerSoundProgress(t){
    if(!t || t.total<=0) return;
    const flags = ensureTimerFlags(t);
    const remain = Math.max(0, t.remain||0);
    if(!flags.half && remain <= t.total/2){
      flags.half = true; triggerTimerSound('timer.half');
    }
    if(!flags.last60 && remain <= 60){
      flags.last60 = true; triggerTimerSound('timer.last60');
    }
    if(!flags.last10 && remain <= 10){
      flags.last10 = true; triggerTimerSound('timer.last10');
    }
    if(!flags.last01 && remain <= 1){
      flags.last01 = true; triggerTimerSound('timer.last01');
    }
  }

  // Globals
  window.timers = window.timers || [];
  window.timers.forEach(t=>resetTimerSoundFlags(t));
  window.sws    = window.sws || [];
  window.timerId = window.timerId || 0;
  window.swId    = window.swId || 0;

  // Helpers presence fallbacks
  window.minToAng = window.minToAng || function(min, total){ const t=total||60; return (min/t)*Math.PI*2 - Math.PI/2; };
  window.arcPath = window.arcPath || function(r, a1, a2, sw){
    const cx=250, cy=250;
    const rr1 = r - (sw/2), rr2 = r + (sw/2);
    const x1 = cx + rr1*Math.cos(a1), y1 = cy + rr1*Math.sin(a1);
    const x2 = cx + rr1*Math.cos(a2), y2 = cy + rr1*Math.sin(a2);
    const x3 = cx + rr2*Math.cos(a2), y3 = cy + rr2*Math.sin(a2);
    const x4 = cx + rr2*Math.cos(a1), y4 = cy + rr2*Math.sin(a1);
    const large = (a2-a1) % (Math.PI*2) > Math.PI ? 1 : 0;
    return `M ${x1} ${y1} A ${rr1} ${rr1} 0 ${large} 1 ${x2} ${y2} L ${x3} ${y3} A ${rr2} ${rr2} 0 ${large} 0 ${x4} ${y4} Z`;
  };

  // ============ Stopwatch ============
  function addSW(){ window.sws.push({id:window.swId++, elapsed:0, running:false, start:0}); renderSW(); }
  function renderSW(){
    const root = $('swList'); if(!root) return;
    root.innerHTML='';
    (window.sws||[]).forEach((sw,i)=>{
      const div = document.createElement('div'); div.className='sw-item';
      const time = document.createElement('div'); time.className='sw-time'; time.id=`sw${sw.id}`;
      time.textContent = fmtSW(sw.elapsed);
      const btns = document.createElement('div'); btns.className='sw-btns';
      const start = document.createElement('button'); start.textContent=sw.running?'⏸ 停止':'▶ 開始'; start.onclick=()=>toggleSW(i);
      const reset = document.createElement('button'); reset.className='ghost'; reset.textContent='↻ リセット'; reset.onclick=()=>resetSW(i);
      const del   = document.createElement('button'); del.className='ghost danger'; del.textContent='🗑️ 削除'; del.onclick=()=>{window.sws.splice(i,1); renderSW();};
      btns.append(start, reset, del); div.append(time, btns); root.appendChild(div);
    });
  }
  function toggleSW(i){ const sw=window.sws[i]; if(!sw) return; if(sw.running){ sw.running=false; sw.elapsed += (Date.now()-sw.start)/1000; }else{ sw.running=true; sw.start=Date.now(); } renderSW(); }
  function resetSW(i){ const sw=window.sws[i]; if(!sw) return; sw.running=false; sw.elapsed=0; renderSW(); }
  function fmtSW(sec){ const m=Math.floor(sec/60), s=Math.floor(sec%60); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; }

  // ============ Timer ============
  function addTimer(){
    const now = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date())));
    const timer = {
      id: window.timerId++,
      total: 25*60, remain: 25*60, running:false, start:0, alerted:false,
      startMin: now.getMinutes(), minutes: 25, gaugeColor:'#4da3ff', clockMode:'outer', __hasStarted:false
    };
    resetTimerSoundFlags(timer);
    window.timers.push(timer);
    renderTimers();
  }

  function startTimerUntil(){
    const timeEl = $('tUntilTime'); if(!timeEl){ alert('終了時刻UIの読み込みに失敗しました'); return; }
    const val = String(timeEl.value||''); if(!val || !/^[0-2]\d:[0-5]\d$/.test(val)){ alert('終了時刻を選んでください'); return; }
    const [hhStr, mmStr] = val.split(':');
    const hh = parseInt(hhStr,10), mm = parseInt(mmStr,10);
    const now = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()))); const nowAbs = now.getHours()*60 + now.getMinutes();
    let endAbs = hh*60 + mm; let diff = endAbs - nowAbs; if(diff <= 0) diff += 1440;
    const color = $('tUntilColor') ? $('tUntilColor').value : '#4da3ff';
    const clockMode = $('tUntilMode') ? $('tUntilMode').value : 'direct';
    const t = { id:window.timerId++, total: diff*60, remain: diff*60, running:false, start:0, alerted:false,
                startMin: now.getMinutes(), minutes: diff, gaugeColor: color, clockMode: clockMode, __hasStarted:false };
    resetTimerSoundFlags(t);
    window.timers.push(t); renderTimers(); startTimer(window.timers.length-1);
  }

  function renderTimers(){
    const root = $('timerList'); if(!root) return;
    root.innerHTML='';
    window.timers.forEach((t,i)=>{
      const div = document.createElement('div'); div.className='timer-item';
      const controls = document.createElement('div'); controls.className='row'; controls.style.marginBottom='12px';
      const minInput=document.createElement('input'); minInput.type='number'; minInput.min='1'; minInput.max='720'; minInput.value=t.minutes; minInput.style.width='80px';
      minInput.onchange=(e)=>{ t.minutes=parseInt(e.target.value,10); t.total=t.minutes*60; if(!t.running) t.remain=t.total; updateTimer(i); };
      const modeLabel=document.createElement('label'); modeLabel.textContent='表示:'; modeLabel.style.marginLeft='8px';
      const modeSelect=document.createElement('select'); modeSelect.innerHTML='<option value="outer">外周</option><option value="direct">直接配置</option>'; modeSelect.value=t.clockMode||'outer';
      modeSelect.onchange=(e)=>{ t.clockMode=e.target.value; drawTimerArcs(); nlRenderTimerOverlays(); };
      const colorLabel=document.createElement('label'); colorLabel.textContent='色:'; colorLabel.style.marginLeft='8px';
      const colorInput=document.createElement('input'); colorInput.type='color'; colorInput.value=t.gaugeColor||'#4da3ff'; colorInput.style.width='50px';
      colorInput.onchange=(e)=>{ t.gaugeColor=e.target.value; updateTimer(i); };
      controls.append(minInput, document.createTextNode(' 分'), modeLabel, modeSelect, colorLabel, colorInput);
      const display=document.createElement('div'); display.className='timer-display'; display.id=`t${t.id}`;
      const endSpan=document.createElement('span'); endSpan.id=`te${t.id}`; endSpan.className='tiny'; endSpan.style.marginLeft='8px'; endSpan.style.verticalAlign='middle';
      const gauge=document.createElement('div'); gauge.className='timer-gauge'; const fill=document.createElement('div'); fill.className='fill'; fill.id=`tf${t.id}`; gauge.appendChild(fill);
      const row=document.createElement('div'); row.className='row';
      const startBtn=document.createElement('button'); startBtn.textContent='▶ 開始'; startBtn.onclick=()=>startTimer(i);
      const pauseBtn=document.createElement('button'); pauseBtn.textContent='⏸ 停止'; pauseBtn.onclick=()=>pauseTimer(i);
      const resetBtn=document.createElement('button'); resetBtn.className='ghost'; resetBtn.textContent='↻ リセット'; resetBtn.onclick=()=>resetTimer(i);
      const stopBtn=document.createElement('button'); stopBtn.className='ghost danger'; stopBtn.textContent='🗑️ 削除'; stopBtn.onclick=()=>{window.timers.splice(i,1); renderTimers(); drawTimerArcs(); nlRenderTimerOverlays();};
      row.append(startBtn,pauseBtn,resetBtn,stopBtn);
      // compute display
      const m=Math.floor(Math.abs(t.remain)/60), s=Math.floor(Math.abs(t.remain)%60), sign=t.remain<0?'-':'';
      display.textContent = `${sign}${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
      const end = new Date(Date.now()+Math.max(0,t.remain)*1000); endSpan.textContent=`(終了 ${String(end.getHours()).padStart(2,'0')}:${String(end.getMinutes()).padStart(2,'0')})`;
      display.appendChild(endSpan);
      div.append(controls, display, gauge, row); root.appendChild(div);
    });
  }

  function startTimer(i){
    const t=window.timers[i]; if(!t||t.running) return;
    if(t.remain<=0 || t.alerted){
      t.total = t.minutes*60;
      t.remain = t.total;
      t.alerted = false;
      resetTimerSoundFlags(t);
      const now = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
      t.startMin = now.getMinutes();
    }
    const isFresh = !t.__hasStarted || t.remain===t.total;
    const isResume = t.__hasStarted && t.remain>0 && t.remain<t.total;
    t.__hasStarted = true;
    t.start = Date.now() - (t.total - t.remain)*1000;
    t.running=true;
    if(isFresh){
      triggerTimerSound('timer.start');
    }else if(isResume){
      triggerTimerSound('timer.resume');
    }
    renderTimers();
  }
  function pauseTimer(i){
    const t=window.timers[i]; if(!t) return;
    if(t.running){ triggerTimerSound('timer.pause'); }
    t.running=false; renderTimers();
  }
  function resetTimer(i){
    const t=window.timers[i]; if(!t) return;
    t.total=t.minutes*60; t.remain=t.total; t.running=false; t.alerted=false;
    t.__hasStarted=false;
    resetTimerSoundFlags(t);
    t.startMin=(window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date())).getMinutes();
    updateTimer(i); renderTimers();
  }
  function updateTimer(i){
    const t=window.timers[i]; if(!t) return;
    const el=$('t'+t.id); if(el){ const m=Math.floor(Math.abs(t.remain)/60), s=Math.floor(Math.abs(t.remain)%60), sign=t.remain<0?'-':''; el.childNodes[0].nodeValue = `${sign}${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; const ee=$('te'+t.id); if(ee){ const end=new Date(Date.now()+Math.max(0,t.remain)*1000); ee.textContent=`(終了 ${String(end.getHours()).padStart(2,'0')}:${String(end.getMinutes()).padStart(2,'0')})`; } }
    const fill=$('tf'+t.id); if(fill){ const pct=t.total>0? Math.max(0, Math.min(50000,t.remain/t.total*100)) : 0; fill.style.width=pct+'%'; fill.style.background=t.gaugeColor||'#4da3ff'; }
    drawTimerArcs(); nlRenderTimerOverlays();
  }
  function tickTimer(){
    (window.timers||[]).forEach((t,i)=>{
      if(t.running){
        const elapsed=(Date.now()-t.start)/1000;
        t.remain = t.total - elapsed;
        handleTimerSoundProgress(t);
        updateTimer(i);
        if(t.remain<=0 && !t.alerted){
          t.alerted=true; t.running=false; t.remain=0;
          ensureTimerFlags(t).complete = true;
          triggerTimerSound('timer.complete');
          try{ notify && notify('⏰ タイマー終了!'); }catch(e){}
          const el=$('t'+t.id); if(el){ el.classList.add('alert'); setTimeout(()=>el.classList.remove('alert'),1500);}
          renderTimers();
        }
      }
    });
  }

  // ============ Planner Clock Arcs ============
  function ensureTimerArcGroup(){
    let group = $('timerArcs');
    if(group) return group;
    // try to find planner clock SVG
    let svg = document.querySelector('#planner svg, .planner svg, svg#plannerClock, svg#clock, .clock svg, svg');
    if(!svg || !(svg instanceof SVGElement)) return null;
    group = document.createElementNS('http://www.w3.org/2000/svg','g');
    group.setAttribute('id','timerArcs');
    group.setAttribute('style','pointer-events:none');
    // Place just beneath hands, above other arcs
    const hands = svg.querySelector('#hands');
    if(hands && hands.parentNode){ hands.parentNode.insertBefore(group, hands); } else { svg.appendChild(group); }
    return group;
  }

  
function drawTimerArcs(){
  const group = ensureTimerArcGroup(); if(!group) return;
  while(group.firstChild) group.removeChild(group.firstChild);
  const modeSel = $('mode'); const faceMode = modeSel ? modeSel.value : 'hour';
  const now = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
  const timers = (window.timers||[]).filter(t=>t && t.total>0 && t.remain>0);
  const baseR = 210, insetBase = 50, insetStep = 16, sw = 6, s0 = -Math.PI/2;
  const totalMinOnFace = (faceMode==='day') ? 720 : 60;

  function fullCirclePath(r){ return arcPath(r, s0, s0+2*Math.PI, sw); }
  function addTrack(r){
    const track = document.createElementNS('http://www.w3.org/2000/svg','path');
    track.setAttribute('d', fullCirclePath(r));
    track.setAttribute('stroke', '#00000040');
    track.setAttribute('fill', 'none');
    track.setAttribute('opacity', '0.4');
    track.setAttribute('stroke-linecap','round');
    track.setAttribute('stroke-width', String(sw));
    group.appendChild(track);
  }
  function addArc(r, a1, a2, color, alpha){
    const p = document.createElementNS('http://www.w3.org/2000/svg','path');
    p.setAttribute('d', arcPath(r, a1, a2, sw));
    p.setAttribute('stroke', color || '#4da3ff');
    p.setAttribute('fill', 'none');
    p.setAttribute('opacity', String(alpha ?? 0.9));
    p.setAttribute('stroke-linecap','round');
    p.setAttribute('stroke-width', String(sw));
    group.appendChild(p);

    const ph = document.createElementNS('http://www.w3.org/2000/svg','path');
    ph.setAttribute('d', arcPath(r, a1, a2, Math.max(1, sw-3)));
    ph.setAttribute('stroke', '#ffffff');
    ph.setAttribute('fill', 'none');
    ph.setAttribute('opacity', String(Math.max(0, (alpha ?? 0.9) * 0.2)));
    ph.setAttribute('stroke-linecap','round');
    ph.setAttribute('stroke-width', String(Math.max(1, sw-3)));
    group.appendChild(ph);
  }

  timers.forEach((t, idx)=>{
    const r = baseR - (insetBase + idx*insetStep);
    addTrack(r);

    if (t.clockMode === 'outer') {
      // 一周＝t.total（秒）。残り割合で 12時から短くする
      const total = Math.max(1, t.total);
      const remain = Math.max(0, Math.min(t.remain, total));
      const frac = remain / total;
      if (frac <= 1e-4) return; // 完全非表示
      const a1 = s0;
      const a2 = s0 + 2*Math.PI*frac;
      addArc(r, a1, a2, (t.gaugeColor||'#4da3ff'), 0.95);
      return;
    }

    // 直接配置：最初の角度を固定。以降動かない。0で非表示
    if (t._anchorTotal !== t.total) { delete t._directAnchorAngle; t._anchorTotal = t.total; }
    if (t._directAnchorAngle == null) {
      const curMin = (faceMode==='day') ? ((now.getHours()%12)*60 + now.getMinutes()) : now.getMinutes();
      t._directAnchorAngle = minToAng(curMin, totalMinOnFace);
    }
    const a1 = t._directAnchorAngle;
    const spanMin = t.total / 60; // 分
    if (spanMin <= 0) return;
    const delta = (spanMin / totalMinOnFace) * 2*Math.PI;
    const a2 = a1 + delta;
    addArc(r, a1, a2, (t.gaugeColor||'#4da3ff'), 0.75);
  });
}


  // ============ Numberline Overlays ============
  function nlRenderTimerOverlays(){
    // clear
    document.querySelectorAll('.nl-row .nl-timer, .nl-row .nl-timer-outer').forEach(n=>n.remove());
    if(!(window.timers && window.timers.length)) return;
    const nowD = (window.__getNow?window.__getNow():(window.__getNow?window.__getNow():new Date()));
    const rows = Array.from(document.querySelectorAll('.nl-row'));
  rows.forEach(r=>{ r.__nlStack=0; r.__nlOuterStack=0; });
    if(!rows.length) return;

    // Identify current hour row
    const nowHourStart = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0).getTime();
    let currentRow = null;
    rows.forEach(row=>{ const ts = parseInt(row.dataset.startTs||'0',10); if(ts===nowHourStart) currentRow = row; });

    window.timers.forEach(t=>{
      const remainSec = Math.max(0, t.remain||0);
      if(remainSec<=0) return;
      const end = new Date(nowD.getTime() + remainSec*1000);

      // direct placement: overlap bars within each hour
      if(t.clockMode!=='outer'){
        rows.forEach(row=>{
          const startTs = parseInt(row.dataset.startTs||'0',10);
          const hourStart = new Date(startTs);
          const hourEnd   = new Date(startTs + 60*60000);
          const overlapStart = new Date(Math.max(nowD.getTime(), hourStart.getTime()));
          const overlapEnd   = new Date(Math.min(end.getTime(), hourEnd.getTime()));
          if(overlapEnd > overlapStart){
            const startMin = (overlapStart - hourStart)/60000;
            const endMin   = (overlapEnd   - hourStart)/60000;
            const leftPct  = Math.max(0, Math.min(50000,((startMin+0.0001)/60)*100));
            const rightPct = Math.max(0, Math.min(50000,((endMin+0.0001)/60)*100));
            const widthPct = Math.max(1, rightPct-leftPct);
            const bar = document.createElement('div');
            bar.className = 'nl-timer';
            bar.style.position='absolute';
            bar.style.left = leftPct + '%';
            bar.style.width = widthPct + '%';
            bar.style.height = '10px';
            bar.style.top = '96%'; // もう少し下げる
            bar.style.transform = 'translateY(-50%)';
            bar.style.borderRadius = '6px';
            bar.style.zIndex = '2';
            bar.style.background = (t.gaugeColor||'#4da3ff') + '80';
            bar.title = 'タイマー残り';
            row.__nlStack = (row.__nlStack||0);
bar.style.top = `calc(96% + ${row.__nlStack*12}px)`;
row.__nlStack++;
const barsEl = row.querySelector('.nl-bars');
            if(barsEl) barsEl.appendChild(bar);
          }
        });
      }else{
        // outer mode in numberline: 0-60 full width gauge that shrinks from right, only on current hour row
        if(currentRow){
          const barsEl = currentRow.querySelector('.nl-bars');
          if(barsEl){
            // make container full-width
            const total = Math.max(1, t.total);
            const pct = Math.max(0, Math.min(50000,(t.remain/total)*100));
            // background track
            const track = document.createElement('div');
            track.className = 'nl-timer-outer';
            track.style.position='absolute';
            track.style.left = '0%';
            track.style.width = '100%';
            track.style.height = '10px';
            track.style.top = '96%'; // もう少し下げる
            track.style.transform = 'translateY(-50%)';
            track.style.borderRadius = '6px';
            track.style.zIndex = '2';
            track.style.background = '#00000020';
            // fill from left to right, then we mask right side by width pct
            const fill = document.createElement('div');
fill.style.height='100%';
fill.style.width = pct + '%';
fill.style.right = '0';
fill.style.left = 'auto';
fill.style.transition = 'none'; // 右から減らす（右端固定で幅のみ縮小）
            fill.style.background = (t.gaugeColor||'#4da3ff') + '99';
            fill.style.borderRadius='6px';
            track.appendChild(fill);
            // 追加: 残り時間と終了時刻のラベル
            (function(){
              try{
                const label = document.createElement('div');
                label.className = 'nl-timer-label';
                label.style.position = 'absolute';
                label.style.left = '0';
                label.style.top = '-18px';
                label.style.fontSize = '12px';
                label.style.color = 'var(--muted)';
                label.style.pointerEvents = 'none';
                const end = new Date(nowD.getTime() + remainSec*1000);
                const pad = n=>String(n).padStart(2,'0');
                const mm = Math.floor(remainSec/60);
                const ss = Math.floor(remainSec%60);
                const hhE = pad(end.getHours());
                const mmE = pad(end.getMinutes());
                label.textContent = `残: ${mm}:${pad(ss)} / 終: ${hhE}:${mmE}`;
                track.appendChild(label);
              }catch(e){}
            })();
            currentRow.__nlOuterStack = (currentRow.__nlOuterStack||0);
track.style.top = `calc(96% + ${currentRow.__nlOuterStack*12}px)`;
currentRow.__nlOuterStack++;
barsEl.appendChild(track);
          }
        }
      }
    });
  }

  // ============ Bindings ============
  function bind(){
    const btnAddTimer = $('tAdd'); if(btnAddTimer) btnAddTimer.onclick = addTimer;
    const btnUntilStart = $('tUntilStart'); if(btnUntilStart) btnUntilStart.onclick = startTimerUntil;
    const btnAddSW = $('swAdd'); if(btnAddSW) btnAddSW.onclick = addSW;
    // default until time
    if($('tUntilTime')){ const d=new Date(Date.now()+25*60000); $('tUntilTime').value=`${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; }
    // loops
    if(!window.__timerIntV2) window.__timerIntV2 = setInterval(tickTimer, 250);
    if(!window.__swIntV2) window.__swIntV2 = setInterval(()=>{ (window.sws||[]).forEach(sw=>{ if(sw.running){ const sec=sw.elapsed + (Date.now()-sw.start)/1000; const el=$('sw'+sw.id); if(el) el.textContent=fmtSW(sec); } }); }, 250);
    if(!window.__nlTimerOverlayIntV2) window.__nlTimerOverlayIntV2 = setInterval(nlRenderTimerOverlays, 500);
    // initial draws
    renderTimers(); renderSW(); drawTimerArcs(); nlRenderTimerOverlays();
  }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', bind); else bind();
})();
</script>
<style data-planner-style="1" media="not all">
.nl-timer,.nl-timer-outer{box-shadow:0 1px 3px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.2)}
</style>

<style id="global-visual-effects" data-planner-style="1" media="not all">
  #globalEffectLayer{
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:100000;
    display:block;
  }
  .fx-overlay{
    position:absolute;
    inset:0;
    opacity:0;
    transition:opacity .25s ease, transform .25s ease;
    mix-blend-mode:screen;
  }
  .fx-overlay.show{opacity:1;}
  .fx-overlay.fade{opacity:0;}

  .fx-flash{
    background:radial-gradient(circle at center, rgba(255,255,255,.85), rgba(255,255,255,0));
    animation:fxFlash 720ms ease-out forwards;
  }
  @keyframes fxFlash{
    0%{opacity:0;}
    10%{opacity:1;}
    100%{opacity:0;}
  }

  .fx-bluepulse{
    background:radial-gradient(circle at center, rgba(77,163,255,.6), rgba(15,23,42,.0));
    filter:blur(2px);
    animation:fxBluePulse 1200ms ease-out forwards;
  }
  @keyframes fxBluePulse{
    0%{transform:scale(0.7);opacity:0;}
    35%{opacity:0.95;}
    100%{transform:scale(1.25);opacity:0;}
  }

  .fx-aurora{
    background:linear-gradient(125deg, rgba(123,92,255,.55), rgba(0,214,255,.35), rgba(255,255,255,.15));
    background-size:400% 400%;
    animation:fxAurora 1800ms ease forwards;
  }
  @keyframes fxAurora{
    0%{background-position:0% 50%;opacity:0;}
    20%{opacity:0.85;}
    100%{background-position:100% 50%;opacity:0;}
  }

  .fx-grid{
    background:
      repeating-linear-gradient(90deg, rgba(79,196,255,.2) 0 2px, transparent 2px 80px),
      repeating-linear-gradient(0deg, rgba(79,196,255,.2) 0 2px, transparent 2px 80px);
    animation:fxGrid 1400ms ease-out forwards;
  }
  @keyframes fxGrid{
    0%{opacity:0;transform:scale(1.1);}
    25%{opacity:.9;}
    100%{opacity:0;transform:scale(1.4);}
  }

  .fx-neon{
    background:radial-gradient(circle at center, rgba(255,255,255,.75) 0%, rgba(255,255,255,.15) 35%, rgba(0,0,0,0) 65%);
    mix-blend-mode:screen;
    animation:fxNeon 1500ms ease-out forwards;
  }
  @keyframes fxNeon{
    0%{opacity:0;transform:scale(0.5);}
    30%{opacity:.95;}
    100%{opacity:0;transform:scale(1.3);}
  }

  .fx-spark span,
  .fx-confetti span{
    position:absolute;
    top:50%; left:50%;
    width:6px; height:6px;
    border-radius:50%;
    animation-duration:1.4s;
    animation-fill-mode:forwards;
    transform:translate(-50%,-50%);
  }
  .fx-spark span{
    background:#fff;
    box-shadow:0 0 12px rgba(255,255,255,.9);
    animation-name:fxSpark;
  }
  @keyframes fxSpark{
    0%{opacity:0; transform:translate(-50%,-50%) scale(.2);}
    10%{opacity:1;}
    100%{opacity:0; transform:translate(calc(-50% + var(--x,0)), calc(-50% + var(--y,0))) scale(.05);}
  }
  .fx-confetti span{
    width:8px; height:14px;
    border-radius:2px;
    animation-name:fxConfetti;
    transform-origin:center;
  }
  @keyframes fxConfetti{
    0%{opacity:0; transform:translate(-50%,-50%) rotate(0deg);}
    10%{opacity:1;}
    100%{opacity:0; transform:translate(calc(-50% + var(--x,0)), calc(-50% + var(--y,40vh))) rotate(520deg);}
  }

  .fx-ripple::before,
  .fx-ripple::after{
    content:"";
    position:absolute;
    inset:20%;
    border:2px solid rgba(255,255,255,.6);
    border-radius:50%;
    animation:fxRipple 1100ms ease-out forwards;
  }
  .fx-ripple::after{
    animation-delay:.15s;
    border-color:rgba(77,163,255,.7);
  }
  @keyframes fxRipple{
    0%{transform:scale(.6);opacity:.9;}
    100%{transform:scale(1.8);opacity:0;}
  }
</style>

<script id="visual-effects-engine">
(()=>{
  if(window.VisualFX) return;
  const VisualFX = (function(){
    const catalog = [
      {id:'none', label:'(エフェクトなし)', className:'', duration:0},
      {id:'flash', label:'ホワイトフラッシュ', className:'fx-flash', duration:720},
      {id:'bluepulse', label:'ブルーパルス', className:'fx-bluepulse', duration:1200},
      {id:'aurora', label:'オーロラスウィープ', className:'fx-aurora', duration:1800},
      {id:'grid', label:'シアン・グリッド', className:'fx-grid', duration:1400},
      {id:'neon', label:'ネオンリング', className:'fx-neon', duration:1500},
      {id:'ripple', label:'リップルパルス', className:'fx-ripple', duration:1200},
      {id:'spark', label:'スター・スパーク', build:()=>spawnSpark(), duration:1500},
      {id:'confetti', label:'コンフェッティシャワー', build:()=>spawnConfetti(), duration:2000}
    ];
    const map = new Map(catalog.map(c=>[c.id,c]));

    function ensureLayer(){
      let layer = document.getElementById('globalEffectLayer');
      if(!layer){
        layer = document.createElement('div');
        layer.id = 'globalEffectLayer';
        layer.setAttribute('aria-hidden','true');
        document.body.appendChild(layer);
      }
      return layer;
    }
    function spawnBase(cls){
      const el = document.createElement('div');
      el.className = `fx-overlay ${cls||''}`;
      ensureLayer().appendChild(el);
      return el;
    }
    function spawnSpark(){
      const el = spawnBase('fx-spark');
      for(let i=0;i<18;i++){
        const star = document.createElement('span');
        star.style.setProperty('--x', `${(Math.random()*2-1)*40}vw`);
        star.style.setProperty('--y', `${(Math.random()*2-1)*30}vh`);
        star.style.animationDelay = (Math.random()*0.35).toFixed(2)+'s';
        el.appendChild(star);
      }
      return el;
    }
    function spawnConfetti(){
      const colors = ['#f97316','#38bdf8','#f472b6','#a78bfa','#34d399','#facc15'];
      const el = spawnBase('fx-confetti');
      for(let i=0;i<26;i++){
        const piece = document.createElement('span');
        piece.style.background = colors[i%colors.length];
        piece.style.setProperty('--x', `${(Math.random()*2-1)*60}vw`);
        piece.style.setProperty('--y', `${Math.random()*30 + 25}vh`);
        piece.style.animationDelay = (Math.random()*0.35).toFixed(2)+'s';
        el.appendChild(piece);
      }
      return el;
    }
    function play(id){
      if(!id || id==='none') return;
      const def = map.get(id);
      if(!def) return;
      const el = def.build ? def.build() : spawnBase(def.className);
      if(!el) return;
      requestAnimationFrame(()=>el.classList.add('show'));
      const life = def.duration || 1500;
      if(life>200){
        setTimeout(()=>el.classList.add('fade'), Math.max(0, life-250));
      }
      setTimeout(()=>{ el.remove(); }, life+350);
    }
    return { catalog, play };
  })();
  window.VisualFX = VisualFX;
})();
</script>

<script id="fix-clock-updater">
(()=>{
  if (window.__clockFixInstalled) return;
  window.__clockFixInstalled = true;
  const $=s=>document.querySelector(s);
  const h=$('#hHand'), m=$('#mHand'), s=$('#sHand');
  const dg=$('#digitalTime'), dd=$('#digitalDate');
  const motionNodes = Array.from(document.querySelectorAll('#motion'));
  let motionValue = (motionNodes.find(node=>node && node.value)?.value) || 'tick';
  motionNodes.forEach(node=>{
    if(!node) return;
    node.value = motionValue;
    node.addEventListener('change', (e)=>{
      motionValue = e.target.value || 'tick';
      motionNodes.forEach(other=>{ if(other && other!==e.target) other.value = motionValue; });
    });
  });
  const motion = ()=> motionValue === 'smooth';
  let last=-1;
  function pad(n){return n<10?'0'+n:''+n;}
  function rot(el,deg){ if(el) el.setAttribute('transform',`rotate(${deg} 250 250)`); }
  function syncNumberlineHands(now){
    const rows = document.querySelectorAll('.nl-row');
    if(!rows.length) return;
    const hourStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 0, 0, 0).getTime();
    rows.forEach(row=>{
      const ts = parseInt(row.dataset.startTs||'0',10);
      const isCurrent = row.classList.contains('current') || ts===hourStart;
      if(ts===hourStart){ row.classList.add('current'); }
      else if(row.classList.contains('current')){ row.classList.remove('current'); }
      const sHand = row.querySelector('.nl-hand.s');
      const mHand = row.querySelector('.nl-hand.m');
      if(!sHand && !mHand) return;
      if(isCurrent){
        const ss = now.getSeconds();
        const mm = now.getMinutes();
        if(sHand) sHand.style.left = (ss/60*100)+'%';
        if(mHand) mHand.style.left = (mm/60*100)+'%';
      }else{
        if(sHand) sHand.style.left = '0%';
        if(mHand) mHand.style.left = '0%';
      }
    });
  }
  function tick(){
    const now = (typeof window.__getNow==='function')
      ? window.__getNow()
      : new Date();
    const hh=now.getHours()%12, mm=now.getMinutes(), ss=now.getSeconds(), ms=now.getMilliseconds();
    const sm=motion();
    const sec= sm?(ss+ms/1000):ss;
    const min= sm?(mm+sec/60):mm;
    const hr = sm?(hh+min/60):(hh+mm/60);
    rot(h, hr*30); rot(m, min*6); rot(s, sec*6);
    syncNumberlineHands(now);
    if(dg && dd && ss!==last){ last=ss;
      const wd=["日","月","火","水","木","金","土"][now.getDay()];
      dg.textContent = `${pad(now.getHours())}:${pad(mm)}:${pad(ss)}`;
      dd.textContent = `${now.getFullYear()}年${now.getMonth()+1}月${now.getDate()}日（${wd}）`;
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();
</script>


<script id="time-scale-engine">
(()=>{
  if (window.__timeScaleInit) return;
  window.__timeScaleInit = true;
  let scale = 1, baseReal = Date.now(), baseVirt = Date.now();
  function getNowMs(){ if (scale === 1) return Date.now(); return baseVirt + (Date.now()-baseReal)*scale; }
  window.__getNow = ()=> new Date(getNowMs());
  window.__getTimeScale = ()=> scale;
  window.__setTimeScale = (s)=>{
    s = Math.max(1, Math.min(50000,parseInt(s)||1));
    if (s === scale) return;
    baseVirt = getNowMs(); baseReal = Date.now(); scale = s;
  };
  // Wire UI if present
  function bindUI(){
    const sel = document.getElementById('timeScale');
    if (!sel) return;
    sel.onchange = ()=> window.__setTimeScale(sel.value);
  }
  document.addEventListener('DOMContentLoaded', bindUI);
  bindUI();
})();
</script>


<script id="direct-anchor-store">
(()=>{
  if (!window.__directAnchors) {
    try { window.__directAnchors = new WeakMap(); }
    catch(e){ window.__directAnchors = new Map(); } // fallback
  }
})();
</script>


<script>
// === Timer HUD (残り時間と終了時刻の数値表示・クリック操作) ===
(function(){
  if (window.__timerHudInit) return; window.__timerHudInit = true;

  const $ = (id)=>document.getElementById(id);
  function pad(n){ return String(n).padStart(2,'0'); }

  // Track which timer to show: prefer the most recently started running timer.
  let activeIndex = -1;
  function chooseActive(){
    // Prefer running timers. If multiple, pick the one with the earliest (closest) end.
    let candidate = -1, bestRem = Infinity;
    (window.timers||[]).forEach((t,i)=>{
      if(t.running){
        if(t.remain < bestRem){ bestRem = t.remain; candidate = i; }
      }
    });
    // If none running, show the one that most recently finished (remain<=0) or the last interacted.
    if(candidate===-1){
      (window.timers||[]).forEach((t,i)=>{
        if(t.remain<=0){
          if(Math.abs(t.remain) < Math.abs(bestRem)){ bestRem = t.remain; candidate = i; }
        }
      });
    }
    if(candidate!==-1) activeIndex = candidate;
  }

  function formatEndFromRemain(remSec){
    const base = new Date();
    const end = new Date(base.getTime() + Math.max(0, remSec)*1000);
    return `${pad(end.getHours())}:${pad(end.getMinutes())}`;
  }

  function hudLabel(t){
    const sec = Math.floor(Math.abs(t.remain||0));
    const mm  = Math.floor(sec/60), ss = sec%60;
    const sign = (t.remain||0) < 0 ? '-' : '';
    const endStr = formatEndFromRemain(Math.max(0, t.remain||0));
    const left = `${sign}${pad(mm)}:${pad(ss)}`;
    return `残 ${left} ｜ 終 ${endStr}`;
  }

  function applyStyle(el, t){
    el.classList.remove('strong','warn','danger');
    if(!t) return;
    if(t.remain<=0) el.classList.add('danger');
    else if(t.remain<=60) el.classList.add('warn');
    else el.classList.add('strong');
  }

  function updateHUD(){
    const el1 = $('plTimerHUD');
    const el2 = $('nlTimerHUD');
    if(!el1 && !el2) return;
    chooseActive();
    const t = (window.timers||[])[activeIndex];
    if(!t){
      if(el1){ el1.textContent = ''; el1.style.display='none'; }
      if(el2){ el2.textContent = ''; el2.style.display='none'; }
      return;
    }
    const text = hudLabel(t);
    if(el1){ el1.style.display='inline-block'; el1.textContent = text; applyStyle(el1,t); }
    if(el2){ el2.style.display='inline-block'; el2.textContent = text; applyStyle(el2,t); }
  }

  // Click behavior
  function onClickHUD(){
    chooseActive();
    const t = (window.timers||[])[activeIndex];
    if(!t) return;
    if(t.remain<=0){
      // 終了（停止して0に確定）
      t.running = false; t.remain = 0; t.alerted = true;
      if(typeof renderTimers === 'function') renderTimers();
      updateHUD();
      return;
    }
    // toggle pause/resume
    if(t.running){ if(typeof pauseTimer === 'function') pauseTimer(activeIndex); }
    else{ if(typeof startTimer === 'function') startTimer(activeIndex); }
    updateHUD();
  }
  ['plTimerHUD','nlTimerHUD'].forEach(id=>{
    const el = $(id); if(el){ el.addEventListener('click', onClickHUD); }
  });

  // Monkey-patch key functions to keep HUD in sync
  function wrap(name, fn){
    const orig = window[name];
    window[name] = function(){
      const r = orig && orig.apply(this, arguments);
      try{ fn && fn.apply(this, arguments); }catch(e){}
      return r;
    };
  }
  wrap('startTimer', ()=>{ chooseActive(); updateHUD(); });
  wrap('pauseTimer', ()=>{ updateHUD(); });
  wrap('resetTimer', ()=>{ updateHUD(); });
  wrap('tickTimer',  ()=>{ updateHUD(); });
  wrap('renderTimers', ()=>{ updateHUD(); });

  // Hook "〜まで開始" to set focus to that timer
  const untilBtn = $('tUntilStart');
  if(untilBtn){
    untilBtn.addEventListener('click', ()=>{
      setTimeout(()=>{ chooseActive(); updateHUD(); }, 50);
    });
  }

  // Initial paint
  setInterval(updateHUD, 250);
  updateHUD();
})();
</script>


<!-- PATCH: numberline ETA/HUD position tweaks and label styling -->
<style id="nl-linear-fixes-20251101" data-planner-style="1" media="not all">
  /* 数直線のETAを見切れない位置に調整 */
  .nl-eta{ bottom:-18px !important; }
  /* 全体の残り時間HUDを少し下に */
  #nlTimerHUD{ margin-top:16px !important; }
  /* OUTERトラックのレーベル */
  .nl-timer-label{ white-space:nowrap; text-shadow:0 1px 2px rgba(0,0,0,.35); }
  /* 右端固定で痩せるためのfill配置 */
  .nl-outer-fill{ position:absolute; right:0; top:0; bottom:0; }
</style>

<style id="planner-pagecomplete-adjust" data-planner-style="1" media="not all">
  #pageCompleteBtn{ top:-4px !important; }
  @media (max-width:540px){
    #pageCompleteBtn{ top:-2px !important; }
  }
</style>


<script>
// --- injected: place delay counter to the right of remaining time ---
(function(){
  function arrange() {
    const rts = document.querySelectorAll('.remaining-time, .remain-time, .rest-time');
    rts.forEach(rt => {
      // Find nearest delay counter in the same schedule row
      let root = rt.closest('.schedule-item, .task-row, .timeline-entry, .study-row, .plan-row') || rt.parentElement;
      if(!root) root = rt.parentElement;
      if(!root) return;
      let delay = root.querySelector('.delay-counter, .extension-counter, .lateness, .overrun, .延長カウンター, .延長');
      // Wrap in a row container
      if (rt.parentElement && !rt.parentElement.classList.contains('remaining-time-row')) {
        const wrap = document.createElement('span');
        wrap.className = 'remaining-time-row';
        rt.parentElement.insertBefore(wrap, rt);
        wrap.appendChild(rt);
        if (delay) {
          wrap.appendChild(delay);
        } else {
          const d = document.createElement('span');
          d.className = 'delay-counter';
          wrap.appendChild(d);
        }
      } else if (delay && delay.parentElement !== rt.parentElement) {
        // Move delay next to remaining-time
        rt.parentElement.appendChild(delay);
      }
    });
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', arrange);
  } else {
    arrange();
  }
  // Re-apply on updates if the app fires custom events
  window.addEventListener('延長更新', arrange);
  window.addEventListener('study:update', arrange);
  // Fallback periodic check (lightweight)
  setInterval(arrange, 1500);
})();
</script>

<script>
// ===== サウンドマネージャ =====
(function(){
  const LS = "sound_prefs_v1";
  const $ = (sel,root=document)=>root.querySelector(sel);
  const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));
  const defaultEvents = [
    {key:"study.extend.start", name:"延長カウンター開始（勉強：最初の延長が発生）"},
    {key:"study.extend.tick",  name:"延長中の1分延長ごと（勉強）"},
    {key:"plan.start", name:"予定開始"},
    {key:"plan.end",   name:"予定終了"},
    {key:"minute.tick", name:"毎分"},
    {key:"minute.30",   name:"毎30分（00/30）"},
    {key:"hour.full",   name:"毎正時（00分）"},
    {key:"ui.click",    name:"ボタン操作音"},
    {key:"pomodoro.focus", name:"ポモドーロ開始"},
    {key:"pomodoro.break", name:"ポモドーロ休憩"},
    {key:"timer.start", name:"タイマー開始"},
    {key:"timer.resume", name:"タイマー再開"},
    {key:"timer.pause", name:"タイマー一時停止"},
    {key:"timer.half", name:"タイマー残り半分"},
    {key:"timer.last60", name:"タイマー残り60秒"},
    {key:"timer.last10", name:"タイマー残り10秒"},
    {key:"timer.last01", name:"タイマー残り1秒"},
    {key:"timer.complete", name:"タイマー完了"},
    {key:"delay.detected", name:"遅延の発生/継続検知"},
    {key:"deadline.soon", name:"予定終了1分前"},
    {key:"deadline.soon.m02", name:"予定終了2分前"},
    {key:"deadline.soon.m03", name:"予定終了3分前"},
    {key:"deadline.soon.m04", name:"予定終了4分前"},
    {key:"deadline.soon.m05", name:"予定終了5分前"},
    {key:"deadline.soon.m06", name:"予定終了6分前"},
    {key:"deadline.soon.m07", name:"予定終了7分前"},
    {key:"deadline.soon.m08", name:"予定終了8分前"},
    {key:"deadline.soon.m09", name:"予定終了9分前"},
    {key:"deadline.soon.m10", name:"予定終了10分前"},
    {key:"deadline.soon.m11", name:"予定終了11分前"},
    {key:"deadline.soon.m12", name:"予定終了12分前"},
    {key:"deadline.soon.m13", name:"予定終了13分前"},
    {key:"deadline.soon.m14", name:"予定終了14分前"},
    {key:"deadline.soon.m15", name:"予定終了15分前"},
    {key:"deadline.soon.m16", name:"予定終了16分前"},
    {key:"deadline.soon.m17", name:"予定終了17分前"},
    {key:"deadline.soon.m18", name:"予定終了18分前"},
    {key:"deadline.soon.m19", name:"予定終了19分前"},
    {key:"deadline.soon.m20", name:"予定終了20分前"},
  ];
  (function extendDefaultEvents(){
    const pad2 = (n)=>String(n).padStart(2,'0');
    defaultEvents.push({key:"second.tick", name:"毎秒（共通）"});
    for(let s=0;s<60;s++){
      defaultEvents.push({key:`second.s${pad2(s)}`, name:`${pad2(s)}秒リマインド`});
    }
    for(let h=0;h<24;h++){
      defaultEvents.push({key:`hour.${pad2(h)}`, name:`${pad2(h)}時ジャスト`});
    }
    [
      {key:"study.session.start", name:"勉強ページ開始"},
      {key:"study.session.mid", name:"勉強ページ折り返し"},
      {key:"study.session.last5", name:"勉強残り5分"},
      {key:"study.session.last1", name:"勉強残り1分"},
      {key:"study.session.done", name:"勉強ページ完了"},
      {key:"study.session.overtime", name:"勉強ページ延長警告"},
    ].forEach(ev=>defaultEvents.push(ev));
  })();
  const state = {
    enabled:false,
    ctx:null,
    nodes:{}, // key -> AudioBuffer
    conf:{},  // key -> {vol:0.8, loop:false, dataUrl:null, enabled:true}
    lastTick:{min:-1,hour:-1,halfMin:-1,sec:-1},
    bgm:{el:null, dataUrl:null, vol:0.3, loop:true, idbKey:null}
  };
  const EVENT_IDB_PREFIX = 'ev:';
  const BGM_IDB_KEY = 'bgm:main';

  function soundDataURLToBlob(dataUrl){
    if(!dataUrl || typeof dataUrl !== 'string') return null;
    const parts = dataUrl.split(',');
    if(parts.length<2) return null;
    const mimeMatch = parts[0].match(/:(.*?);/);
    const mime = mimeMatch ? mimeMatch[1] : 'audio/wav';
    const bstr = atob(parts[1]);
    const len = bstr.length;
    const u8 = new Uint8Array(len);
    for(let i=0;i<len;i++){ u8[i] = bstr.charCodeAt(i); }
    return new Blob([u8], {type:mime});
  }
  function getSoundIDB(){
    return window.__SoundIDB || null;
  }
  async function persistDataUrlToIDB(idbKey, dataUrl){
    const api = getSoundIDB();
    if(!api || !api.put || !dataUrl || !idbKey) return null;
    try{
      const blob = soundDataURLToBlob(dataUrl);
      if(!blob) return null;
      await api.put(idbKey, blob);
      return idbKey;
    }catch(e){
      console.warn('persistDataUrlToIDB failed', e);
      return null;
    }
  }
  async function deleteFromIDB(idbKey){
    const api = getSoundIDB();
    if(!api || !api.del || !idbKey) return;
    try{ await api.del(idbKey); }catch(e){ console.warn('deleteFromIDB failed', e); }
  }
  function save(){
    const payload = { conf: state.conf, bgm:{dataUrl:state.bgm.dataUrl, vol:state.bgm.vol, loop:state.bgm.loop, idbKey: state.bgm.idbKey||null} };
    localStorage.setItem(LS, JSON.stringify(payload));
  }
  function ensureEventConfig(key){
    if(!key) return null;
    if(!state.conf[key]){
      state.conf[key] = {vol:0.8, loop:false, dataUrl:null, enabled:false, effectId:'none'};
    }else if(!('effectId' in state.conf[key])){
      state.conf[key].effectId = 'none';
    }
    return state.conf[key];
  }
  function load(){
    try{
      const obj = JSON.parse(localStorage.getItem(LS)||'{}');
      state.conf = obj.conf||{};
      state.bgm.dataUrl = obj.bgm && obj.bgm.dataUrl || null;
      state.bgm.vol = obj.bgm && (obj.bgm.vol ?? 0.3);
      state.bgm.loop = obj.bgm && (obj.bgm.loop ?? true);
      state.bgm.idbKey = obj.bgm && obj.bgm.idbKey || null;
    }catch(e){}
    Object.keys(state.conf||{}).forEach(key=>ensureEventConfig(key));
    defaultEvents.forEach(ev=>ensureEventConfig(ev.key));
  }
  function unlockAudio(){
    if(state.enabled) return;
    try{
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      const o = ctx.createOscillator(); const g = ctx.createGain();
      g.gain.value = 0; o.connect(g); g.connect(ctx.destination);
      o.start(); o.stop(ctx.currentTime+0.01);
      state.ctx = ctx; state.enabled = true;
    }catch(e){}
  }
  async function decodeToBuffer(dataUrl){
    if(!state.ctx) unlockAudio();
    if(!state.ctx || !dataUrl) return null;
    const res = await fetch(dataUrl);
    const arr = await res.arrayBuffer();
    return await state.ctx.decodeAudioData(arr.slice(0));
  }
  async function decodeBlobToBuffer(blob){
    if(!state.ctx) unlockAudio();
    if(!state.ctx || !blob) return null;
    const arr = await blob.arrayBuffer();
    return await state.ctx.decodeAudioData(arr.slice(0));
  }
  const bufferPromises = {};
  async function ensureBufferForKey(key){
    if(state.nodes[key]) return state.nodes[key];
    if(bufferPromises[key]) return bufferPromises[key];
    const conf = state.conf[key];
    if(!conf) return null;
    bufferPromises[key] = (async()=>{
      let buf = null;
      try{
        if(conf.dataUrl){
          buf = await decodeToBuffer(conf.dataUrl);
        }else if(conf.idbKey){
          const api = getSoundIDB();
          if(api && api.get){
            const blob = await api.get(conf.idbKey);
            if(blob){ buf = await decodeBlobToBuffer(blob); }
          }
        }
      }catch(e){
        console.warn('ensureBufferForKey', e);
        buf = null;
      }
      if(buf){ state.nodes[key] = buf; }
      delete bufferPromises[key];
      return buf;
    })();
    return bufferPromises[key];
  }
  async function setEventSound(key, dataUrl){
    const conf = ensureEventConfig(key);
    conf.dataUrl = dataUrl; conf.enabled = true;
    save();
    // 先読み
    try{ state.nodes[key] = await decodeToBuffer(dataUrl); }catch(e){}
    // IDBにも保存して次回以降はそちらを参照
    try{
      const newKey = await persistDataUrlToIDB(EVENT_IDB_PREFIX + key, dataUrl);
      if(newKey){
        conf.idbKey = newKey;
        conf.dataUrl = null;
      }else{
        conf.idbKey = null;
      }
      save();
    }catch(_){
      conf.idbKey = null;
      save();
    }
  }
  async function clearSoundData(key){
    const conf = state.conf[key];
    if(!conf) return;
    const oldKey = conf.idbKey;
    conf.dataUrl = null;
    conf.idbKey = null;
    conf.enabled = false;
    delete state.nodes[key];
    save();
    if(oldKey){
      await deleteFromIDB(oldKey).catch(()=>{});
    }
  }
  function runEffectForKey(key){
    if(!key) return;
    const conf = ensureEventConfig(key);
    if(!conf || !conf.effectId || conf.effectId==='none') return;
    if(window.VisualFX && typeof VisualFX.play==='function'){
      try{ VisualFX.play(conf.effectId); }catch(_){}
    }
  }
  async function play(key){
    try{
      const c = state.conf[key];
      if(!c || !c.enabled) return;
      if(!state.ctx) unlockAudio();
      if(state.ctx){
        const buf = await ensureBufferForKey(key);
        if(buf){
          const src = state.ctx.createBufferSource();
          src.buffer = buf;
          src.loop = !!c.loop;
          const gain = state.ctx.createGain();
          gain.gain.value = c.vol ?? 0.8;
          src.connect(gain); gain.connect(state.ctx.destination); src.start(0);
          if(!src.loop){
            try{
              setTimeout(()=>{ try{ src.stop(); }catch(_e){} }, Math.max(100, (buf.duration||1)*1000));
            }catch(_e){}
          }
          return src;
        }
      }
      // フォールバック: dataURL を Audio で鳴らす
      if(c.dataUrl){
        const el = new Audio(c.dataUrl);
        el.volume = c.vol ?? 0.8;
        el.loop = !!c.loop;
        el.play();
        return el;
      }
      // 最終手段: IDB からBlobを取得してAudio再生
      if(c.idbKey){
        const api = getSoundIDB();
        if(api && api.get){
          const blob = await api.get(c.idbKey);
          if(blob){
            const url = URL.createObjectURL(blob);
            const el = new Audio(url);
            el.volume = c.vol ?? 0.8;
            el.loop = !!c.loop;
            el.onended = el.onerror = ()=>{ URL.revokeObjectURL(url); };
            el.play();
            return el;
          }
        }
      }
    }catch(e){
      console.warn('play failed', e);
    }
  }
  function fireSound(key){
    if(!key) return;
    runEffectForKey(key);
    try{
      const res = play(key);
      if(res && typeof res.catch==='function'){
        res.catch(()=>{});
      }
    }catch(_){}
  }
  function stopAll(){
    try{ if(state.ctx) state.ctx.close(); }catch(e){}
    state.enabled=false; state.ctx=null; state.nodes={};
  }
  // BGM
  function revokeBgmObjectUrl(){
    if(state.bgm && state.bgm.objUrl){
      try{ URL.revokeObjectURL(state.bgm.objUrl); }catch(_e){}
      state.bgm.objUrl = null;
    }
  }
  async function getBgmUrl(){
    if(state.bgm.dataUrl) return state.bgm.dataUrl;
    if(state.bgm.idbKey){
      const api = getSoundIDB();
      if(api && api.get){
        const blob = await api.get(state.bgm.idbKey);
        if(blob){
          revokeBgmObjectUrl();
          const url = URL.createObjectURL(blob);
          state.bgm.objUrl = url;
          return url;
        }
      }
    }
    return null;
  }
  async function bgmPlay(){
    if(state.bgm.el){ try{ state.bgm.el.pause(); }catch(_e){} }
    const url = await getBgmUrl();
    if(!url) return;
    const a = new Audio(url); a.loop = !!state.bgm.loop; a.volume = state.bgm.vol ?? 0.3;
    a.play(); state.bgm.el = a;
  }
  function bgmStop(){
    if(state.bgm.el){
      try{ state.bgm.el.pause(); }catch(_e){}
      state.bgm.el=null;
    }
  }
  async function setBgmSource(dataUrl){
    revokeBgmObjectUrl();
    state.bgm.dataUrl = dataUrl;
    save();
    try{
      const newKey = await persistDataUrlToIDB(BGM_IDB_KEY, dataUrl);
      if(newKey){
        state.bgm.idbKey = newKey;
        state.bgm.dataUrl = null;
      }else{
        state.bgm.idbKey = null;
      }
      save();
    }catch(_){
      state.bgm.idbKey = null;
      save();
    }
  }

  function getEffectCatalog(){
    if(window.VisualFX && Array.isArray(window.VisualFX.catalog) && window.VisualFX.catalog.length){
      return window.VisualFX.catalog;
    }
    return [{id:'none', label:'(エフェクトなし)'}];
  }
  function populateEffectSelect(select, selected){
    if(!select) return;
    const list = getEffectCatalog();
    const current = selected || 'none';
    select.innerHTML = '';
    list.forEach(item=>{
      const opt = document.createElement('option');
      opt.value = item.id;
      opt.textContent = item.label || item.id;
      if(item.id === current) opt.selected = true;
      select.appendChild(opt);
    });
  }

  // UI
  function renderUI(){
    const root = $('#soundRoot'); if(!root) return;
    root.innerHTML = '';
    defaultEvents.forEach(ev=>{
      const conf = ensureEventConfig(ev.key);
      const row = document.createElement('div');
      row.className = 'row';
      row.style.alignItems='center';
      row.style.justifyContent='space-between';
      row.style.border='1px solid var(--ring)'; row.style.borderRadius='10px'; row.style.padding='10px';
      row.style.background='rgba(255,255,255,.04)';
      const inputId = `file-${ev.key.replace(/[^a-zA-Z0-9_-]/g,'_')}`;
      row.innerHTML = `
        <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
          <div style="min-width:220px;font-size:13px;">${ev.name}</div>
          <input type="file" id="${inputId}" accept="audio/*" data-k="${ev.key}">
          <label style="font-size:12px;opacity:.8">音量</label>
          <input type="range" min="0" max="1" step="0.01" value="${conf.vol ?? 0.8}" data-k="${ev.key}" data-role="vol" style="width:120px">
          <label style="font-size:12px;opacity:.8">ループ</label>
          <input type="checkbox" ${conf.loop?'checked':''} data-k="${ev.key}" data-role="loop">
          <label style="font-size:12px;opacity:.8">有効</label>
          <input type="checkbox" ${conf.enabled?'checked':''} data-k="${ev.key}" data-role="enabled">
          <label style="font-size:12px;opacity:.8">エフェクト</label>
          <select data-role="effect" data-k="${ev.key}" style="min-width:160px;padding:4px 8px;border-radius:8px;background:rgba(255,255,255,.06);color:var(--fg);border:1px solid var(--ring);"></select>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn small" data-act="test" data-k="${ev.key}">テスト</button>
          <button class="btn small ghost" data-act="clear" data-k="${ev.key}">クリア</button>
        </div>`;
      root.appendChild(row);
      populateEffectSelect(row.querySelector('select[data-role="effect"]'), conf.effectId||'none');
    });
  }
  function bindUI(){
    const enableBtn = $('#soundEnableBtn');
    if(enableBtn) enableBtn.onclick = ()=>{ unlockAudio(); };
    const testAll = $('#soundTestAllBtn'); if(testAll) testAll.onclick = ()=>{ defaultEvents.forEach(ev=>fireSound(ev.key)); };
    const stopBtn = $('#soundStopAllBtn'); if(stopBtn) stopBtn.onclick = ()=>{ stopAll(); };

    const exportBtn = $('#soundExportBtn'); if(exportBtn) exportBtn.onclick = ()=>{
      const blob = new Blob([JSON.stringify({conf:state.conf, bgm:{dataUrl:state.bgm.dataUrl, vol:state.bgm.vol, loop:state.bgm.loop}}, null, 2)], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'sound_prefs.json'; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    };
    const importInput = $('#soundImportInput'); if(importInput){
      importInput.onchange = async()=>{
        const f = importInput.files && importInput.files[0]; if(!f) return;
        const txt = await f.text();
        try{
          const obj = JSON.parse(txt||'{}');
          if(obj.conf) state.conf = obj.conf;
          if(obj.bgm){ state.bgm.dataUrl = obj.bgm.dataUrl||null; state.bgm.vol = obj.bgm.vol ?? 0.3; state.bgm.loop = obj.bgm.loop ?? true; }
          save(); renderUI();
        }catch(e){}
      };
    }
    const root = $('#soundRoot');
    root.addEventListener('change', async(e)=>{
      const t = e.target; const key = t.getAttribute('data-k');
      if(!key) return;
      const conf = ensureEventConfig(key);
      if(t.type==='file'){
        const f = t.files && t.files[0]; if(!f) return;
        const reader = new FileReader();
        reader.onload = async(ev)=>{ await setEventSound(key, ev.target.result); };
        reader.readAsDataURL(f);
      }else if(t.getAttribute('data-role')==='vol'){
        conf.vol = parseFloat(t.value||'0.8'); save();
      }else if(t.getAttribute('data-role')==='loop'){
        conf.loop = !!t.checked; save();
      }else if(t.getAttribute('data-role')==='enabled'){
        conf.enabled = !!t.checked; save();
      }else if(t.getAttribute('data-role')==='effect'){
        conf.effectId = t.value || 'none'; save();
      }
    });
    root.addEventListener('click', (e)=>{
      const t = e.target; const key = t.getAttribute('data-k'); const act = t.getAttribute('data-act');
      if(act==='test'){ fireSound(key); }
      if(act==='clear' && key){
        clearSoundData(key).then(()=>renderUI()).catch(()=>renderUI());
      }
    });
    // BGM
    const bgmFile = $('#bgmFile'); if(bgmFile){ bgmFile.onchange = async()=>{
      const f = bgmFile.files && bgmFile.files[0]; if(!f) return;
      const reader = new FileReader();
      reader.onload = ev=>{ setBgmSource(ev.target.result); };
      reader.readAsDataURL(f);
    };}
    const bgmVol = $('#bgmVol'); if(bgmVol){ bgmVol.oninput = ()=>{ state.bgm.vol = parseFloat(bgmVol.value||'0.3'); if(state.bgm.el) state.bgm.el.volume = state.bgm.vol; save(); }; }
    const bgmLoop = $('#bgmLoop'); if(bgmLoop){ bgmLoop.onchange = ()=>{ state.bgm.loop = !!bgmLoop.checked; if(state.bgm.el) state.bgm.el.loop = state.bgm.loop; save(); }; }
    const bPlay = $('#bgmPlay'); if(bPlay){ bPlay.onclick = ()=>{ unlockAudio(); bgmPlay(); }; }
    const bStop = $('#bgmStop'); if(bStop){ bStop.onclick = ()=>{ bgmStop(); }; }

    // UIクリック音
    document.addEventListener('click',(e)=>{
      const tag = (e.target.tagName||'').toLowerCase();
      if(tag==='button' || tag==='a' || e.target.classList.contains('btn')){
        fireSound('ui.click');
      }
    }, {capture:true});
  }

  // 分・時刻トリガ
  function timeTick(nowMs){
    // minute
    const d = new Date(nowMs);
    const pad2 = (n)=>String(n).padStart(2,'0');
    if(d.getSeconds() !== state.lastTick.sec){
      state.lastTick.sec = d.getSeconds();
      fireSound('second.tick');
      fireSound(`second.s${pad2(state.lastTick.sec)}`);
    }
    if(d.getMinutes() !== state.lastTick.min){
      state.lastTick.min = d.getMinutes();
      fireSound('minute.tick');
      const m = d.getMinutes();
      if(m===0 || m===30){ fireSound('minute.30'); }
    }
    if(d.getHours() !== state.lastTick.hour){
      state.lastTick.hour = d.getHours();
      fireSound(`hour.${pad2(state.lastTick.hour)}`);
      if(d.getMinutes()===0) fireSound('hour.full');
    }
  }

  // 予定開始/終了フック（外部から利用）
  window.SoundMgr = {
    play, trigger:(k)=>fireSound(k), timeTick, unlockAudio,
    __state: state, __load: load, __render: renderUI
  };
  window.__runSoundEffectForKey = runEffectForKey;
  load();
  // タブが開かれたときにUI描画
  document.addEventListener('click', (e)=>{
    if(e.target && e.target.classList && e.target.classList.contains('tab')){
      if(e.target.dataset.tab==='sound'){ setTimeout(()=>{ renderUI(); bindUI(); }, 0); }
    }
  });
  // 初回も軽く準備
  setTimeout(()=>{ renderUI(); bindUI(); }, 0);
})();
</script>


<!-- Sound Upgrade: IndexedDB-backed storage and robust playback -->
<script>
(function(){
  const LS = 'sound_prefs_v1'; // reuse existing key for metadata

  // --- IndexedDB helper ---
  const DB_NAME = 'planner-sounds';
  const STORE = 'sounds';
  function openDB(){
    return new Promise((resolve, reject)=>{
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = (e)=>{
        const db = e.target.result;
        if(!db.objectStoreNames.contains(STORE)){
          db.createObjectStore(STORE, { keyPath: 'key' });
        }
      };
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error);
    });
  }
  async function idbPut(key, blob){
    const db = await openDB();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).put({ key, blob });
      tx.oncomplete = ()=>resolve(true);
      tx.onabort = tx.onerror = ()=>reject(tx.error);
    });
  }
  async function idbGet(key){
    const db = await openDB();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(STORE, 'readonly');
      const req = tx.objectStore(STORE).get(key);
      req.onsuccess = ()=>resolve(req.result && req.result.blob || null);
      req.onerror = ()=>reject(req.error);
    });
  }
  async function idbDel(key){
    const db = await openDB();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).delete(key);
      tx.oncomplete = ()=>resolve(true);
      tx.onabort = tx.onerror = ()=>reject(tx.error);
    });
  }

  window.__SoundIDB = Object.assign(window.__SoundIDB || {}, {
    put: idbPut,
    get: idbGet,
    del: idbDel,
    dataURLtoBlob
  });

  function saveMeta(conf, bgm){
    try{
      const payload = { conf, bgm:{ dataUrl: null, vol: bgm.vol ?? 0.3, loop: !!bgm.loop, idbKey: bgm.idbKey || null } };
      localStorage.setItem(LS, JSON.stringify(payload));
    }catch(e){ console.warn('saveMeta', e); }
  }

  function dataURLtoBlob(dataUrl){
    const arr = dataUrl.split(',');
    const mime = arr[0].match(/:(.*?);/)[1] || 'audio/wav';
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    while(n--){ u8arr[n] = bstr.charCodeAt(n); }
    return new Blob([u8arr], {type:mime});
  }
  function blobToDataUrl(blob){
    return new Promise((resolve, reject)=>{
      try{
        const reader = new FileReader();
        reader.onload = ()=>resolve(reader.result);
        reader.onerror = ()=>reject(reader.error);
        reader.readAsDataURL(blob);
      }catch(err){
        reject(err);
      }
    });
  }

  async function migrateIfNeeded(){
    try{
      if(!window.SoundMgr || !SoundMgr.__state) return;
      const state = SoundMgr.__state;
      const conf = state.conf || {};
      let changed = false;
      for(const k of Object.keys(conf)){
        const c = conf[k];
        if(c && c.dataUrl && !c.idbKey){
          // move to IDB
          const blob = dataURLtoBlob(c.dataUrl);
          const key = 'ev:' + k;
          await idbPut(key, blob);
          c.idbKey = key;
          c.dataUrl = null;
          changed = true;
        }
      }
      // BGM migrate
      const bgm = state.bgm || {};
      if(bgm && bgm.dataUrl && !bgm.idbKey){
        const blob = dataURLtoBlob(bgm.dataUrl);
        const key = 'bgm:main';
        await idbPut(key, blob);
        bgm.idbKey = key;
        bgm.dataUrl = null;
        changed = true;
      }
      if(changed){
        saveMeta(conf, bgm);
        try{ SoundMgr.__render && SoundMgr.__render(); }catch(e){}
      }
    }catch(e){ console.warn('migrateIfNeeded', e); }
  }

  // --- Override play to use IDB if available ---
  const origPlay = window.SoundMgr && SoundMgr.play;
  async function playUpgraded(key){
    try{
      try{
        const fxRunner = window.__runSoundEffectForKey;
        if(typeof fxRunner === 'function'){ fxRunner(key); }
      }catch(_){}
      const st = SoundMgr.__state;
      const c = st.conf[key];
      if(!st.enabled || !c || !c.enabled) return;
      // prefer IDB
      if(c.idbKey){
        if(!st.ctx){ try{ SoundMgr.unlockAudio(); }catch(e){} }
        const blob = await idbGet(c.idbKey);
        if(blob){
          const arr = await blob.arrayBuffer();
          const buf = await st.ctx.decodeAudioData(arr.slice(0));
          const src = st.ctx.createBufferSource(); src.buffer = buf; src.loop = !!c.loop;
          const gain = st.ctx.createGain(); gain.gain.value = c.vol ?? 0.8;
          src.connect(gain); gain.connect(st.ctx.destination); src.start(0);
          if(!src.loop){ setTimeout(()=>{ try{ src.stop(); }catch(e){} }, Math.max(100, (buf.duration||1)*1000)); }
          return;
        }
      }
      // fallback to original behavior
      if(typeof origPlay === 'function'){ return origPlay(key); }
    }catch(e){
      try{ if(typeof origPlay === 'function') return origPlay(key); }catch(_){}
    }
  }

  // Hook UI file inputs within sound tab to store into IDB directly
  document.addEventListener('change', async (e)=>{
    const t = e.target;
    const isSoundInput = t && t.type==='file' && (t.id==='bgmFile' || (t.id && t.id.startsWith('file-')) || (t.closest && t.closest('#soundRoot')));
    if(!isSoundInput) return;
    const st = SoundMgr && SoundMgr.__state; if(!st) return;
    const files = t.files || [];
    if(files.length===0) return;
    const f = files[0];
    const dataKey = t.getAttribute('data-k');
    const readerKey = t.id==='bgmFile' ? 'bgm:main' : (dataKey ? ('ev:' + dataKey) : null);
    if(!readerKey) return;
    try{
      await idbPut(readerKey, f);
      if(t.id==='bgmFile'){
        st.bgm.idbKey = readerKey; st.bgm.dataUrl = null;
      }else{
        const k = t.getAttribute('data-k');
        if(!st.conf[k]) st.conf[k] = {effectId:'none'};
        if(typeof st.conf[k].vol!=='number') st.conf[k].vol = 0.8;
        if(typeof st.conf[k].loop!=='boolean') st.conf[k].loop = false;
        if(!('effectId' in st.conf[k])) st.conf[k].effectId = 'none';
        st.conf[k].idbKey = readerKey;
        st.conf[k].dataUrl = null;
        st.conf[k].enabled = true;
      }
      saveMeta(st.conf, st.bgm);
      try{ SoundMgr.__render && SoundMgr.__render(); }catch(_){}
    }catch(err){ console.warn('IDB put failed', err); }
  }, true);

  // Export/Import with IDB blobs
  function download(filename, text){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([text], {type:'application/json'}));
    a.download = filename; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  }
  async function doExport(){
    const st = SoundMgr.__state; const out = { version:2, items:[], bgm:null };
    for(const k of Object.keys(st.conf)){
      const c = st.conf[k]; if(!c) continue;
      let dataUrl = null, mime=null, name=null;
      if(c.idbKey){
        const blob = await idbGet(c.idbKey);
        if(blob){
          mime = blob.type||'audio/wav'; name = c.name||null;
          dataUrl = await blobToDataUrl(blob);
        }
      }else if(c.dataUrl){ dataUrl = c.dataUrl; }
      out.items.push({key:k, vol:c.vol??0.8, loop:!!c.loop, enabled:!!c.enabled, effectId:c.effectId||'none', dataUrl, mime, name});
    }
    // bgm
    if(st.bgm && st.bgm.idbKey){
      const blob = await idbGet(st.bgm.idbKey);
      if(blob){
        out.bgm = { vol: st.bgm.vol??0.3, loop: !!st.bgm.loop, dataUrl: await blobToDataUrl(blob) };
      }
    }
    download('sounds-export.json', JSON.stringify(out));
  }
  async function doImport(file){
    const txt = await file.text();
    const obj = JSON.parse(txt||'{}');
    const st = SoundMgr.__state;
    if(Array.isArray(obj.items)){
      for(const it of obj.items){
        if(it.dataUrl){
          const blob = dataURLtoBlob(it.dataUrl);
          const id = 'ev:' + it.key;
          await idbPut(id, blob);
          const conf = st.conf[it.key] = st.conf[it.key] || {};
          conf.vol = it.vol??0.8;
          conf.loop = !!it.loop;
          conf.enabled = !!it.enabled;
          conf.effectId = it.effectId || conf.effectId || 'none';
          conf.idbKey = id;
          conf.dataUrl = null;
        }
      }
    }
    if(obj.bgm && obj.bgm.dataUrl){
      const b = dataURLtoBlob(obj.bgm.dataUrl);
      await idbPut('bgm:main', b);
      st.bgm.idbKey = 'bgm:main'; st.bgm.dataUrl = null; st.bgm.vol = obj.bgm.vol??0.3; st.bgm.loop = !!obj.bgm.loop;
    }
    saveMeta(st.conf, st.bgm);
    try{ SoundMgr.__render && SoundMgr.__render(); }catch(e){}
  }

  // Wire buttons if present
  window.addEventListener('DOMContentLoaded', ()=>{
    try{
      // override play
      if(window.SoundMgr){ SoundMgr.play = playUpgraded; SoundMgr.trigger = (k)=>playUpgraded(k); }
      // export
      const ex = document.getElementById('soundExportBtn');
      if(ex){ ex.addEventListener('click', ()=>{ doExport(); }); }
      const imp = document.getElementById('soundImportInput');
      if(imp){ imp.addEventListener('change', (e)=>{ const f = imp.files && imp.files[0]; if(f) doImport(f); }); }
      migrateIfNeeded();
    }catch(e){ console.warn(e); }
  });
})();
</script>


<script>
// === テスト時の音重複防止パッチ (2025-11-05) ===
(function(){
  // すべての現在再生中のaudioを停止して解放
  function stopAllAudios(){
    try{
      document.querySelectorAll('audio').forEach(a=>{
        try{ a.pause(); }catch(_){}
        try{ a.currentTime = 0; }catch(_){}
      });
      if (window.__bgmAudio) {
        try{ window.__bgmAudio.pause(); }catch(_){}
      }
    }catch(e){}
  }
  // #soundRoot内の「テスト」クリックを捕捉して重複回避
  let lastClick = 0;
  function onTestCapture(e){
    const t = e.target;
    // ボタンかつ文言に「テスト」含む or data-act="test"
    const isBtn = t.closest('button, .btn');
    const label = (t.innerText || t.textContent || '').trim();
    const isTest = (t.dataset && t.dataset.act === 'test') || /テスト/.test(label);
    if(!isBtn || !isTest) return;
    const now = Date.now();
    if (now - lastClick < 200) { // 連打デバウンス
      e.stopPropagation();
      e.preventDefault();
      return;
    }
    lastClick = now;
    // 新規再生が始まる前に、既存の再生をすべて止める
    stopAllAudios();
    // ここでは伝播は継続し、既存のハンドラが新しい再生を開始
  }
  function bind(){
    const root = document.getElementById('soundRoot');
    if(root && !root.__noOverlapBound){
      root.addEventListener('click', onTestCapture, true); // captureで先に止める
      root.__noOverlapBound = true;
    }
  }
  document.addEventListener('DOMContentLoaded', bind);
  setTimeout(bind, 800);
  setTimeout(bind, 2500);
})();
</script>


<script>
// === テスト時の音重複・多重ハンドラ対策 強化版 (2025-11-05) ===
(function(){
  // 直前がテストクリックかどうかを示すフラグ
  let __testClickWindow = false;
  let __testClickTimer = null;

  function markTestWindow(){
    __testClickWindow = true;
    clearTimeout(__testClickTimer);
    __testClickTimer = setTimeout(()=>{ __testClickWindow = false; }, 600);
  }

  // すべての既存audioを停止
  function stopAllAudios(except){
    try{
      document.querySelectorAll('audio').forEach(a=>{
        if(except && a === except) return;
        try{ a.pause(); }catch(_){}
        try{ a.currentTime = 0; }catch(_){}
      });
      if(!except && window.__bgmAudio){
        try{ window.__bgmAudio.pause(); }catch(_){}
      }
    }catch(e){}
  }

  // playのモンキーパッチ：テスト窓口中に新規再生されるaudioは他を全停止してから再生
  (function(){
    const proto = window.HTMLMediaElement && HTMLMediaElement.prototype;
    if (!proto || proto.__patchedForTestNoOverlap) return;
    const _play = proto.play;
    proto.play = function(){
      if(__testClickWindow){
        // テスト中の再生は単一に保つ
        try{ stopAllAudios(this); }catch(_){}
        try{
          // まれに音割れ要因になる過大ゲインを避ける（ブラウザにより無効）
          if (typeof this.volume === 'number' && this.volume > 1) this.volume = 1;
        }catch(_){}
      }
      return _play.apply(this, arguments);
    };
    proto.__patchedForTestNoOverlap = true;
  })();

  // #soundRoot の「テスト」ボタンをキャプチャ
  let lastClick = 0;
  function onTestCapture(e){
    const t = e.target;
    const isBtn = t.closest && t.closest('button, .btn');
    const label = (t.innerText || t.textContent || '').trim();
    const isTest = (t.dataset && t.dataset.act === 'test') || /テスト/.test(label);
    if(!isBtn || !isTest) return;
    const now = Date.now();
    // 連打吸収
    if (now - lastClick < 250) {
      e.stopPropagation();
      e.stopImmediatePropagation && e.stopImmediatePropagation();
      e.preventDefault();
      return;
    }
    lastClick = now;
    // 以後しばらくを「テスト窓口」に
    markTestWindow();
    // 既存の再生は先に全部止める（これで多重ハンドラでも重畳しにくい）
    stopAllAudios();
    // ここでは伝播は流し、既存のハンドラが新規再生を開始
  }

  function bind(){
    const root = document.getElementById('soundRoot');
    if(root && !root.__noOverlapV2){
      root.addEventListener('click', onTestCapture, true);
      root.__noOverlapV2 = true;
    }
  }
  document.addEventListener('DOMContentLoaded', bind);
  setTimeout(bind, 800);
  setTimeout(bind, 2500);
})();
</script>


<script>
// === テスト再生の安定化・単一化（最優先ガード） (2025-11-05) ===
(function(){
  // テストクリック後の一定時間は「テスト専用モード」
  let testWindow = false;
  let testWindowTimer = null;
  let activeTestAudio = null; // その瞬間の唯一の再生ターゲット
  let activeSince = 0;

  function enterTestWindow(){
    testWindow = true;
    clearTimeout(testWindowTimer);
    testWindowTimer = setTimeout(()=>{ testWindow = false; activeTestAudio = null; }, 800);
  }

  // 既存のaudioを可能な限り止める
  function stopAll(except){
    try{
      document.querySelectorAll('audio').forEach(a=>{
        if(except && a===except) return;
        try{ a.pause(); }catch(_){}
        try{ a.currentTime = 0; }catch(_){}
      });
      if(!except && window.__bgmAudio){
        try{ window.__bgmAudio.pause(); }catch(_){}
      }
    }catch(_){}
  }

  // play()のパッチ：テストモード中は1本だけ許可
  (function(){
    const P = window.HTMLMediaElement && HTMLMediaElement.prototype;
    if(!P || P.__patchedTestSingletonV3) return;
    const _play = P.play;
    P.play = function(){
      // 常時：過剰音量を抑止
      try{ if(typeof this.volume==='number' && this.volume>1) this.volume = 1; }catch(_){}

      if(testWindow){
        const now = performance.now ? performance.now() : Date.now();
        if(!activeTestAudio){
          // 最初の1本を採用し、他は無視
          activeTestAudio = this;
          activeSince = now;
          stopAll(this);
          // 再生終了時に解放
          try{
            this.addEventListener('ended', ()=>{ if(activeTestAudio===this){ activeTestAudio=null; } }, {once:true});
          }catch(_){}
          return _play.apply(this, arguments);
        }else if(activeTestAudio === this){
          // 既に選ばれた本人は普通に再生
          return _play.apply(this, arguments);
        }else{
          // 別インスタンスの再生要求は**無視**（Promise互換で即解決）
          try{ this.pause(); this.currentTime = 0; }catch(_){}
          return Promise.resolve();
        }
      }
      // 通常時
      return _play.apply(this, arguments);
    };
    P.__patchedTestSingletonV3 = true;
  })();

  // 「テスト」ボタンのクリックを先取りしてテスト窓口を開く
  function isTestButton(el){
    if(!el) return false;
    const btn = el.closest && el.closest('button, .btn');
    if(!btn) return false;
    const label = (btn.innerText || btn.textContent || '').trim();
    return (btn.dataset && btn.dataset.act === 'test') || /テスト/.test(label);
  }

  let lastClick = 0;
  function onClickCapture(e){
    if(!isTestButton(e.target)) return;
    const now = Date.now();
    if(now - lastClick < 220){
      // 連打吸収
      e.stopPropagation();
      e.stopImmediatePropagation && e.stopImmediatePropagation();
      e.preventDefault();
      return;
    }
    lastClick = now;
    // テスト窓口開始 & 既存音を先に止める
    enterTestWindow();
    stopAll(null);
    // 以降は既存のハンドラへ流す（playパッチが単一化）
  }

  function bind(){
    const root = document.getElementById('soundRoot');
    if(root && !root.__testSingletonBind){
      root.addEventListener('click', onClickCapture, true); // capture段階
      root.__testSingletonBind = true;
    }
  }
  document.addEventListener('DOMContentLoaded', bind);
  setTimeout(bind, 600);
  setTimeout(bind, 2000);

  function ensurePlannerGuideLabel(){
    let label = plannerDirectState.label;
    if(label && !label.isConnected){ label = null; plannerDirectState.label = null; }
    if(!label){
      const wrap = document.querySelector('.clock-wrap');
      if(!wrap) return null;
      label = document.createElement('div');
      label.id = 'plannerDirectLabel';
      label.className = 'planner-direct-label';
      wrap.appendChild(label);
      plannerDirectState.label = label;
    }
    return label;
  }

  const Pomodoro = {
    running:false,
    paused:false,
    phase:'focus',
    cycle:1,
    focus:25,
    shortBreak:5,
    longBreak:15,
    longEvery:4,
    remainingMs:0,
    phaseEnds:0,
    timer:null
  };
  window.Pomodoro = Pomodoro;

  function readPomodoroConfig(){
    Pomodoro.focus = Math.max(1, parseInt(($('pomoFocus')||{value:25}).value,10)||25);
    Pomodoro.shortBreak = Math.max(1, parseInt(($('pomoBreak')||{value:5}).value,10)||5);
    Pomodoro.longBreak = Math.max(1, parseInt(($('pomoLongBreak')||{value:15}).value,10)||15);
    Pomodoro.longEvery = Math.max(1, parseInt(($('pomoLongEvery')||{value:4}).value,10)||4);
  }

  function setPomodoroPanelVisible(show){
    const panel = $('pomoPanel');
    if(panel){ panel.style.display = show ? 'flex' : 'none'; }
  }

  function initPomodoroUI(){
    const toggleBtn = $('pomo');
    const stopBtn = $('pomoStop');
    const panel = $('pomoPanel');
    if(toggleBtn){
      toggleBtn.addEventListener('click', ()=>{
        if(!panel) return;
        const open = panel.style.display==='flex';
        setPomodoroPanelVisible(!open);
        updatePomodoroButtons();
      });
    }
    if(stopBtn) stopBtn.onclick = ()=>stopPomodoro(true);
    if($('pomoStartBtn')) $('pomoStartBtn').onclick = startPomodoro;
    if($('pomoPauseBtn')) $('pomoPauseBtn').onclick = togglePomodoroPause;
    if($('pomoSkipBtn')) $('pomoSkipBtn').onclick = skipPomodoroPhase;
    updatePomodoroButtons();
    updatePomodoroUI();
  }

  function startPomodoro(){
    readPomodoroConfig();
    Pomodoro.running = true;
    Pomodoro.paused = false;
    Pomodoro.cycle = 1;
    beginPomodoroPhase('focus');
    setPomodoroPanelVisible(true);
    updatePomodoroButtons();
    updatePomodoroUI('ポモドーロ開始');
  }

  function beginPomodoroPhase(type){
    const minutes = type==='focus'
      ? Pomodoro.focus
      : (type==='longBreak' ? Pomodoro.longBreak : Pomodoro.shortBreak);
    Pomodoro.phase = type;
    Pomodoro.remainingMs = minutes * 60000;
    Pomodoro.phaseEnds = Date.now() + Pomodoro.remainingMs;
    if(Pomodoro.timer){ clearInterval(Pomodoro.timer); }
    Pomodoro.timer = setInterval(pomodoroTick, 1000);
    updatePomodoroUI();
  }

  function pomodoroTick(){
    if(!Pomodoro.running || Pomodoro.paused) return;
    const remain = Pomodoro.phaseEnds - Date.now();
    if(remain <= 0){
      advancePomodoroPhase();
    }else{
      Pomodoro.remainingMs = remain;
      updatePomodoroUI();
    }
  }

  function advancePomodoroPhase(){
    if(!Pomodoro.running) return;
    if(Pomodoro.phase === 'focus'){
      const isLong = Pomodoro.cycle % Pomodoro.longEvery === 0;
      beginPomodoroPhase(isLong ? 'longBreak' : 'break');
    }else{
      Pomodoro.cycle++;
      beginPomodoroPhase('focus');
    }
  }

  function togglePomodoroPause(){
    if(!Pomodoro.running) return;
    const pauseBtn = $('pomoPauseBtn');
    if(!Pomodoro.paused){
      Pomodoro.paused = true;
      Pomodoro.remainingMs = Math.max(0, Pomodoro.phaseEnds - Date.now());
      if(Pomodoro.timer){ clearInterval(Pomodoro.timer); Pomodoro.timer=null; }
      if(pauseBtn) pauseBtn.textContent = '▶ 再開';
      updatePomodoroUI('一時停止中');
    }else{
      Pomodoro.paused = false;
      Pomodoro.phaseEnds = Date.now() + Pomodoro.remainingMs;
      Pomodoro.timer = setInterval(pomodoroTick, 1000);
      if(pauseBtn) pauseBtn.textContent = '⏸ 一時停止';
      updatePomodoroUI('再開しました');
    }
    updatePomodoroButtons();
  }

  function skipPomodoroPhase(){
    if(!Pomodoro.running) return;
    advancePomodoroPhase();
    updatePomodoroUI('次のフェーズへ移動しました');
  }

  function stopPomodoro(manual){
    if(Pomodoro.timer){ clearInterval(Pomodoro.timer); Pomodoro.timer=null; }
    Pomodoro.running = false;
    Pomodoro.paused = false;
    Pomodoro.phase = 'focus';
    Pomodoro.remainingMs = 0;
    updatePomodoroButtons();
    updatePomodoroUI(manual ? 'ポモドーロを停止しました' : 'ポモドーロ完了');
    clearPomodoroVisuals();
  }

  function formatPhaseLabel(){
    if(Pomodoro.phase==='focus') return '集中';
    if(Pomodoro.phase==='longBreak') return '長休憩';
    return '休憩';
  }

  function updatePomodoroUI(message){
    const info = $('pomoInfo');
    const status = $('pomoStatus');
    const hud = $('pomoClockHUD');
    const remainingText = Pomodoro.remainingMs>0 ? formatDuration(Pomodoro.remainingMs) : '--:--';
    if(info){
      if(!Pomodoro.running){
        info.textContent = message || '停止中';
      }else{
        info.textContent = `${formatPhaseLabel()} #${Pomodoro.cycle} / 残り ${remainingText}`;
      }
    }
    if(status){
      if(message && !Pomodoro.running){
        status.textContent = message;
      }else if(Pomodoro.running){
        status.textContent = Pomodoro.paused ? '一時停止中' : `${formatPhaseLabel()}を進行中`;
      }else{
        status.textContent = '停止中';
      }
    }
    if(hud){
      if(Pomodoro.running){
        hud.style.display='inline-block';
        hud.textContent = Pomodoro.paused ? '🍅 一時停止中' : `🍅 ${formatPhaseLabel()} ${remainingText}`;
      }else{
        hud.style.display='none';
      }
    }
  }

  function updatePomodoroButtons(){
    const pauseBtn = $('pomoPauseBtn');
    const stopBtn = $('pomoStop');
    if(pauseBtn){
      pauseBtn.style.display = Pomodoro.running ? 'inline-block' : 'none';
      pauseBtn.textContent = Pomodoro.paused ? '▶ 再開' : '⏸ 一時停止';
    }
    if(stopBtn){
      stopBtn.style.display = Pomodoro.running ? 'block' : 'none';
    }
    const toggleBtn = $('pomo');
    if(toggleBtn){
      toggleBtn.textContent = Pomodoro.running ? '🍅 ポモドーロ稼働中' : '🍅 ポモドーロ開始';
      toggleBtn.classList.toggle('active', Pomodoro.running || ( $('pomoPanel') && $('pomoPanel').style.display==='flex'));
    }
  }

  function clearPomodoroVisuals(){
    const hud = $('pomoClockHUD'); if(hud) hud.style.display='none';
  }
})();
</script>
  </div>

  <!-- Modals -->

  <div class="modal window compact" id="compareModal">
    <div class="box">
      <div class="box-head">
        <h3 style="margin:0">比較する本を選択</h3>
        <button class="mini-menu" data-close aria-label="閉じる">×</button>
      </div>
      <select id="compareSelect" class="input" style="margin-bottom:8px"></select>
      <div class="row space" style="align-items:center">
        <span class="muted" style="font-size:12px">候補を選んでから実行</span>
        <div class="row" style="gap:6px">
          <button class="btn ghost" data-close>閉じる</button>
          <button class="btn primary" id="compareGo">並べて表示</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal window compact" id="boxSelectModal">
    <div class="box">
      <div class="box-head">
        <h3 style="margin:0">切り取りを保存</h3>
        <button class="mini-menu" data-close aria-label="閉じる">×</button>
      </div>
      <div class="snip-meta" id="snippetSourceHint">元ページ: -</div>
      <div class="snip-preview"><img id="snippetPreviewImg" alt="preview"/></div>
      <div class="row" style="gap:8px;margin-bottom:8px">
        <select id="boxSelect" style="flex:1"></select>
        <button class="btn ghost" id="newBoxBtn">+ 新規</button>
      </div>
      <input class="input" id="snippetName" placeholder="名前（任意）" style="margin-bottom:8px"/>
      <textarea class="input" id="snippetNote" placeholder="メモ/コメント（任意）" style="margin-bottom:8px"></textarea>
      <div class="tight-row" id="snippetAnswerArea" style="justify-content:flex-start">
        <label class="row" style="gap:6px"><input type="checkbox" id="snippetAlsoAnswer"/> 解答も追加</label>
        <label class="chip-check"><input type="radio" name="snippetAnswerMode" value="crop" id="snippetAnswerModeCrop" checked> 切り取る</label>
        <label class="chip-check"><input type="radio" name="snippetAnswerMode" value="page" id="snippetAnswerModePage"> 全体</label>
      </div>
      <div class="answer-hint" id="snippetAnswerHint">比較中の解答がある時だけ使えます</div>
      <div class="row space" style="margin-top:6px">
        <button class="btn ghost" data-close>キャンセル</button>
        <button class="btn primary" id="assignToBoxBtn">保存</button>
      </div>
    </div>
  </div>

  <div class="modal" id="newBoxModal">
    <div class="box">
      <h3>新しいボックス</h3>
      <input id="newBoxName" class="input" placeholder="ボックス名" />
      <div class="row" style="gap:8px;margin-top:8px">
        <input id="newBoxTags" class="input" placeholder="タグ（カンマ区切り, 任意）" />
      </div>
      <div class="row space" style="margin-top:10px">
        <button class="btn ghost" data-close>閉じる</button>
        <button class="btn primary" id="createBoxBtn">作成</button>
      </div>
    </div>
  </div>

  <div class="modal" id="pageInsertModal">
    <div class="box">
      <h3>ページの追加/挿入</h3>
      <p class="muted">画像を選ぶと現在の位置に挿入します（複数可）。</p>
      <input type="file" id="insertPicker" accept="image/*" multiple class="input"/>
      <div class="row space" style="margin-top:10px">
        <button class="btn ghost" data-close>閉じる</button>
        <button class="btn primary" id="insertNowBtn">挿入</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast hidden"></div>


<script>
/** ===== DB ===== */
const DB_NAME='study-ebook-db-v2-2';
const DB_VER=3;
let db;
function openDB(){
  return new Promise((resolve,reject)=>{
    const req=indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded=(e)=>{
      const db=e.target.result;
      if(!db.objectStoreNames.contains('books')){
        const s=db.createObjectStore('books',{keyPath:'id'});
        s.createIndex('createdAt','createdAt');
        s.createIndex('title','title');
        s.createIndex('tags','tags',{multiEntry:true});
        s.createIndex('folder','folder');
      }
      if(!db.objectStoreNames.contains('boxes')){
        const b=db.createObjectStore('boxes',{keyPath:'id'});
        b.createIndex('name','name');
        b.createIndex('createdAt','createdAt');
        b.createIndex('tags','tags',{multiEntry:true});
      }
      if(!db.objectStoreNames.contains('settings')) db.createObjectStore('settings',{keyPath:'key'});
    };
    req.onsuccess=()=>{db=req.result; resolve(db)};
    req.onerror=()=>reject(req.error);
  });
}
function tx(name,mode='readonly'){return db.transaction(name,mode).objectStore(name)}
function uuid(){return 'id-'+crypto.randomUUID()}
const dbReady = openDB();

const Book={
  async list(){await dbReady; return new Promise((res,rej)=>{const out=[];const c=tx('books').openCursor();c.onsuccess=e=>{const r=e.target.result;if(r){out.push(r.value);r.continue()}else res(out)};c.onerror=()=>rej(c.error)})},
  async add(b){await dbReady; return new Promise((res)=>{tx('books','readwrite').add(b).onsuccess=()=>res(b)})},
  async put(b){await dbReady; return new Promise((res)=>{tx('books','readwrite').put(b).onsuccess=()=>res(b)})},
  async get(id){await dbReady; return new Promise((res)=>{tx('books').get(id).onsuccess=e=>res(e.target.result)})},
  async del(id){await dbReady; return new Promise((res)=>{tx('books','readwrite').delete(id).onsuccess=()=>res(true)})}
};
const Box={
  async list(){await dbReady; return new Promise((res,rej)=>{const out=[];const c=tx('boxes').openCursor();c.onsuccess=e=>{const r=e.target.result;if(r){out.push(r.value);r.continue()}else res(out)};c.onerror=()=>rej(c.error)})},
  async add(b){await dbReady; return new Promise((res)=>{tx('boxes','readwrite').add(b).onsuccess=()=>res(b)})},
  async put(b){await dbReady; return new Promise((res)=>{tx('boxes','readwrite').put(b).onsuccess=()=>res(b)})},
  async get(id){await dbReady; return new Promise((res)=>{tx('boxes').get(id).onsuccess=e=>res(e.target.result)})},
  async del(id){await dbReady; return new Promise((res)=>{tx('boxes','readwrite').delete(id).onsuccess=()=>res(true)})}
};
// expose for helpers that look up via window.*
window.Book = Book;
window.Box = Box;

function loadStoredBool(key,fallback=false){
  try{
    const raw=localStorage.getItem(key);
    if(raw===null) return fallback;
    return raw==='1';
  }catch(err){
    return fallback;
  }
}
function saveStoredBool(key,value){
  try{localStorage.setItem(key,value?'1':'0');}catch(err){}
}
function applyPerfMode(on){
  document.documentElement.classList.toggle('performance-mode',on);
  if(document.body) document.body.classList.toggle('performance-mode',on);
  saveStoredBool(PERF_MODE_KEY,on);
}
function loadStoredNumber(key){
  try{
    const raw=localStorage.getItem(key);
    if(raw===null) return null;
    const num=parseInt(raw,10);
    return Number.isNaN(num)?null:num;
  }catch(err){
    return null;
  }
}
function saveStoredNumber(key,value){
  try{localStorage.setItem(key,String(value));}catch(err){}
}
function loadStoredJSON(key){
  try{
    const raw=localStorage.getItem(key);
    if(!raw) return null;
    return JSON.parse(raw);
  }catch(err){
    return null;
  }
}
function saveStoredJSON(key,value){
  try{ localStorage.setItem(key, JSON.stringify(value)); }catch(err){}
}
function loadRecentBoxes(){
  const arr=loadStoredJSON(BOX_RECENT_KEY);
  return Array.isArray(arr)?arr.filter(Boolean):[];
}
function bumpRecentBox(boxId){
  if(!boxId) return;
  const cur=loadRecentBoxes().filter(id=>id!==boxId);
  cur.unshift(boxId);
  saveStoredJSON(BOX_RECENT_KEY, cur.slice(0,50));
}

const LIBRARY_SHOW_ANSWERS_KEY='library-show-answers';
const LAST_PAGE_KEY_PREFIX='viewer-last-page:';
const LAST_COMPARE_KEY_PREFIX='viewer-last-compare:';
const LAST_COMPARE_WINDOW_KEY_PREFIX='viewer-last-compare-window:';
const LAST_BOX_VIEW_KEY='viewer-last-box-view';
const PERF_MODE_KEY='performance-mode';
const BOX_RECENT_KEY='box-recent-order';
const OPEN_TABS_STORAGE_KEY='open-tabs-v1';
const KEY_NAV_CONFIG_KEY='viewer-key-nav-config';
const DEFAULT_KEY_NAV_CONFIG={
  panStep:45,
  zoomStep:1.06,
  holdMs:140,
  bookClamp:false,
  panLeftKeys:['ArrowLeft'],
  panRightKeys:['ArrowRight'],
  panUpKeys:['ArrowUp'],
  panDownKeys:['ArrowDown'],
  zoomInKeys:['.','／','/','?','．','。','・','か','カ'],
  zoomOutKeys:['\\','＿','_','＼','を','ヲ','ろ','ロ'],
  zoomInCodes:['Period','Slash','IntlYen'],
  zoomOutCodes:['Backslash','IntlRo','Minus'],
  resetKeys:[','],
  resetCodes:['Comma']
};
function ensureCommaReset(cfg){
  const next=Object.assign({}, cfg);
  const keys=Array.isArray(next.resetKeys)?next.resetKeys.slice():[];
  if(!keys.includes(',')) keys.unshift(',');
  next.resetKeys=keys;
  const codes=Array.isArray(next.resetCodes)?next.resetCodes.slice():[];
  if(!codes.includes('Comma')) codes.unshift('Comma');
  next.resetCodes=codes;
  return next;
}
let keyNavConfig = (()=>ensureCommaReset(Object.assign({}, DEFAULT_KEY_NAV_CONFIG, loadStoredJSON(KEY_NAV_CONFIG_KEY)||{})))();
function setKeyNavConfig(next){
  keyNavConfig = ensureCommaReset(Object.assign({}, DEFAULT_KEY_NAV_CONFIG, keyNavConfig, next));
  saveStoredJSON(KEY_NAV_CONFIG_KEY, keyNavConfig);
}
const viewerMemory={
  book:{id:null,closed:true},
  box:{id:null,closed:true}
};
const perfModeEnabled = loadStoredBool(PERF_MODE_KEY,false);
applyPerfMode(perfModeEnabled);
const openTabsState=[];
let activeOpenTabId=null;
const openTabKey=(type,id)=>`${type}:${id}`;
function persistOpenTabs(){
  try{
    localStorage.setItem(OPEN_TABS_STORAGE_KEY, JSON.stringify({
      openTabs:openTabsState,
      active:activeOpenTabId
    }));
  }catch(err){}
}
function loadOpenTabsFromStorage(){
  try{
    const raw=localStorage.getItem(OPEN_TABS_STORAGE_KEY);
    if(!raw) return null;
    const obj=JSON.parse(raw);
    if(!obj || !Array.isArray(obj.openTabs)) return null;
    return {
      openTabs: obj.openTabs.filter(t=>t && t.type && t.id),
      active: obj.active || null
    };
  }catch(err){
    return null;
  }
}
function renderOpenTabs(){
  const wrap=document.getElementById('openTabs');
  if(!wrap) return;
  wrap.innerHTML='';
  openTabsState.forEach(tab=>{
    const el=document.createElement('div');
    el.className='tab open-tab'+(tab.key===activeOpenTabId?' active':'');
    el.dataset.key=tab.key;
    const label=document.createElement('span');
    label.className='label';
    label.textContent=(window.escapeHTML?escapeHTML:String)(tab.title|| (tab.type==='book'?'本':'ボックス'));
    const close=document.createElement('button');
    close.className='close';
    close.textContent='×';
    close.title='閉じる';
    close.addEventListener('click',(e)=>{ e.stopPropagation(); closeOpenTab(tab.key); });
    el.addEventListener('click',()=>handleOpenTabClick(tab.key));
    el.appendChild(label);
    el.appendChild(close);
    wrap.appendChild(el);
  });
  persistOpenTabs();
}
function ensureOpenTab(type,id,title){
  const key=openTabKey(type,id);
  const existing=openTabsState.find(t=>t.key===key);
  if(existing){
    existing.title=title||existing.title;
  }else{
    openTabsState.push({key,type,id,title:title|| (type==='book'?'本':'ボックス')});
  }
  activeOpenTabId=key;
  renderOpenTabs();
}
async function handleOpenTabClick(key){
  const tab=openTabsState.find(t=>t.key===key);
  if(!tab) return;
  activeOpenTabId=key;
  renderOpenTabs();
  persistOpenTabs();
  if(tab.type==='book'){
    if(state.activeTab==='planner') showTab('library');
    const book=await Book.get(tab.id);
    if(book){ mountBookViewer(book); }
    else{ showToast && showToast('本が見つかりません','error'); closeOpenTab(key); }
  }else if(tab.type==='box'){
    if(state.activeTab==='planner') showTab('boxes');
    const box=await Box.get(tab.id);
    if(box){ mountBoxViewer(box); }
    else{ showToast && showToast('ボックスが見つかりません','error'); closeOpenTab(key); }
  }
}
async function closeOpenTab(key){
  const idx=openTabsState.findIndex(t=>t.key===key);
  if(idx<0) return;
  const closed=openTabsState[idx];
  const wasActive = openTabsState[idx].key===activeOpenTabId;
  openTabsState.splice(idx,1);
  persistOpenTabs();
  if(wasActive){
    const fallback=openTabsState[idx] || openTabsState[idx-1] || openTabsState[openTabsState.length-1];
    if(fallback){
      activeOpenTabId=fallback.key;
      renderOpenTabs();
      await handleOpenTabClick(fallback.key);
    }else{
      activeOpenTabId=null;
      const viewerEl=document.getElementById('viewerView');
      if(viewerEl){ viewerEl.innerHTML=''; viewerEl.classList.add('hidden'); }
      document.body.classList.remove('reading');
      state.viewerContext=null;
      showTab(closed?.type==='box'?'boxes':'library');
    }
  }else{
    renderOpenTabs();
  }
}
async function restoreOpenTabs(){
  const stored=loadOpenTabsFromStorage();
  if(!stored || !stored.openTabs.length) return false;
  const normalized=stored.openTabs.map(t=>{
    const key=t.key || openTabKey(t.type,t.id);
    return {key,type:t.type,id:t.id,title:t.title|| (t.type==='box'?'ボックス':'本')};
  }).filter(t=>t.type==='book' || t.type==='box');
  if(!normalized.length) return false;
  openTabsState.splice(0, openTabsState.length, ...normalized);
  activeOpenTabId = normalized.some(t=>t.key===stored.active) ? stored.active : (normalized[0]?.key||null);
  renderOpenTabs();
  persistOpenTabs();
  if(activeOpenTabId){
    await handleOpenTabClick(activeOpenTabId);
  }
  return true;
}

function getLastPageIndex(bookId){
  if(!bookId) return 0;
  const saved=loadStoredNumber(LAST_PAGE_KEY_PREFIX+bookId);
  return saved===null?0:saved;
}
function setLastPageIndex(bookId,index){
  if(!bookId) return;
  saveStoredNumber(LAST_PAGE_KEY_PREFIX+bookId,index);
}
function getLastCompareIndex(baseId, targetId){
  if(!baseId || !targetId) return null;
  return loadStoredNumber(`${LAST_COMPARE_KEY_PREFIX}${baseId}:${targetId}`);
}
function setLastCompareIndex(baseId, targetId, index){
  if(!baseId || !targetId) return;
  saveStoredNumber(`${LAST_COMPARE_KEY_PREFIX}${baseId}:${targetId}`, index);
}
function getLastCompareWindowIndex(baseId, targetId){
  if(!baseId || !targetId) return null;
  return loadStoredNumber(`${LAST_COMPARE_WINDOW_KEY_PREFIX}${baseId}:${targetId}`);
}
function setLastCompareWindowIndex(baseId, targetId, index){
  if(!baseId || !targetId) return;
  saveStoredNumber(`${LAST_COMPARE_WINDOW_KEY_PREFIX}${baseId}:${targetId}`, index);
}
function getLastBoxView(){
  const obj = loadStoredJSON(LAST_BOX_VIEW_KEY);
  if(!obj || !obj.boxId) return null;
  return obj;
}
function setLastBoxView(boxId,index){
  if(!boxId) return;
  saveStoredJSON(LAST_BOX_VIEW_KEY,{boxId,index});
}
function collectHiddenAnswerIds(books){
  const set=new Set();
  (books||[]).forEach(b=>{
    const links=Array.isArray(b.answerBookIds)?b.answerBookIds:[];
    links.forEach(id=>{ if(id && id!==b.id) set.add(id); });
  });
  return set;
}

/** ===== State & Utils ===== */
const state={
  view:'library',
  viewMode:'grid',
  sort:'-createdAt',
  tagFilter:null,
  folderFilter:null,
  search:'',
  showAnswers:loadStoredBool(LIBRARY_SHOW_ANSWERS_KEY,false),
  activeTab:'library',
  viewerContext:null // 'book' | 'box'
};
let hiddenAnswerIdsCache=new Set();
let currentMode='single';
let compareHideBtn=null;
let compareRightHidden=false;
const MENU_ACTIONS_KEY='viewer-menu-actions';
const DEFAULT_MENU_ACTIONS=['toggleSpread','compareToggle','toggleSelect','insert','resetView','toggleHideRight','compareWindowToggle','linkedAnswerCompareQuick','linkedAnswerWindowQuick'];
const BOX_MENU_ACTIONS=['resetView','toggleZoomLock','togglePanLock','toggleSliceView','fitContain','fitWidth','prevPage','nextPage','menuJump','toggleMemoPanel','toggleMemoWindow','toggleFav','toggleWeak','toggleDone','multiToggle','multiAll','multiNone','multiDelete','multiState'];
const MENU_REQUIRED_ACTIONS=['compareWindowToggle','linkedAnswerCompareQuick','linkedAnswerWindowQuick'];
const safePrimaryAnswerId=()=>{ try{ return (typeof primaryAnswerId==='function') ? primaryAnswerId() : null; }catch(e){ return null; } };
const safeTriggerPrimaryAnswer=(mode)=>{ try{ if(typeof triggerPrimaryAnswer==='function') triggerPrimaryAnswer(mode); }catch(e){} };
function viewerRoot(){ return document.getElementById('viewerView'); }
function viewerControl(id){ return viewerRoot()?.querySelector(`#${id}`); }
function clickViewerControl(id){
  const el=viewerControl(id);
  el?.click();
  return Boolean(el);
}
function focusViewerControl(id){
  const el=viewerControl(id);
  if(!el) return false;
  el.focus?.();
  el.select?.();
  return true;
}
const menuActionDefs={
  toggleSpread:{id:'toggleSpread',label:'見開き',onClick:()=>clickViewerControl('spreadToggle')},
  compareToggle:{id:'compareToggle',label:'比較ON',onClick:()=>{ if(currentMode==='compare'){ clickViewerControl('compareEnd'); } else { clickViewerControl('compareStart'); } },updateButton:(btn)=>{ btn.textContent=currentMode==='compare'?'比較OFF':'比較ON'; }},
  toggleSelect:{id:'toggleSelect',label:'切り取り',onClick:()=>clickViewerControl('selectBtn')},
  insert:{id:'insert',label:'挿入',onClick:()=>clickViewerControl('insertBtn')},
  resetView:{id:'resetView',label:'表示リセット',onClick:()=>window.__viewerResetView?.({toast:true})},
  toggleHideRight:{id:'toggleHideRight',label:'右側隠す',onClick:()=>compareHideBtn?.click(),updateButton:(btn)=>{ btn.disabled = (currentMode!=='compare'); btn.textContent = compareRightHidden?'右側表示':'右側隠す'; }},
  compareWindowToggle:{id:'compareWindowToggle',label:'比較ウィンドウ',onClick:()=>clickViewerControl('compareWindowBtn'),updateButton:(btn)=>{ const open=document.getElementById('compareWindow')?.classList.contains('open'); btn.textContent=open?'比較ウィンドウOFF':'比較ウィンドウON'; }},
  compareWindowPrev:{id:'compareWindowPrev',label:'比較ウィンドウ前',onClick:()=>clickViewerControl('compareWindowPrev'),updateButton:(btn)=>{ const open=document.getElementById('compareWindow')?.classList.contains('open'); const target=viewerControl('compareWindowPrev'); btn.disabled=!open || !target || target.disabled; }},
  compareWindowNext:{id:'compareWindowNext',label:'比較ウィンドウ次',onClick:()=>clickViewerControl('compareWindowNext'),updateButton:(btn)=>{ const open=document.getElementById('compareWindow')?.classList.contains('open'); const target=viewerControl('compareWindowNext'); btn.disabled=!open || !target || target.disabled; }},
  compareWindowSelect:{id:'compareWindowSelect',label:'比較ウィンドウ選択',onClick:()=>clickViewerControl('compareWindowSelect')},
  compareWindowSync:{id:'compareWindowSync',label:'比較ウィンドウ透明',onClick:()=>clickViewerControl('compareWindowSync'),updateButton:(btn)=>{ const el=viewerControl('compareWindowSync'); btn.disabled=!el; const active=el?.classList.contains('active'); btn.textContent=active?'透明ON':'透明'; }},
  compareWindowJump:{id:'compareWindowJump',label:'比較ウィンドウ入力',onClick:()=>focusViewerControl('compareWindowJump'),updateButton:(btn)=>{ const input=viewerControl('compareWindowJump'); btn.disabled=!input || input.disabled; }},
  prevPage:{id:'prevPage',label:'前ページ',onClick:()=>clickViewerControl('prevBtn')},
  nextPage:{id:'nextPage',label:'次ページ',onClick:()=>clickViewerControl('nextBtn')},
  jumpFocus:{id:'jumpFocus',label:'ページ入力',onClick:()=>focusViewerControl('jumpInput')},
  menuJump:{
    id:'menuJump',
    label:'クイック移動',
    render:()=>{
      const wrap=document.createElement('div');
      wrap.className='quick-field';
      const input=document.createElement('input');
      input.type='number';
      input.placeholder='ページ番号';
      input.min='1';
      const btn=document.createElement('button');
      btn.className='btn small';
      btn.textContent='移動';
      const commit=()=>{
        const value=parseInt(input.value,10);
        if(Number.isNaN(value)) return;
        const jumpInput=viewerControl('jumpInput');
        const jumpGo=viewerControl('jumpGo');
        if(jumpInput) jumpInput.value=value;
        if(jumpGo){ jumpGo.click(); }
        input.value='';
      };
      btn.onclick=(e)=>{ e.stopPropagation(); commit(); };
      input.addEventListener('keydown',(e)=>{
        e.stopPropagation();
        if(e.key==='Enter'){ e.preventDefault(); commit(); }
      });
      wrap.appendChild(input);
      wrap.appendChild(btn);
      return {element:wrap, control:input};
    }
  },
  openBookMenu:{id:'openBookMenu',label:'メニューを開く',onClick:()=>clickViewerControl('bookMenuBtn')},
  openStageMenu:{id:'openStageMenu',label:'ステージ操作',onClick:()=>clickViewerControl('stageMenuBtn')},
  toggleMemoPanel:{id:'toggleMemoPanel',label:'メモ欄',onClick:()=>clickViewerControl('memoToggle'),updateButton:(btn)=>{ const memoBtn=viewerControl('memoToggle'); btn.textContent=memoBtn?.textContent?.trim()||'メモ欄'; }},
  toggleMemoWindow:{id:'toggleMemoWindow',label:'ミニメモ',onClick:()=>clickViewerControl('memoMiniBtn'),updateButton:(btn)=>{ const open=document.getElementById('memoWindow')?.classList.contains('open'); btn.textContent=open?'ミニメモを閉じる':'ミニメモを開く'; }},
  focusMemo:{id:'focusMemo',label:'メモを書く',onClick:()=>focusViewerControl('pageMemo')},
  linkedAnswerQuick:{
    id:'linkedAnswerQuick',
    label:'解答クイック',
    render:()=>{
      const wrap=document.createElement('div');
      wrap.className='quick-field';
      wrap.style.gap='6px';
      const select=document.createElement('select');
      select.className='input';
      select.style.minWidth='160px';
      const btnCompare=document.createElement('button');
      btnCompare.className='btn small';
      btnCompare.textContent='並べて比較';
      const btnWindow=document.createElement('button');
      btnWindow.className='btn small ghost';
      btnWindow.textContent='解答ウィンドウ';
      const refreshOptions=()=>{
        select.innerHTML='';
        const chips=[...document.querySelectorAll('#linkedAnswerQuick .answer-chip')];
        if(!chips.length){
          const opt=document.createElement('option'); opt.value=''; opt.textContent='解答なし';
          select.appendChild(opt); select.disabled=true; btnCompare.disabled=true; btnWindow.disabled=true;
          return;
        }
        select.disabled=false; btnCompare.disabled=false; btnWindow.disabled=false;
        chips.forEach(ch=>{
          const opt=document.createElement('option');
          opt.value=ch.dataset.answer||'';
          opt.textContent=ch.querySelector('strong')?.textContent||'解答';
          select.appendChild(opt);
        });
      };
      const triggerAction=(action)=>{
        const val=select.value;
        if(!val) return;
        const chip=document.querySelector(`#linkedAnswerQuick .answer-chip[data-answer="${val}"]`);
        const btn=chip?.querySelector(`button[data-action="${action}"]`);
        btn?.click();
      };
      btnCompare.onclick=(e)=>{ e.stopPropagation(); triggerAction('split'); };
      btnWindow.onclick=(e)=>{ e.stopPropagation(); triggerAction('window'); };
      wrap.appendChild(select);
      wrap.appendChild(btnCompare);
      wrap.appendChild(btnWindow);
      refreshOptions();
      wrap.__refreshLinkedAnswers = refreshOptions;
      return {element:wrap, control:select};
    },
    updateButton:(el)=>{
      if(el?.__refreshLinkedAnswers){ el.__refreshLinkedAnswers(); }
    }
  },
  linkedAnswerCompareQuick:{id:'linkedAnswerCompareQuick',label:'解答比較(先頭)',onClick:()=>safeTriggerPrimaryAnswer('compare'),updateButton:(btn)=>{ const ok=safePrimaryAnswerId()!=null; btn.disabled=!ok; }},
  linkedAnswerWindowQuick:{id:'linkedAnswerWindowQuick',label:'解答ウィンドウ(先頭)',onClick:()=>safeTriggerPrimaryAnswer('window'),updateButton:(btn)=>{ const ok=safePrimaryAnswerId()!=null; btn.disabled=!ok; }},
  toggleFav:{id:'toggleFav',label:'★お気に入り',onClick:()=>clickViewerControl('stFav'),updateButton:(btn)=>{ const chk=viewerControl('stFav'); if(!chk){ btn.disabled=true; return; } btn.disabled=false; btn.textContent=chk.checked?'★お気に入りOFF':'★お気に入りON'; }},
  toggleWeak:{id:'toggleWeak',label:'×苦手',onClick:()=>clickViewerControl('stWeak'),updateButton:(btn)=>{ const chk=viewerControl('stWeak'); if(!chk){ btn.disabled=true; return; } btn.disabled=false; btn.textContent=chk.checked?'×苦手OFF':'×苦手ON'; }},
  toggleDone:{id:'toggleDone',label:'✓完了',onClick:()=>clickViewerControl('stDone'),updateButton:(btn)=>{ const chk=viewerControl('stDone'); if(!chk){ btn.disabled=true; return; } btn.disabled=false; btn.textContent=chk.checked?'✓完了解除':'✓完了ON'; }},
  toggleZoomLock:{id:'toggleZoomLock',label:'ズームロック',onClick:()=>clickViewerControl('zoomLockBtn'),updateButton:(btn)=>{ const locked=viewerControl('zoomLockBtn')?.classList.contains('active'); btn.textContent=locked?'ズーム解除':'ズームロック'; }},
  togglePanLock:{id:'togglePanLock',label:'移動ロック',onClick:()=>clickViewerControl('panLockBtn'),updateButton:(btn)=>{ const locked=viewerControl('panLockBtn')?.classList.contains('active'); btn.textContent=locked?'移動解除':'移動ロック'; }},
  toggleSliceView:{id:'toggleSliceView',label:'ハーフ表示',onClick:()=>clickViewerControl('sliceViewBtn'),updateButton:(btn)=>{ const active=viewerControl('sliceViewBtn')?.classList.contains('active'); btn.textContent=active?'ハーフ解除':'ハーフ表示'; }},
  fitContain:{id:'fitContain',label:'フィット',onClick:()=>clickViewerControl('fitContain')},
  fitWidth:{id:'fitWidth',label:'幅フィット',onClick:()=>clickViewerControl('fitWidth')},
  flipScrub:{
    id:'flipScrub',
    label:'めくりゲージ',
    render:()=>{
      const wrap=document.createElement('div');
      wrap.className='quick-slider';
      const slider=document.createElement('input');
      slider.type='range';
      slider.min='1';
      slider.step='1';
      slider.value='1';
      slider.addEventListener('input',()=>{
        const scrub=document.getElementById('scrubRange');
        if(!scrub) return;
        scrub.value=slider.value;
        scrub.dispatchEvent(new Event('input',{bubbles:true}));
      });
      wrap.appendChild(slider);
      return {element:wrap, control:slider};
    },
    updateButton:(slider)=>{
      const scrub=document.getElementById('scrubRange');
      if(!slider || !scrub) return;
      const maxValue=scrub.getAttribute('max') || scrub.max || scrub.value || '1';
      slider.max=maxValue;
      slider.value=scrub.value || slider.value || '1';
    }
  },
  flipPlay:{id:'flipPlay',label:'めくり開始',onClick:()=>clickViewerControl('flipPlay')},
  flipStop:{id:'flipStop',label:'めくり停止',onClick:()=>clickViewerControl('flipStop')},
  floatPrev:{id:'floatPrev',label:'フロート前',onClick:()=>clickViewerControl('fPrev')},
  floatNext:{id:'floatNext',label:'フロート次',onClick:()=>clickViewerControl('fNext')},
  floatJump:{id:'floatJump',label:'フロート入力',onClick:()=>focusViewerControl('fJump')},
  floatGo:{id:'floatGo',label:'フロート移動',onClick:()=>clickViewerControl('fGo')},
  floatSelect:{id:'floatSelect',label:'フロート選択',onClick:()=>clickViewerControl('fSelect')},
  multiToggle:{id:'multiToggle',label:'複数選択ON/OFF',onClick:()=>clickViewerControl('multiToggle')},
  multiAll:{id:'multiAll',label:'すべて選択',onClick:()=>clickViewerControl('multiAll')},
  multiNone:{id:'multiNone',label:'選択解除',onClick:()=>clickViewerControl('multiNone')},
  multiMove:{id:'multiMove',label:'選択を移動',onClick:()=>clickViewerControl('multiMove')},
  multiCopy:{id:'multiCopy',label:'選択をコピー',onClick:()=>clickViewerControl('multiCopy')},
  multiDelete:{id:'multiDelete',label:'選択を削除',onClick:()=>clickViewerControl('multiDelete')},
  multiState:{id:'multiState',label:'選択の状態',onClick:()=>clickViewerControl('multiSet')},
  multiNewBook:{id:'multiNewBook',label:'選択から新本',onClick:()=>clickViewerControl('multiNewBook')}
};
let menuActionConfig=[];
function loadMenuActionConfig(){
  try{
    const raw=localStorage.getItem(MENU_ACTIONS_KEY);
    if(raw){
      const arr=JSON.parse(raw);
      if(Array.isArray(arr)){
        menuActionConfig=arr.filter(id=>menuActionDefs[id]);
        MENU_REQUIRED_ACTIONS.forEach(id=>{ if(menuActionDefs[id] && !menuActionConfig.includes(id)) menuActionConfig.push(id); });
        return;
      }
    }
  }catch(err){ console.warn('menu action config load failed', err); }
  menuActionConfig=[...DEFAULT_MENU_ACTIONS];
  MENU_REQUIRED_ACTIONS.forEach(id=>{ if(menuActionDefs[id] && !menuActionConfig.includes(id)) menuActionConfig.push(id); });
}
function saveMenuActionConfig(){
  try{localStorage.setItem(MENU_ACTIONS_KEY, JSON.stringify(menuActionConfig));}catch(err){}
}
loadMenuActionConfig();
let menuActionsContainerRef=null;
let menuActionSettingsRef=null;
// key navigation settings DOM refs
const keyNavForm={
  panStep:document.getElementById('keyPanStep'),
  zoomStep:document.getElementById('keyZoomStep'),
  holdMs:document.getElementById('keyHoldMs'),
  left:document.getElementById('keyLeftKeys'),
  right:document.getElementById('keyRightKeys'),
  up:document.getElementById('keyUpKeys'),
  down:document.getElementById('keyDownKeys'),
  zin:document.getElementById('keyZoomInKeys'),
  zout:document.getElementById('keyZoomOutKeys'),
  reset:document.getElementById('keyResetKeys'),
  leftCapture:document.getElementById('keyLeftCapture'),
  rightCapture:document.getElementById('keyRightCapture'),
  upCapture:document.getElementById('keyUpCapture'),
  downCapture:document.getElementById('keyDownCapture'),
  zinCapture:document.getElementById('keyZoomInCapture'),
  zoutCapture:document.getElementById('keyZoomOutCapture'),
  resetCapture:document.getElementById('keyResetCapture'),
  clamp:document.getElementById('keyClamp'),
  save:document.getElementById('keyNavSave')
};
const parseList=(val)=>{ return (val||'').split(',').map(s=>s.trim()).filter(Boolean); };
const wireKeyCapture=(button,input)=>{
  if(!button || !input) return;
  const stopHint=()=>{
    button.disabled=false;
    button.textContent='設定';
  };
  const startCapture=()=>{
    button.disabled=true;
    button.textContent='入力待ち…';
    input.focus();
    input.select?.();
    const handler=(e)=>{
      e.preventDefault();
      const keyName = e.key===' ' ? 'Space' : e.key;
      input.value = keyName;
      cleanup();
    };
    const cleanup=()=>{
      input.removeEventListener('keydown', handler, true);
      input.removeEventListener('blur', cleanup, true);
      stopHint();
    };
    input.addEventListener('keydown', handler, true);
    input.addEventListener('blur', cleanup, true);
  };
  button.addEventListener('click',(e)=>{ e.preventDefault(); startCapture(); });
};
['left','right','up','down','zin','zout','reset'].forEach(k=>{
  wireKeyCapture(keyNavForm[`${k}Capture`], keyNavForm[k]);
});
function renderKeyNavSettingsPanel(){
  if(!keyNavForm.panStep) return;
  keyNavForm.panStep.value=keyNavConfig.panStep||DEFAULT_KEY_NAV_CONFIG.panStep;
  keyNavForm.zoomStep.value=keyNavConfig.zoomStep||DEFAULT_KEY_NAV_CONFIG.zoomStep;
  keyNavForm.holdMs.value=keyNavConfig.holdMs||DEFAULT_KEY_NAV_CONFIG.holdMs;
  keyNavForm.left.value=Array.isArray(keyNavConfig.panLeftKeys)?keyNavConfig.panLeftKeys.join(', '):(DEFAULT_KEY_NAV_CONFIG.panLeftKeys.join(', '));
  keyNavForm.right.value=Array.isArray(keyNavConfig.panRightKeys)?keyNavConfig.panRightKeys.join(', '):(DEFAULT_KEY_NAV_CONFIG.panRightKeys.join(', '));
  keyNavForm.up.value=Array.isArray(keyNavConfig.panUpKeys)?keyNavConfig.panUpKeys.join(', '):(DEFAULT_KEY_NAV_CONFIG.panUpKeys.join(', '));
  keyNavForm.down.value=Array.isArray(keyNavConfig.panDownKeys)?keyNavConfig.panDownKeys.join(', '):(DEFAULT_KEY_NAV_CONFIG.panDownKeys.join(', '));
  keyNavForm.zin.value=Array.isArray(keyNavConfig.zoomInKeys)?keyNavConfig.zoomInKeys.join(', '):(DEFAULT_KEY_NAV_CONFIG.zoomInKeys.join(', '));
  keyNavForm.zout.value=Array.isArray(keyNavConfig.zoomOutKeys)?keyNavConfig.zoomOutKeys.join(', '):(DEFAULT_KEY_NAV_CONFIG.zoomOutKeys.join(', '));
  keyNavForm.reset.value=Array.isArray(keyNavConfig.resetKeys)?keyNavConfig.resetKeys.join(', '):(DEFAULT_KEY_NAV_CONFIG.resetKeys.join(', '));
  keyNavForm.clamp.checked=!!keyNavConfig.bookClamp;
}
renderKeyNavSettingsPanel();
if(keyNavForm.save){
  keyNavForm.save.onclick=(e)=>{
    e.preventDefault();
    const next={
      panStep:Math.max(10, parseInt(keyNavForm.panStep.value,10)||DEFAULT_KEY_NAV_CONFIG.panStep),
      zoomStep:Math.max(1.01, parseFloat(keyNavForm.zoomStep.value)||DEFAULT_KEY_NAV_CONFIG.zoomStep),
      holdMs:Math.max(40, parseInt(keyNavForm.holdMs.value,10)||DEFAULT_KEY_NAV_CONFIG.holdMs),
      bookClamp:!!keyNavForm.clamp.checked,
      panLeftKeys:parseList(keyNavForm.left.value),
      panRightKeys:parseList(keyNavForm.right.value),
      panUpKeys:parseList(keyNavForm.up.value),
      panDownKeys:parseList(keyNavForm.down.value),
      zoomInKeys:parseList(keyNavForm.zin.value),
      zoomOutKeys:parseList(keyNavForm.zout.value),
      resetKeys:parseList(keyNavForm.reset.value),
      // 明示的にコードのデフォルトを無効化（カスタムのみ使用）
      zoomInCodes:[],
      zoomOutCodes:[],
      resetCodes:[]
    };
    setKeyNavConfig(next);
    refreshZoomBounds();
    applyViewTransform();
    renderKeyNavSettingsPanel();
    showToast && showToast('キー操作設定を保存しました','ok');
  };
}
function updateQuickActionButtons(){
  const config = state.viewerContext==='box' ? BOX_MENU_ACTIONS : menuActionConfig;
  if(!config.length) return;
  config.forEach(id=>{
    const def=menuActionDefs[id];
    if(def?.updateButton && def.element){
      def.updateButton(def.element);
    }
  });
}
function renderMenuButtons(){
  if(!menuActionsContainerRef) return;
  menuActionsContainerRef.innerHTML='';
  Object.values(menuActionDefs).forEach(def=>{
    if(def) def.element=null;
  });
  const config = state.viewerContext==='box' ? BOX_MENU_ACTIONS : menuActionConfig;
  const list = config.length ? config : DEFAULT_MENU_ACTIONS;
  list.forEach(id=>{
    const def=menuActionDefs[id];
    if(!def) return;
    if(typeof def.render==='function'){
      const res=def.render();
      let root=null;
      let ref=null;
      if(res && typeof res==='object' && res.element){
        root=res.element;
        ref=res.control || res.element;
      }else if(res instanceof HTMLElement){
        root=res;
        ref=res;
      }
      if(!root) return;
      menuActionsContainerRef.appendChild(root);
      def.element=ref;
      return;
    }
    const btn=document.createElement('button');
    btn.className='btn small';
    btn.textContent=def.label;
    btn.dataset.action=id;
    btn.onclick=(e)=>{
      e.stopPropagation();
      def.onClick?.();
      updateQuickActionButtons();
    };
    menuActionsContainerRef.appendChild(btn);
    def.element=btn;
  });
  updateQuickActionButtons();
}
function renderMenuActionSettings(){
  if(!menuActionSettingsRef) return;
  menuActionSettingsRef.innerHTML='';
  Object.values(menuActionDefs).forEach(def=>{
    const row=document.createElement('label');
    row.className='row';
    row.style.gap='8px';
    row.style.marginBottom='6px';
    const checkbox=document.createElement('input');
    checkbox.type='checkbox';
    checkbox.checked=menuActionConfig.includes(def.id);
    checkbox.onchange=()=>toggleMenuAction(def.id, checkbox.checked);
    const span=document.createElement('span');
    span.textContent=def.label;
    row.appendChild(checkbox);
    row.appendChild(span);
    menuActionSettingsRef.appendChild(row);
  });
}
function toggleMenuAction(id, enabled){
  if(enabled){
    if(!menuActionConfig.includes(id)) menuActionConfig.push(id);
  }else{
    menuActionConfig=menuActionConfig.filter(x=>x!==id);
  }
  saveMenuActionConfig();
  renderMenuButtons();
  renderMenuActionSettings();
}
function initMenuActionSettings(){
  menuActionSettingsRef=document.getElementById('menuActionSettings');
  renderMenuActionSettings();
}
function showToast(msg,type=''){const t=document.getElementById('toast');t.textContent=msg;t.classList.remove('hidden');t.style.borderColor= type==='error'?'var(--danger)':type==='ok'?'var(--ok)':'#2a394f';setTimeout(()=>t.classList.add('hidden'),1600)}
function groupBy(arr,fn){const m={};arr.forEach(x=>{const k=fn(x);(m[k]=m[k]||[]).push(x)});return m}
function escapeHTML(str){return (str||'').replace(/[&<>"]/g,s=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[s]))}
function fileToDataURL(f){return new Promise((res,rej)=>{const r=new FileReader();r.onload=()=>res(r.result);r.onerror=rej;r.readAsDataURL(f)})}
/** ===== Library ===== */
function renderLibrary(books){
  const {viewMode,sort,tagFilter,folderFilter,search}=state;
  let list=[...books];
  if(tagFilter) list=list.filter(b=>(b.tags||[]).includes(tagFilter));
  if(folderFilter) list=list.filter(b=>(b.folder||'')===folderFilter);
  if(search){const q=search.toLowerCase();list=list.filter(b=>(b.title||'').toLowerCase().includes(q)||(b.tags||[]).some(t=>t.toLowerCase().includes(q)))}
  list.sort((a,b)=> sort==='-createdAt'?(b.createdAt||0)-(a.createdAt||0): sort==='title'?(a.title||'').localeCompare(b.title||'') : (b.pages?.length||0)-(a.pages?.length||0));

  const grid=document.getElementById('libraryGrid');
  const shelf=document.getElementById('libraryShelf');
  const listEl=document.getElementById('libraryList');
  grid.classList.add('hidden'); shelf.classList.add('hidden'); listEl.classList.add('hidden');

  if(viewMode==='grid'){
    grid.innerHTML='';
    list.forEach(b=> grid.appendChild(bookCard(b)));
    grid.classList.remove('hidden');
  }else if(viewMode==='list'){
    listEl.innerHTML='';
    list.forEach(b=>{
      const it=document.createElement('div'); it.className='item';
      it.innerHTML=`<div class="row space" style="width:100%">
        <div class="row" style="gap:10px">
          <span class="pill">${b.pages?.length||0}p</span>
          <strong>${escapeHTML(b.title||'無題')}</strong>
          <span class="muted">${(b.tags||[]).join(', ')}</span>
        </div>
        <div class="row" style="gap:6px">
          <button class="btn small" data-open="${b.id}">開く</button>
          <button class="btn small ghost" data-edit="${b.id}">編集</button>
          <button class="btn small" data-dup="${b.id}">複製</button>
          <button class="btn small danger" data-del="${b.id}">削除</button>
        </div>
      </div>`;
      listEl.appendChild(it);
    });
    listEl.classList.remove('hidden');
  }else{
    shelf.innerHTML='';
    const groups=groupBy(list,b=>b.folder||'未分類');
    Object.entries(groups).forEach(([fold,arr])=>{
      const box=document.createElement('div'); box.className='card';
      box.innerHTML=`<div class="meta"><div class="row space"><strong>${escapeHTML(fold)}</strong><span class="muted">${arr.length}冊</span></div></div>`;
      const sub=document.createElement('div'); sub.className='grid'; sub.style.padding='0 12px 12px';
      arr.forEach(b=> sub.appendChild(bookCard(b)));
      const wrap=document.createElement('div'); wrap.appendChild(box); wrap.appendChild(sub); shelf.appendChild(wrap);
    });
    shelf.classList.remove('hidden');
  }
}
function bookCard(b){
  const c=document.createElement('div'); c.className='card';
  const th = b.coverDataUrl || (b.pages?.[0]?.dataUrl)||'';
  c.innerHTML=`<div class="thumb">${ th? `<img src="${th}" alt="thumb"/>` : '<div class="muted">No Image</div>'}</div>
    <div class="meta">
      <p class="title">${escapeHTML(b.title||'無題')}</p>
      <div class="row space">
        <span class="muted">${(b.tags||[]).slice(0,3).join(' ・ ')}</span>
        <span class="pill">${b.pages?.length||0}p</span>
      </div>
      <div class="row" style="gap:6px;margin-top:8px">
        <button class="btn small" data-open="${b.id}">開く</button>
        <button class="btn small ghost" data-edit="${b.id}">編集</button>
        <button class="btn small" data-dup="${b.id}">複製</button>
        <button class="btn small danger" data-del="${b.id}">削除</button>
      </div>
    </div>`;
  return c;
}

/** ===== Boxes (強化) ===== */
async function renderBoxes(){
  let boxes=await Box.list();
  const q=(document.getElementById('boxSearch').value||'').toLowerCase();
  const onlyWeak=document.getElementById('onlyWeakBox').checked;
  const sort=document.getElementById('boxSort').value;

  // enrich stats
  boxes.forEach(b=>{
    b.tags=b.tags||[];
    const weak=(b.snippets||[]).filter(s=>s.weak).length;
    b._weak=weak;
    b._items=(b.snippets||[]).length;
    b._thumb=b.coverDataUrl || b.snippets?.[0]?.dataUrl||'';
  });
  // filter
  if(q){
    boxes=boxes.filter(b=> (b.name||'').toLowerCase().includes(q)
      || b.tags.some(t=>t.toLowerCase().includes(q))
      || (b.snippets||[]).some(s=> (s.name||'').toLowerCase().includes(q) || (s.note||'').toLowerCase().includes(q)));
  }
  if(onlyWeak){ boxes=boxes.filter(b=> b._weak>0); }
  // sort
  boxes.sort((a,b)=>{
    if(sort==='name') return (a.name||'').localeCompare(b.name||'');
    if(sort==='-items') return (b._items)-(a._items);
    if(sort==='-weak') return (b._weak)-(a._weak);
    return (b.createdAt||0)-(a.createdAt||0);
  });

  const grid=document.getElementById('boxGrid');
  const empty=document.getElementById('boxEmpty');
  grid.innerHTML='';
  if(!boxes.length){empty.classList.remove('hidden');return}
  empty.classList.add('hidden');

  boxes.forEach(x=>{
    const c=document.createElement('div'); c.className='card';
    c.innerHTML=`<div class="thumb">${x._thumb? `<img src="${x._thumb}" alt="thumb"/>`:'<div class="muted">No Image</div>'}</div>
    <div class="meta">
      <p class="title">${escapeHTML(x.name||'無題ボックス')}</p>
      <div class="row space">
        <span class="muted">${x._items} 件 ・ 苦手 ${x._weak}</span>
        <div class="row" style="gap:6px">
          <button class="btn small" data-open-box="${x.id}">開く</button>
          <button class="btn small ghost" data-edit-box="${x.id}">編集</button>
          <button class="btn small danger" data-del-box="${x.id}">削除</button>
        </div>
      </div>
      <div class="row" style="gap:6px;margin-top:6px">${(x.tags||[]).map(t=>`<span class='chip'>${escapeHTML(t)}</span>`).join('')}</div>
    </div>`;
    grid.appendChild(c);
  });
}
function editBoxMeta(box){
  const m=document.createElement('div'); m.className='modal'; m.style.display='flex';
  const b=document.createElement('div'); b.className='box';
  b.innerHTML=`<h3>ボックスを編集</h3>
    <label>名前</label><input id="bxn" class="input" value="${escapeHTML(box.name||'')}" style="margin-bottom:8px"/>
    <label>タグ</label><input id="bxt" class="input" value="${escapeHTML((box.tags||[]).join(', '))}" style="margin-bottom:8px"/>
    <label>サムネイル（任意）</label>
    <div class="row" style="gap:8px;align-items:center;margin-bottom:8px">
      <input type="file" id="bxthumb" accept="image/*" />
      <div class="snip-preview" style="max-width:120px;min-width:90px;"><img id="bxthumbPreview" src="${box.coverDataUrl||box.snippets?.[0]?.dataUrl||''}" alt="thumb"/></div>
    </div>
    <div class="row space">
      <button class="btn ghost" data-close>閉じる</button>
      <div class="row" style="gap:8px">
        <button class="btn ghost" id="exportThisBox">このボックスをエクスポート</button>
        <button class="btn primary" data-save>保存</button>
      </div>
    </div>`;
  m.appendChild(b); document.body.appendChild(m);
  b.querySelector('[data-close]').onclick=()=>m.remove();
  const fileInput=b.querySelector('#bxthumb');
  const preview=b.querySelector('#bxthumbPreview');
  if(fileInput){
    fileInput.onchange=async()=>{
      const f=fileInput.files?.[0];
      if(!f){ return; }
      const url=await fileToDataURL(f);
      preview.src=url;
      box.coverDataUrl=url;
    };
  }
  b.querySelector('#exportThisBox').onclick=()=>exportSingleBox(box);
  b.querySelector('[data-save]').onclick=async()=>{
    box.name=b.querySelector('#bxn').value.trim()||'無題ボックス';
    box.tags=b.querySelector('#bxt').value.split(',').map(s=>s.trim()).filter(Boolean);
    await Box.put(box); m.remove(); renderBoxes(); showToast('更新しました','ok');
  };
}

/** ===== Viewer (Book) ===== */
function mountBookViewer(book){
  state.view='viewer';
  state.viewerContext='book';
  state.activeTab='library';
  viewerMemory.book.id=book.id;
  viewerMemory.book.closed=false;
  ensureOpenTab('book', book.id, book.title||'無題');
  const host=document.getElementById('viewerView'); host.innerHTML=''; host.classList.remove('hidden');
  // ensure library list is hidden while閲覧中
  const libraryEl=document.getElementById('libraryView');
  const boxesEl=document.getElementById('boxesView');
  libraryEl?.classList.add('hidden');
  boxesEl?.classList.add('hidden');
  document.body.classList.add('reading');
  if(typeof book.firstPageNumber!=='number') book.firstPageNumber=1;
  book.pages.forEach(p=>{
    p.state=p.state||{fav:false,weak:false,done:false,extra:[]};
    if(!Array.isArray(p.state.extra)) p.state.extra=[];
    p.memo=p.memo||'';
  });
  book.customStates = book.customStates || []; // {id,name,color}
  book.bookmarks = Array.isArray(book.bookmarks)?book.bookmarks:[];

  const wrap=document.createElement('div'); wrap.className='viewer';
  wrap.innerHTML=`
    <div id="stageHost" class="stage-host">
      <div class="stage-buttons left">
        <button class="mini-menu" id="stageMenuBtn" aria-label="メニュー">☰</button>
        <button class="mini-menu" id="zoomLockBtn" aria-label="ズームロック">🔒ズ</button>
        <button class="mini-menu" id="panLockBtn" aria-label="移動ロック">🔒移</button>
        <button class="mini-menu" id="sliceViewBtn" aria-label="ハーフ表示">半切</button>
        <button class="mini-menu" id="answerQuickBtn" aria-label="解答ウィンドウ">解答</button>
        <button class="mini-menu" id="selectQuickBtn" aria-label="切り取り">切取</button>
      </div>
      <div class="stage-buttons right">
        <button class="mini-menu" id="memoMiniBtn" aria-label="メモ">📝</button>
        <div class="page-badge" id="pageBadge"></div>
      </div>
      <!-- single pane (default) -->
      <div class="stage" id="stageSingle">
        <div class="stage-inner">
          <img id="pageImg" alt="page" draggable="false"/>
          <canvas id="cropCanvas" class="crop hidden"></canvas>
          <div class="interaction-hint" id="interactionHint">ホイール＝ズーム / ドラッグ＝移動</div>
          <div class="stage-arrows">
            <button class="stage-arrow" id="stagePrevArrow" aria-label="前のページ">‹</button>
            <button class="stage-arrow" id="stageNextArrow" aria-label="次のページ">›</button>
          </div>
      <div class="floatbar hidden" id="floatbar"></div>
        </div>
      </div>
      <!-- dual pane for spread/compare -->
      <div class="dual hidden" id="stageDual">
        <div class="pane" id="paneLeft">
          <img id="imgLeft" alt="left" draggable="false"/>
          <div class="pane-badge" id="badgeLeft"></div>
          <canvas class="crop hidden" id="cropCanvasLeft"></canvas>
          <div class="pane-arrows">
            <button class="pane-arrow" id="paneLeftPrevArrow" aria-label="左ページを戻す">‹</button>
            <button class="pane-arrow" id="paneLeftNextArrow" aria-label="左ページを進める">›</button>
          </div>
          <div class="pane-controls">
            <button class="btn small" id="leftPrev">←</button>
            <button class="btn small" id="leftNext">→</button>
            <input class="input" id="leftJump" placeholder="p" style="width:80px"/>
            <button class="btn small" id="leftGo">移動</button>
          </div>
        </div>
        <div class="pane-divider" id="paneDivider" role="separator" aria-orientation="vertical"></div>
        <div class="pane" id="paneRight">
          <img id="imgRight" alt="right" draggable="false"/>
          <div class="pane-badge" id="badgeRight"></div>
          <canvas class="crop hidden" id="cropCanvasRight"></canvas>
          <div class="pane-arrows">
            <button class="pane-arrow" id="paneRightPrevArrow" aria-label="右ページを戻す">‹</button>
            <button class="pane-arrow" id="paneRightNextArrow" aria-label="右ページを進める">›</button>
          </div>
          <div class="pane-controls">
            <button class="btn small" id="rightPrev">←</button>
            <button class="btn small" id="rightNext">→</button>
            <input class="input" id="rightJump" placeholder="p" style="width:80px"/>
            <button class="btn small" id="rightGo">移動</button>
          </div>
        </div>
      </div>
    </div>
    <div class="book-menu compact" id="bookMenuPanel">
      <div class="menu-header" id="menuDragHandle">
        <span></span>
        <button id="menuCloseBtn" aria-label="閉じる">×</button>
      </div>
      <div class="menu-body">
        <div class="menu-actions" id="menuActions"></div>
      </div>
    </div>
    <div class="memo-window" id="memoWindow">
      <div class="memo-header" id="memoWindowDrag">
        <span>ページメモ</span>
        <button id="memoWindowClose" aria-label="閉じる">×</button>
      </div>
      <textarea id="memoWindowInput" placeholder="このページのメモ"></textarea>
    </div>
    <div class="compare-window" id="compareWindow">
      <div class="compare-header" id="compareWindowDrag">
        <span class="compare-title" id="compareWindowTitle">比較ウィンドウ</span>
        <div class="compare-quick">
          <button class="mini-menu" id="compareWindowZoomLock" aria-label="ズームロック">🔓ズ</button>
          <button class="mini-menu" id="compareWindowPanLock" aria-label="移動ロック">🔓移</button>
          <button class="mini-menu" id="compareWindowSelect">本を選択</button>
          <button class="mini-menu" id="compareWindowSync" aria-label="透明切替">透明</button>
          <button class="mini-menu" id="compareWindowClose" aria-label="閉じる">×</button>
        </div>
      </div>
      <div class="compare-body">
        <div class="compare-stage" id="compareWindowStage">
          <span class="compare-placeholder" id="compareWindowPlaceholder">ここに比較ページが表示されます</span>
          <img id="compareWindowImg" alt="比較ウィンドウ" draggable="false"/>
          <canvas class="crop hidden" id="cropCanvasCompareWindow"></canvas>
        </div>
        <div class="compare-controls">
          <button class="btn small" id="compareWindowPrev">←</button>
          <button class="btn small" id="compareWindowNext">→</button>
          <input class="input" id="compareWindowJump" placeholder="ページ" style="width:70px"/>
                  <button class="btn small" id="compareWindowGo">移動</button>
          <span class="compare-meta" id="compareWindowMeta">本が選択されていません</span>
        </div>
      </div>
    </div>
    <div class="control-resizer" id="controlResizer" role="separator" aria-label="右パネル幅を変更"></div>
    <div class="control">
      <div class="row space">
        <div>
          <h3 style="margin:0">${escapeHTML(book.title||'無題')}</h3>
          <span class="muted">${book.pages.length}p ・ 開始 ${book.firstPageNumber||1}p</span>
        </div>
        <div class="row" style="gap:6px">
          <button class="btn small ghost" id="bookMenuBtn">☰ メニュー</button>
        </div>
      </div>
      <div class="statebar">
        <label class="row" style="gap:6px"><input type="checkbox" id="stFav"> ★お気に入り</label>
        <label class="row" style="gap:6px"><input type="checkbox" id="stWeak"> ×苦手</label>
        <label class="row" style="gap:6px"><input type="checkbox" id="stDone"> ✓完了</label>
        <div id="customStateArea" class="row" style="gap:6px;flex-wrap:wrap"></div>
        <button class="btn small ghost" id="addState">+ 状態を作成</button>
      </div>
      <div class="memo-panel">
        <button class="btn small ghost" id="memoToggle">メモ欄を開く</button>
        <div class="memo-body hidden" id="memoBody">
          <textarea id="pageMemo" class="input" placeholder="このページのメモ"></textarea>
        </div>
      </div>
      <div class="toolbar" style="margin:8px 0">
        <select id="filterSelect" class="input" style="max-width:180px">
          <option value="all">すべて表示</option>
          <option value="fav">★のみ</option>
          <option value="weak">×のみ</option>
          <option value="undone">未完了のみ</option>
          <option value="done">完了のみ</option>
          <option value="hasMemo">メモありのみ</option>
        </select>
        <select id="customFilter" class="input" style="max-width:180px">
          <option value="">カスタム状態（任意）</option>
        </select>
        <button class="btn" id="prevBtn">← 前へ</button>
        <button class="btn" id="nextBtn">次へ →</button>
        <input class="input" id="jumpInput" placeholder="ページ番号" style="width:120px"/>
        <button class="btn" id="jumpGo">移動</button>
        <button class="btn ghost" id="fitContain">フィット</button>
        <button class="btn ghost" id="fitWidth">幅フィット</button>
        <button class="btn" id="spreadToggle">見開き 1↔2</button>
        <button class="btn ghost" id="compareStart">比較</button>
        <button class="btn danger hidden" id="compareEnd">比較終了</button>
        <button class="btn ghost hidden" id="compareHideBtn">右側隠す</button>
        <button class="btn ghost" id="compareWindowBtn">比較ウィンドウ</button>
        <button class="btn" id="selectBtn">切り取り</button>
        <button class="btn ghost" id="insertBtn">+ 挿入</button>
      </div>
      <div class="linked-answer-bar hidden" id="linkedAnswerBar">
        <div class="linked-answer-chips" id="linkedAnswerQuick"></div>
        <div class="row" id="linkedAnswerActions" style="gap:6px;flex-wrap:wrap;margin-top:6px">
          <button class="btn small" id="linkedAnswerCompareBtn">解答↔</button>
          <button class="btn small ghost" id="linkedAnswerWindowBtn">解答ウィンドウ</button>
        </div>
      </div>
      <div class="linked-answer-manage" id="answerLinkManage">
        <select class="input" id="answerLinkSelect"></select>
        <button class="btn small" id="answerLinkAdd">+ 紐付け</button>
      </div>
      <div class="toolbar" style="margin-bottom:6px;flex-wrap:wrap">
        <button class="btn small" id="multiToggle">□ 複数選択</button>
        <button class="btn small ghost" id="multiAll">すべて選択</button>
        <button class="btn small ghost" id="multiNone">選択解除</button>
        <button class="btn small" id="multiMove">選択を移動</button>
        <button class="btn small" id="multiCopy">選択をコピー</button>
        <button class="btn small" id="multiNewBook">選択から新しい本</button>
        <button class="btn small danger" id="multiDelete">選択を削除</button>
        <button class="btn small" id="multiSet">選択の状態を変更</button>
      </div>
      <div class="toolbar" style="align-items:center">
        <span class="muted">めくりまくり</span>
        <input type="range" id="flipSpeed" min="1" max="20" value="8" />
        <button class="btn" id="flipPlay">▶︎ 再生</button>
        <button class="btn ghost" id="flipStop">停止</button>
        <input type="range" id="scrubRange" min="1" max="${book.pages.length}" value="1" style="flex:1" />
      </div>
      <div class="hr" style="height:1px;background:#1d2738;margin:8px 0"></div>
      <div class="list" id="thumbList" style="flex:1"></div>
      <div class="hr" style="height:1px;background:#1d2738;margin:8px 0"></div>
      <div class="row space">
        <button class="btn ghost" id="backLib">← ライブラリに戻る</button>
        <div class="muted">実ページ起点: <span id="realStart">${book.firstPageNumber}</span></div>
      </div>
    </div>`;
  host.appendChild(wrap);

  const img=document.getElementById('pageImg');
  const cropSingle=document.getElementById('cropCanvas');
  const cropLeft=document.getElementById('cropCanvasLeft');
  const cropRight=document.getElementById('cropCanvasRight');
  const cropCompareWindow=document.getElementById('cropCanvasCompareWindow');
  const stageHost=document.getElementById('stageHost');
  const stage=document.getElementById('stageSingle');
  const stageDual=document.getElementById('stageDual');
  const controlResizer=document.getElementById('controlResizer');
  const stagePrevArrow=document.getElementById('stagePrevArrow');
  const stageNextArrow=document.getElementById('stageNextArrow');
  const paneLeftPrevArrow=document.getElementById('paneLeftPrevArrow');
  const paneLeftNextArrow=document.getElementById('paneLeftNextArrow');
  const paneRightPrevArrow=document.getElementById('paneRightPrevArrow');
  const paneRightNextArrow=document.getElementById('paneRightNextArrow');
  const stageMenuBtn=document.getElementById('stageMenuBtn');
  const zoomLockBtn=document.getElementById('zoomLockBtn');
  const panLockBtn=document.getElementById('panLockBtn');
  const sliceViewBtn=document.getElementById('sliceViewBtn');
  const memoMiniBtn=document.getElementById('memoMiniBtn');
  const interactionHint=document.getElementById('interactionHint');
  const pageBadge=document.getElementById('pageBadge');
  const floatbar=document.getElementById('floatbar');
  const scrub=document.getElementById('scrubRange');
  const memoEl=document.getElementById('pageMemo');
  const memoToggle=document.getElementById('memoToggle');
  const memoBody=document.getElementById('memoBody');
  const stFav=document.getElementById('stFav');
  const stWeak=document.getElementById('stWeak');
  const stDone=document.getElementById('stDone');
  const customArea=document.getElementById('customStateArea');
  const customFilter=document.getElementById('customFilter');
  const bookMenuBtn=document.getElementById('bookMenuBtn');
  const bookMenuPanel=document.getElementById('bookMenuPanel');
  const menuDragHandle=document.getElementById('menuDragHandle');
  const menuCloseBtn=document.getElementById('menuCloseBtn');
  compareHideBtn=document.getElementById('compareHideBtn');
  const paneLeft=document.getElementById('paneLeft');
  const paneRight=document.getElementById('paneRight');
  const imgLeft=document.getElementById('imgLeft');
  const imgRight=document.getElementById('imgRight');
  const paneDivider=document.getElementById('paneDivider');
  const compareWindow=document.getElementById('compareWindow');
  const compareWindowTitle=document.getElementById('compareWindowTitle');
  const compareWindowMeta=document.getElementById('compareWindowMeta');
  const compareWindowImg=document.getElementById('compareWindowImg');
  const compareWindowStage=document.getElementById('compareWindowStage');
  const compareWindowPlaceholder=document.getElementById('compareWindowPlaceholder');
  const compareWindowPrev=document.getElementById('compareWindowPrev');
  const compareWindowNext=document.getElementById('compareWindowNext');
  const compareWindowGo=document.getElementById('compareWindowGo');
  const compareWindowJump=document.getElementById('compareWindowJump');
  const compareWindowClose=document.getElementById('compareWindowClose');
  const compareWindowDrag=document.getElementById('compareWindowDrag');
  const compareWindowBtn=document.getElementById('compareWindowBtn');
  const compareWindowSelect=document.getElementById('compareWindowSelect');
  const compareWindowSync=document.getElementById('compareWindowSync');
  const compareWindowZoomLock=document.getElementById('compareWindowZoomLock');
  const compareWindowPanLock=document.getElementById('compareWindowPanLock');
  const answerQuickBtn=document.getElementById('answerQuickBtn');
  const selectQuickBtn=document.getElementById('selectQuickBtn');
  const memoWindow=document.getElementById('memoWindow');
  const memoWindowInput=document.getElementById('memoWindowInput');
  const memoWindowClose=document.getElementById('memoWindowClose');
  const memoWindowDrag=document.getElementById('memoWindowDrag');
  const snippetPreview=document.getElementById('snippetPreviewImg');
  const snippetSourceHint=document.getElementById('snippetSourceHint');
  const snippetAnswerHint=document.getElementById('snippetAnswerHint');
  const linkedAnswerBar=document.getElementById('linkedAnswerBar');
  const linkedAnswerQuick=document.getElementById('linkedAnswerQuick');
  const linkedAnswerActions=document.getElementById('linkedAnswerActions');
  const linkedAnswerCompareBtn=document.getElementById('linkedAnswerCompareBtn');
  const linkedAnswerWindowBtn=document.getElementById('linkedAnswerWindowBtn');
  const answerLinkSelect=document.getElementById('answerLinkSelect');
  const answerLinkAdd=document.getElementById('answerLinkAdd');
  const selectionSurfaces={
    single:{key:'single',container:stage,img:img,canvas:cropSingle},
    left:{key:'left',container:paneLeft,img:imgLeft,canvas:cropLeft},
    right:{key:'right',container:paneRight,img:imgRight,canvas:cropRight},
    compareWindow:{key:'compareWindow',container:compareWindowStage,img:compareWindowImg,canvas:cropCompareWindow}
  };
  const VIEWER_STATE_KEYS={
    zoomLock:'viewer-zoom-lock',
    panLock:'viewer-pan-lock',
    sliceView:'viewer-slice-view'
  };
  const COMPARE_STATE_KEYS={
    zoomLock:'compare-window-zoom-lock',
    panLock:'compare-window-pan-lock'
  };
  let page=0, selecting=false, dragging=false, startX=0, startY=0, rectImg=null, rectContainer=null, boxRect=null;
  let activeSelectionSurface=selectionSurfaces.single;
  let selectionMeta=null;
  let pendingSelectionMeta=null;
  let pendingAnswerCrop=null;
  // spread/compare state
  let mode = 'single'; // 'single' | 'spread' | 'compare'
  let rightBook = null;
  let leftIndex = 0; // for dual views we use leftIndex always equals current 'page'
  let rightIndex = 1; // spread: right = left+1 ; compare: right book index
  let compareWindowBook = null;
  let compareWindowIndex = 0;
  let compareWindowOpen = false;
  let compareWindowMinimized = false;
  let compareWindowTransparent = loadStoredBool('viewer-compare-window-transparent', false);
  let compareWindowPos = loadStoredJSON('viewer-compare-window-pos');
  let compareZoom = 1;
  let comparePan = {x:0,y:0};
  let compareNeedsReset = true;
  let compareZoomLocked = loadStoredBool(COMPARE_STATE_KEYS.zoomLock,false);
  let comparePanLocked = loadStoredBool(COMPARE_STATE_KEYS.panLock,false);
  const COMPARE_ZOOM_MIN=0.4;
  const COMPARE_ZOOM_MAX=6;
  let controlWidth = parseFloat(localStorage.getItem('viewer-control-width')||'340')||340;
  book.answerBookIds = Array.from(new Set(Array.isArray(book.answerBookIds)?book.answerBookIds.filter(id=>id && id!==book.id):[]));
  if(book.pages?.length){
    const savedPage=getLastPageIndex(book.id);
    if(typeof savedPage==='number'){
      page=clamp(savedPage,0,book.pages.length-1);
    }
  }
  function compareStageAnchorFromClient(clientX, clientY){
    return anchorFromElement(compareWindowStage, clientX, clientY);
  }
  function setCompareZoom(next,{anchor=null}={}){
    const prev=compareZoom||1;
    const target=clamp(next, COMPARE_ZOOM_MIN, COMPARE_ZOOM_MAX);
    const pivot=anchor||{x:0,y:0};
    if(prev!==target){
      comparePan.x = pivot.x - (target/prev)*(pivot.x - comparePan.x);
      comparePan.y = pivot.y - (target/prev)*(pivot.y - comparePan.y);
    }
    compareZoom=target;
    applyCompareTransform();
  }
  function applyCompareTransform(){
    if(compareWindowImg){
      compareWindowImg.style.transform=`translate(${comparePan.x}px,${comparePan.y}px) scale(${compareZoom})`;
    }
  }
  function resetCompareView(){
    compareZoom=1;
    comparePan={x:0,y:0};
    applyCompareTransform();
  }
  function requestCompareViewReset(){
    compareNeedsReset=true;
  }
  function updateCompareLockButtons(){
    if(compareWindowZoomLock){
      compareWindowZoomLock.classList.toggle('active', compareZoomLocked);
      compareWindowZoomLock.textContent = compareZoomLocked ? '🔒ズ' : '🔓ズ';
      compareWindowZoomLock.setAttribute('aria-pressed', compareZoomLocked?'true':'false');
    }
    if(compareWindowPanLock){
      compareWindowPanLock.classList.toggle('active', comparePanLocked);
      compareWindowPanLock.textContent = comparePanLocked ? '🔒移' : '🔓移';
      compareWindowPanLock.setAttribute('aria-pressed', comparePanLocked?'true':'false');
    }
    if(compareWindowStage){
      compareWindowStage.classList.toggle('pan-disabled', comparePanLocked);
    }
  }
  function setCompareZoomLock(next){
    compareZoomLocked=next;
    saveStoredBool(COMPARE_STATE_KEYS.zoomLock, compareZoomLocked);
    compareStageSurface?.cancel?.();
    updateCompareLockButtons();
  }
  function setComparePanLock(next){
    comparePanLocked=next;
    saveStoredBool(COMPARE_STATE_KEYS.panLock, comparePanLocked);
    if(comparePanLocked){
      compareStageSurface?.cancel?.();
    }
    updateCompareLockButtons();
  }
  function updateCompareDockUI(){
    if(compareWindow){
      compareWindow.classList.remove('minimized');
    }
  }
  function rememberCompareWindowPosition(){
    const viewerRect=wrap.getBoundingClientRect();
    const rect=compareWindow?.getBoundingClientRect();
    if(!rect || !compareWindow) return;
    const clamped=clampPanelPosition(compareWindow, rect.left-viewerRect.left, rect.top-viewerRect.top);
    compareWindowPos=clamped;
    saveStoredJSON('viewer-compare-window-pos', compareWindowPos);
  }
  function applyCompareWindowPosition(pos){
    if(!compareWindow || !pos || Number.isNaN(pos.left) || Number.isNaN(pos.top)) return;
    const clamped=clampPanelPosition(compareWindow, pos.left, pos.top);
    compareWindow.style.left=`${clamped.left}px`;
    compareWindow.style.top=`${clamped.top}px`;
    compareWindowPos=clamped;
    saveStoredJSON('viewer-compare-window-pos', compareWindowPos);
  }
  function setCompareWindowMinimized(next){
    compareWindowMinimized=false;
    if(compareWindowOpen){
      if(compareWindowPos){
        applyCompareWindowPosition(compareWindowPos);
      }else{
        ensureCompareWindowPosition();
      }
    }
    updateCompareDockUI();
  }
  function setCompareWindowTransparent(next){
    compareWindowTransparent=!!next;
    saveStoredBool('viewer-compare-window-transparent', compareWindowTransparent);
    updateCompareWindowUI(true);
  }
  let compareModalTarget = 'split'; // 'split' | 'window'

  let filter='all', customFilterId='';
  let flipTimer=null;
  let multi=false; const selected=new Set();
  const BASE_MIN_ZOOM=0.4;
  const BASE_MAX_ZOOM=6;
  const viewState={zoom:1,minZoom:BASE_MIN_ZOOM,maxZoom:BASE_MAX_ZOOM,translateX:0,translateY:0,userAdjusted:false};
  let zoomLocked=loadStoredBool(VIEWER_STATE_KEYS.zoomLock,false);
  let panLocked=loadStoredBool(VIEWER_STATE_KEYS.panLock,false);
  let sliceMode=loadStoredBool(VIEWER_STATE_KEYS.sliceView,false);
  let panMoved=false;
  let hintTimer=null;
  let stagePanning=false;
  let answerLinkBookCache=[];
  const PANE_SPLIT_KEY='viewer-pane-split';
  let splitRatio=parseFloat(localStorage.getItem(PANE_SPLIT_KEY));
  if(isNaN(splitRatio)) splitRatio=0.5;
  splitRatio=Math.min(0.8, Math.max(0.2, splitRatio));
  const computeMinZoomForClamp=()=>{
    if(!keyNavConfig.bookClamp) return BASE_MIN_ZOOM;
    const stageRect=stage?.getBoundingClientRect?.();
    const baseW=img?.clientWidth||img?.naturalWidth||0;
    const baseH=img?.clientHeight||img?.naturalHeight||0;
    if(!stageRect || !baseW || !baseH) return BASE_MIN_ZOOM;
    const fitZoom=Math.max(stageRect.width/(baseW||1), stageRect.height/(baseH||1));
    return Math.max(BASE_MIN_ZOOM, fitZoom);
  };
  const refreshZoomBounds=()=>{
    const minZoom=computeMinZoomForClamp();
    viewState.minZoom=minZoom;
    viewState.maxZoom=Math.max(BASE_MAX_ZOOM, minZoom);
    if(viewState.zoom<minZoom){
      viewState.zoom=minZoom;
    }
  };
  if(img){
    img.onload=()=>{
      resetViewState({keepAdjusted:false});
    };
  }
  function primaryAnswerId(){
    const links=book.answerBookIds||[];
    return links.length?links[0]:null;
  }
  function triggerPrimaryAnswer(mode){
    const id=primaryAnswerId();
    if(!id) return;
    if(mode==='window'){ openLinkedAnswerInWindow(id); }
    else{ startLinkedCompare(id); }
  }
  // expose for quick-menu helpers
  window.primaryAnswerId = primaryAnswerId;
  window.triggerPrimaryAnswer = triggerPrimaryAnswer;
  memoToggle?.addEventListener('click',()=>{
    if(!memoBody) return;
    const nowHidden=memoBody.classList.toggle('hidden');
    memoToggle.textContent=nowHidden?'メモ欄を開く':'メモ欄を閉じる';
    updateQuickActionButtons();
  });
  stageMenuBtn?.addEventListener('click',(e)=>{
    e.stopPropagation();
    setMenu(true);
  });
  memoMiniBtn?.addEventListener('click',(e)=>{
    e.stopPropagation();
    setMemoWindow(!memoWindowOpen);
  });
  answerLinkAdd?.addEventListener('click',async()=>{
    if(!answerLinkSelect) return;
    const targetId=answerLinkSelect.value;
    if(!targetId){
      showToast('解答を選択してください','error');
      return;
    }
    if(book.answerBookIds.includes(targetId)){
      showToast('既に紐付け済みです');
      return;
    }
    book.answerBookIds.push(targetId);
    await Book.put(book);
    answerLinkSelect.value='';
    await refreshAnswerLinkUI();
    refresh();
    showToast('解答を紐付けました','ok');
  });
  linkedAnswerQuick?.addEventListener('click',async(e)=>{
    const actionBtn=e.target.closest('button');
    if(!actionBtn) return;
    const chip=actionBtn.closest('.answer-chip');
    if(!chip) return;
    const targetId=chip.dataset.answer;
    if(!targetId) return;
    const action=actionBtn.dataset.action;
    if(action==='window'){
      await openLinkedAnswerInWindow(targetId);
      return;
    }
    if(action==='remove'){
      book.answerBookIds=book.answerBookIds.filter(id=>id!==targetId);
      await Book.put(book);
      await refreshAnswerLinkUI();
      refresh();
      showToast('紐付けを解除しました','ok');
      return;
    }
    await startLinkedCompare(targetId);
  });
  linkedAnswerCompareBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); triggerPrimaryAnswer('compare'); });
  linkedAnswerWindowBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); triggerPrimaryAnswer('window'); });
  function updateLockButtons(){
    if(zoomLockBtn){
      zoomLockBtn.classList.toggle('active', zoomLocked);
      zoomLockBtn.textContent = zoomLocked ? '🔒ズ' : '🔓ズ';
      zoomLockBtn.setAttribute('aria-pressed', zoomLocked?'true':'false');
    }
    if(panLockBtn){
      panLockBtn.classList.toggle('active', panLocked);
      panLockBtn.textContent = panLocked ? '🔒移' : '🔓移';
      panLockBtn.setAttribute('aria-pressed', panLocked?'true':'false');
    }
    if(sliceViewBtn){
      sliceViewBtn.classList.toggle('active', sliceMode);
      sliceViewBtn.setAttribute('aria-pressed', sliceMode?'true':'false');
    }
    updateQuickActionButtons();
  }
  function applySliceViewState(){
    stageHost?.classList.toggle('slice-view', sliceMode);
    if(sliceViewBtn){
      sliceViewBtn.textContent = sliceMode ? '半切✓' : '半切';
    }
  }
  function setZoomLock(next){
    zoomLocked=next;
    saveStoredBool(VIEWER_STATE_KEYS.zoomLock, zoomLocked);
    stageSurface?.cancel?.();
    stopInertia();
    paneControllers.forEach(ctrl=>ctrl.cancelInteractions?.());
    updateLockButtons();
    updateHintText();
    if(mode==='single') showInteractionHint();
  }
  function setPanLock(next){
    panLocked=next;
    saveStoredBool(VIEWER_STATE_KEYS.panLock, panLocked);
    if(panLocked){
      stageSurface?.cancel?.();
      paneControllers.forEach(ctrl=>ctrl.cancelInteractions?.());
      stopInertia();
    }
    stage?.classList.toggle('pan-disabled', mode!=='single' || panLocked);
    updateLockButtons();
    updateHintText();
  }
  function setSliceView(next){
    sliceMode=next;
    saveStoredBool(VIEWER_STATE_KEYS.sliceView, sliceMode);
    updateLockButtons();
    applySliceViewState();
  }
  async function getBooksForLinking(force=false){
    if(!force && Array.isArray(window.__allBooksCache) && window.__allBooksCache.length){
      return window.__allBooksCache;
    }
    const books=await Book.list();
    window.__allBooksCache=books;
    return books;
  }
  function renderAnswerLinkSelect(allBooks){
    if(!answerLinkSelect) return;
    const links=book.answerBookIds||[];
    const candidates=allBooks.filter(b=>b.id!==book.id && !links.includes(b.id)).sort((a,b)=>(a.title||'').localeCompare(b.title||''));
    answerLinkSelect.innerHTML='';
    if(!candidates.length){
      const opt=document.createElement('option');
      opt.value='';
      opt.textContent='追加できる本がありません';
      answerLinkSelect.appendChild(opt);
      answerLinkSelect.disabled=true;
      if(answerLinkAdd) answerLinkAdd.disabled=true;
      return;
    }
    answerLinkSelect.disabled=false;
    if(answerLinkAdd) answerLinkAdd.disabled=false;
    const placeholder=document.createElement('option');
    placeholder.value='';
    placeholder.textContent='解答を選択';
    answerLinkSelect.appendChild(placeholder);
    candidates.forEach(b=>{
      const opt=document.createElement('option');
      opt.value=b.id;
      opt.textContent=`${b.title||'無題'} (${b.pages?.length||0}p)`;
      answerLinkSelect.appendChild(opt);
    });
  }
  function updateLinkedAnswerChips(allBooks){
    if(!linkedAnswerBar || !linkedAnswerQuick) return;
    linkedAnswerQuick.innerHTML='';
    const links=book.answerBookIds||[];
    const hasLinks = links.length>0;
    linkedAnswerBar.classList.toggle('hidden', !hasLinks);
    if(linkedAnswerActions){
      linkedAnswerActions.classList.toggle('hidden', !hasLinks);
    }
    if(!hasLinks){ updateQuickActionButtons(); return; }
    links.forEach(id=>{
      const target=allBooks.find(b=>b.id===id);
      const title=target?.title || '（見つかりません）';
      const chip=document.createElement('div');
      chip.className='answer-chip';
      chip.dataset.answer=id;
      chip.innerHTML=`<strong>${escapeHTML(title)}</strong>
        <button type="button" data-action="split" title="並べて比較">↔</button>
        <button type="button" data-action="window" title="解答ウィンドウ">🗔</button>
        <button type="button" data-action="remove" title="紐付け解除">×</button>`;
      linkedAnswerQuick.appendChild(chip);
    });
    updateQuickActionButtons();
  }
  async function refreshAnswerLinkUI(force=false){
    if(!answerLinkSelect && !linkedAnswerBar) return;
    const books=await getBooksForLinking(force);
    answerLinkBookCache=books;
    renderAnswerLinkSelect(books);
    updateLinkedAnswerChips(books);
  }
  function getCompareStartIndexFor(targetBook){
    if(!targetBook?.pages?.length) return 0;
    const saved=getLastCompareIndex(book.id, targetBook.id);
    if(typeof saved==='number' && !Number.isNaN(saved)){
      return clamp(saved,0,targetBook.pages.length-1);
    }
    return idxFromRealForBook(targetBook, realOf(page));
  }
  async function startLinkedCompare(targetId){
    if(!targetId) return;
    if(mode==='compare' && rightBook?.id===targetId){
      exitCompareMode({toast:true});
      return;
    }
    let target=answerLinkBookCache.find(b=>b.id===targetId);
    if(!target){
      target=await Book.get(targetId);
    }
    if(!target){
      showToast('解答が見つかりません','error');
      return;
    }
    if(!target.pages?.length){
      showToast('ページがありません','error');
      return;
    }
    rightBook=target;
    rightIndex=getCompareStartIndexFor(target);
    mode='compare';
    compareEnd?.classList.remove('hidden');
    compareStart?.classList.add('hidden');
    compareRightHidden=false;
    pendingAnswerCrop=null;
    selecting=false;
    syncSelectingUI();
    load();
    showToast(`${target.title||'解答'} と比較を開始`, 'ok');
  }
  async function openLinkedAnswerInWindow(targetId){
    if(!targetId) return;
    if(compareWindowBook?.id===targetId){
      if(compareWindowOpen){
        setCompareWindowOpen(false);
        showToast('解答ウィンドウを一時的に閉じました','ok');
        return;
      }
      setCompareWindowMinimized(false);
      setCompareWindowOpen(true);
      showToast('解答ウィンドウを表示しました','ok');
      return;
    }
    let target=answerLinkBookCache.find(b=>b.id===targetId);
    if(!target){
      target=await Book.get(targetId);
    }
    if(!target){
      showToast('解答が見つかりません','error');
      return;
    }
    if(!target.pages?.length){
      showToast('ページがありません','error');
      return;
    }
    setCompareWindowBook(target);
    setCompareWindowMinimized(false);
    setCompareWindowOpen(true);
  }
  updateLockButtons();
  applySliceViewState();
  refreshAnswerLinkUI(true);
  zoomLockBtn?.addEventListener('click',(e)=>{
    e.stopPropagation();
    setZoomLock(!zoomLocked);
  });
  panLockBtn?.addEventListener('click',(e)=>{
    e.stopPropagation();
    setPanLock(!panLocked);
  });
  sliceViewBtn?.addEventListener('click',(e)=>{
    e.stopPropagation();
    setSliceView(!sliceMode);
  });
  answerQuickBtn?.addEventListener('click',(e)=>{
    e.stopPropagation();
    const pid=primaryAnswerId();
    if(!pid){
      showToast('紐付け解答がありません','error');
      return;
    }
    openLinkedAnswerInWindow(pid);
  });
  selectQuickBtn?.addEventListener('click',(e)=>{
    e.stopPropagation();
    toggleSelect();
  });
  function syncMemoFields(value, source){
    if(memoEl && source!=='main') memoEl.value=value;
    if(memoWindowInput && source!=='window') memoWindowInput.value=value;
  }
  async function commitMemo(value){
    book.pages[page].memo=value;
    await Book.put(book);
    updateThumbs();
  }
  memoEl?.addEventListener('input',()=>{ syncMemoFields(memoEl.value,'main'); });
  memoEl?.addEventListener('change',()=>commitMemo(memoEl.value));
  memoWindowInput?.addEventListener('input',()=>{ syncMemoFields(memoWindowInput.value,'window'); });
  memoWindowInput?.addEventListener('change',()=>commitMemo(memoWindowInput.value));
  let menuOpen=false;
  let memoWindowOpen=false;
  const bodyObserver=new MutationObserver(()=>updateFloatbarVisibility());
  bodyObserver.observe(document.body,{attributes:true,attributeFilter:['class']});
  function updateFloatbarVisibility(){
    if(!floatbar) return;
    const shouldShow = document.body.classList.contains('mainmode2');
    floatbar.classList.toggle('hidden', !shouldShow);
  }
  function clampPanelPosition(panel,left,top){
    const viewerRect=wrap.getBoundingClientRect();
    const panelRect=panel.getBoundingClientRect();
    const width=panelRect.width||panel.offsetWidth||320;
    const height=panelRect.height||panel.offsetHeight||220;
    const barRect=document.querySelector('.topbar')?.getBoundingClientRect();
    const minTop=Math.max(0,(barRect?.bottom ?? 0) - viewerRect.top + 8);
    const minLeft=-width*0.2;
    const maxLeft=viewerRect.width - width*0.2;
    const maxTop=viewerRect.height - height*0.2;
    return {
      left:Math.max(minLeft, Math.min(left, maxLeft)),
      top:Math.max(minTop, Math.min(top, maxTop))
    };
  }
  function makeDraggable(panel, handle, {onMove}={}){
    if(!panel || !handle) return;
    let dragging=false;
    let offsetX=0, offsetY=0;
    const move=(clientX,clientY)=>{
      if(!dragging) return;
      const viewerRect=wrap.getBoundingClientRect();
      let left=clientX - offsetX - viewerRect.left;
      let top=clientY - offsetY - viewerRect.top;
      const clamped=clampPanelPosition(panel,left,top);
      panel.style.left=`${clamped.left}px`;
      panel.style.top=`${clamped.top}px`;
      onMove?.(clamped.left, clamped.top);
    };
    const end=()=>{
      if(!dragging) return;
      dragging=false;
      panel.classList.remove('dragging');
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      document.removeEventListener('touchmove', onTouchMove);
      document.removeEventListener('touchend', onTouchEnd);
    };
    const start=(clientX,clientY)=>{
      const rect=panel.getBoundingClientRect();
      offsetX=clientX-rect.left;
      offsetY=clientY-rect.top;
      dragging=true;
      panel.classList.add('dragging');
    };
    const onMouseMove=(e)=>move(e.clientX,e.clientY);
    const onMouseUp=()=>end();
    const onTouchMove=(e)=>{ const {x,y}=pointerClientXY(e); move(x,y); e.preventDefault(); };
    const onTouchEnd=()=>end();
    handle.addEventListener('mousedown',(e)=>{
      if(e.button!==0) return;
      if(e.target.closest('button, input, select, textarea')) return;
      e.preventDefault();
      start(e.clientX,e.clientY);
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
    handle.addEventListener('touchstart',(e)=>{
      if(e.target.closest('button, input, select, textarea')) return;
      const {x,y}=pointerClientXY(e);
      start(x,y);
      e.preventDefault();
      document.addEventListener('touchmove', onTouchMove,{passive:false});
      document.addEventListener('touchend', onTouchEnd);
    },{passive:false});
  }
  makeDraggable(bookMenuPanel, menuDragHandle);
  makeDraggable(memoWindow, memoWindowDrag);
  makeDraggable(compareWindow, compareWindowDrag,{
    onMove:(left,top)=>{
      compareWindowPos={left,top};
      saveStoredJSON('viewer-compare-window-pos', compareWindowPos);
    }
  });
  if(compareWindowImg){
    compareWindowImg.addEventListener('load',()=>{
      if(compareNeedsReset){
        resetCompareView();
        compareNeedsReset=false;
      }else{
        applyCompareTransform();
      }
    });
    if(compareWindowImg.complete && compareWindowImg.naturalWidth){
      resetCompareView();
      compareNeedsReset=false;
    }
  }
  let compareStageSurface=null;
  if(compareWindowStage){
    const canUseCompareStage=()=>compareWindowOpen && !!compareWindowBook && !!compareWindowImg?.src;
    compareStageSurface = createPanZoomSurface({
      element:compareWindowStage,
      anchorFromClient:compareStageAnchorFromClient,
      getEnabled:()=>canUseCompareStage(),
      getZoom:()=>compareZoom,
      setZoom:(next,{anchor}={})=>setCompareZoom(next,{anchor}),
      getZoomLocked:()=>compareZoomLocked,
      getPanLocked:()=>comparePanLocked || selecting,
      applyPanDelta:(dx,dy)=>{
        comparePan.x+=dx;
        comparePan.y+=dy;
        applyCompareTransform();
      },
      onPanStart:()=>{ compareWindowStage.classList.add('grabbing'); },
      onPanEnd:()=>{ compareWindowStage.classList.remove('grabbing'); },
      onReset:()=>{ resetCompareView(); compareNeedsReset=false; },
      doubleTapResetEnabled:false,
      shouldIgnoreTarget:(target)=> target.closest('.compare-quick') || target.closest('.compare-controls')
    });
    const ignoreTarget=(target)=> target.closest('.compare-quick') || target.closest('.compare-controls');
    compareWindowStage.addEventListener('mousedown',(e)=>{
      if(!selecting) return;
      if(pendingAnswerCrop && pendingAnswerCrop.surfaceKey!=='compareWindow') return;
      if(ignoreTarget(e.target)) return;
      e.preventDefault();
      startDrag(e, selectionSurfaces.compareWindow);
    });
    compareWindowStage.addEventListener('touchstart',(e)=>{
      if(!selecting) return;
      if(pendingAnswerCrop && pendingAnswerCrop.surfaceKey!=='compareWindow') return;
      if(ignoreTarget(e.target)) return;
      if(e.touches.length===1){
        e.preventDefault();
        startDrag(e, selectionSurfaces.compareWindow);
      }
    },{passive:false});
    compareWindowStage.addEventListener('touchmove',(e)=>{
      if(!selecting) return;
      e.preventDefault();
      moveDrag(e);
    },{passive:false});
    compareWindowStage.addEventListener('touchend',(e)=>{
      if(!selecting) return;
      e.preventDefault();
      endDrag(e);
    },{passive:false});
  }
  updateCompareLockButtons();
  updateCompareDockUI();
  function setMenu(open){
    if(!bookMenuPanel) return;
    menuOpen=open;
    bookMenuPanel.classList.toggle('open', open);
  }
  function toggleMenu(){ setMenu(!menuOpen); }
  function setMemoWindow(open){
    if(!memoWindow) return;
    memoWindowOpen=open;
    memoWindow.classList.toggle('open', open);
    updateQuickActionButtons();
  }
  bookMenuBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); toggleMenu(); });
  bookMenuPanel?.addEventListener('click',(e)=>e.stopPropagation());
  memoWindow?.addEventListener('click',(e)=>e.stopPropagation());
  compareWindow?.addEventListener('click',(e)=>e.stopPropagation());
  memoWindowClose?.addEventListener('click',()=>setMemoWindow(false));
  updateFloatbarVisibility();
  const menuActionsContainer=document.getElementById('menuActions');
  const menuActionSettings=document.getElementById('menuActionSettings');
  menuActionsContainerRef=menuActionsContainer;
  if(menuActionSettings) menuActionSettingsRef=menuActionSettings;
  updateCompareWindowUI();
  renderMenuButtons();
  renderMenuActionSettings();
  menuCloseBtn?.addEventListener('click',()=>setMenu(false));
  function saveSplitRatio(){
    try{localStorage.setItem(PANE_SPLIT_KEY, splitRatio.toFixed(3));}catch(err){}
  }
  function applySplitRatio(){
    if(!paneLeft || !paneRight) return;
    const activeRatio = (compareRightHidden && mode==='compare') ? 0.9 : splitRatio;
    const leftFlex=Math.min(0.95, Math.max(0.2, activeRatio));
    const rightFlex=Math.max(0.05, 1-leftFlex);
    paneLeft.style.flex=`${leftFlex}`;
    paneRight.style.flex=`${rightFlex}`;
    if(paneDivider){
      if(mode==='single' || compareRightHidden){
        paneDivider.style.display='none';
      }else{
        paneDivider.style.display='';
        paneDivider.style.left=`calc(${(leftFlex*100).toFixed(2)}% - 6px)`;
      }
    }
  }
  let dividerDragging=false;
  let dividerRect=null;
  const dividerMouseMove=(e)=>{
    if(!dividerDragging || !dividerRect) return;
    let ratio=(e.clientX - dividerRect.left)/dividerRect.width;
    ratio=Math.min(0.85, Math.max(0.15, ratio));
    splitRatio=ratio;
    saveSplitRatio();
    applySplitRatio();
  };
  const dividerTouchMove=(e)=>{
    if(!dividerDragging || !dividerRect) return;
    const {x}=pointerClientXY(e);
    let ratio=(x - dividerRect.left)/dividerRect.width;
    ratio=Math.min(0.85, Math.max(0.15, ratio));
    splitRatio=ratio;
    saveSplitRatio();
    applySplitRatio();
  };
  const stopDividerDrag=()=>{
    if(!dividerDragging) return;
    dividerDragging=false;
    paneDivider?.classList.remove('active');
    document.removeEventListener('mousemove', dividerMouseMove);
    document.removeEventListener('mouseup', stopDividerDrag);
    document.removeEventListener('touchmove', dividerTouchMove);
    document.removeEventListener('touchend', stopDividerDrag);
  };
  const startDividerDrag=(clientX)=>{
    if(!paneDivider || !stageDual || mode==='single' || compareRightHidden || stageDual.classList.contains('hidden')) return;
    dividerDragging=true;
    paneDivider.classList.add('active');
    dividerRect=stageDual.getBoundingClientRect();
    document.addEventListener('mousemove', dividerMouseMove);
    document.addEventListener('mouseup', stopDividerDrag);
    document.addEventListener('touchmove', dividerTouchMove,{passive:false});
    document.addEventListener('touchend', stopDividerDrag);
  };
  paneDivider?.addEventListener('mousedown',(e)=>{ e.preventDefault(); startDividerDrag(e.clientX); });
  paneDivider?.addEventListener('touchstart',(e)=>{ const {x}=pointerClientXY(e); startDividerDrag(x); e.preventDefault(); },{passive:false});
  const onWindowResize=()=>{
    applySplitRatio();
    refreshZoomBounds();
    applyViewTransform();
  };
  window.addEventListener('resize', onWindowResize);
  compareHideBtn?.addEventListener('click',()=>{
    if(mode!=='compare') return;
    compareRightHidden=!compareRightHidden;
    applyCompareHideState();
  });
  function anchorFromElement(el, clientX, clientY){
    if(!el) return {x:0,y:0};
    const rect=el.getBoundingClientRect();
    return {x:clientX - (rect.left + rect.width/2), y:clientY - (rect.top + rect.height/2)};
  }
  function computeLayoutOffset(containerEl, imgEl){
    if(!containerEl || !imgEl) return {x:0,y:0};
    const parent=imgEl.offsetParent;
    const containerRect=containerEl.getBoundingClientRect?.();
    const parentRect=parent?.getBoundingClientRect?.();
    if(!containerRect || !parentRect) return {x:0,y:0};
    const layoutCenterX=parentRect.left + imgEl.offsetLeft + (imgEl.offsetWidth||0)/2;
    const layoutCenterY=parentRect.top + imgEl.offsetTop + (imgEl.offsetHeight||0)/2;
    const containerCenterX=containerRect.left + containerRect.width/2;
    const containerCenterY=containerRect.top + containerRect.height/2;
    return {x:layoutCenterX - containerCenterX, y:layoutCenterY - containerCenterY};
  }
  function getStageLayoutOffset(){
    return computeLayoutOffset(stage, img);
  }
  function stageAnchorFromClient(clientX, clientY){
    const rect=stage?.getBoundingClientRect?.();
    if(!rect) return {x:0,y:0};
    const baseOffset=getStageLayoutOffset();
    const centerX=rect.left + rect.width/2;
    const centerY=rect.top + rect.height/2;
    return {x:clientX-centerX - baseOffset.x, y:clientY-centerY - baseOffset.y};
  }
  function touchDistance(a,b){
    const dx=a.clientX-b.clientX;
    const dy=a.clientY-b.clientY;
    return Math.hypot(dx,dy);
  }
  function createPanZoomSurface(options={}){
    const {
      element,
      anchorFromClient=(x,y)=>({x,y}),
      getEnabled=()=>true,
      getZoom=()=>1,
      setZoom=()=>{},
      getZoomLocked=()=>false,
      getPanLocked=()=>false,
      applyPanDelta=()=>{},
      onPanStart=()=>{},
      onPanEnd=()=>{},
      onReset=()=>{},
      shouldIgnoreTarget=()=>false,
      doubleTapThreshold=350,
      doubleTapDistance=28,
      doubleTapResetEnabled=true
    }=options||{};
    if(!element) return {destroy:()=>{}};
    let dragging=false;
    let pointerId=null;
    let lastPointer=null;
    let pinchActive=false;
    let pinchStartDist=0;
    let pinchStartZoom=1;
    let pinchAnchor=null;
    let lastTapTime=0;
    let lastTapPos=null;
    const cleanup=[];
    const add=(target,type,handler,opts)=>{
      if(!target) return;
      target.addEventListener(type,handler,opts);
      cleanup.push(()=>target.removeEventListener(type,handler,opts));
    };
    const canInteract=(target)=> getEnabled() && !shouldIgnoreTarget(target);
    const stopDrag=(withMomentum=false)=>{
      if(!dragging) return;
      dragging=false;
      if(pointerId!==null){
        try{ element.releasePointerCapture(pointerId); }catch(err){}
      }
      pointerId=null;
      if(withMomentum){ startMomentum(); } else { stopMomentum(); }
      onPanEnd();
    };
    const supportsPointer = typeof window!=='undefined' && 'PointerEvent' in window;
    let velocity={x:0,y:0};
    // 慣性の強さを調整（軽いドラッグでも少し残る）
    const MOMENTUM_WINDOW=200;
    const MIN_SPEED=0.00003;
    const DECAY=0.94;
    const BOOST=1.1;
    const MAX_SPEED=1.4;
    let moveHistory=[];
    let moveHistoryTime=0;
    let lastMoveTime=0;
    let momentumId=null;
    const clampVel=(v)=>Math.max(-MAX_SPEED, Math.min(MAX_SPEED, v));
    const clearHistory=()=>{
      moveHistory=[];
      moveHistoryTime=0;
    };
    const pushMove=(dx,dy,dt)=>{
      if(dt<=0) return;
      moveHistory.push({dx,dy,dt});
      moveHistoryTime+=dt;
      while(moveHistoryTime>MOMENTUM_WINDOW && moveHistory.length){
        moveHistoryTime-=moveHistory[0].dt;
        moveHistory.shift();
      }
    };
    const blendedVelocity=()=>{
      if(!moveHistory.length) return {...velocity};
      let totalW=0,totalX=0,totalY=0,elapsed=0;
      // weight recent moves more for a snappier release
      for(let i=moveHistory.length-1;i>=0;i--){
        const m=moveHistory[i];
        elapsed+=m.dt;
        const recency = Math.max(0, MOMENTUM_WINDOW-elapsed)/MOMENTUM_WINDOW;
        const weight = 0.6 + 1.4*recency;
        totalW+=m.dt*weight;
        totalX+=m.dx*weight;
        totalY+=m.dy*weight;
        if(elapsed>MOMENTUM_WINDOW) break;
      }
      if(totalW<=0) return {...velocity};
      return {
        x: clampVel(totalX/totalW),
        y: clampVel(totalY/totalW)
      };
    };
    const stopMomentum=(resetVelocity=true)=>{
      if(momentumId){ cancelAnimationFrame(momentumId); momentumId=null; }
      if(resetVelocity) velocity={x:0,y:0};
    };
    const startMomentum=()=>{
      if(getPanLocked() || !getEnabled()) return;
      const releaseVel=blendedVelocity();
      stopMomentum(false);
      velocity.x=clampVel(releaseVel.x);
      velocity.y=clampVel(releaseVel.y);
      const speed=Math.max(Math.abs(velocity.x), Math.abs(velocity.y));
      if(speed<MIN_SPEED){
        stopMomentum();
        return;
      }
      let lastTs=performance.now();
      const step=(ts)=>{
        const dt=Math.max(1, ts-lastTs);
        lastTs=ts;
        velocity.x=clampVel(velocity.x*DECAY);
        velocity.y=clampVel(velocity.y*DECAY);
        applyPanDelta(velocity.x*dt*BOOST, velocity.y*dt*BOOST);
        if(Math.max(Math.abs(velocity.x), Math.abs(velocity.y))<MIN_SPEED){
          stopMomentum();
          return;
        }
        momentumId=requestAnimationFrame(step);
      };
      momentumId=requestAnimationFrame(step);
    };
    const pointerDown=(e)=>{
      if(!canInteract(e.target)) return;
      if(getPanLocked()) return;
      if(e.pointerType!=='touch' && e.button!==0) return;
      if(e.pointerType==='touch' && pinchActive) return;
      dragging=true;
      pointerId=e.pointerId;
      lastPointer={x:e.clientX,y:e.clientY};
      lastMoveTime=performance.now();
      velocity={x:0,y:0};
      clearHistory();
      stopMomentum();
      onPanStart();
      try{ element.setPointerCapture(e.pointerId); }catch(err){}
      e.preventDefault();
    };
    const pointerMove=(e)=>{
      if(!dragging || e.pointerId!==pointerId) return;
      if(getPanLocked()){ stopDrag(); try{ element.releasePointerCapture(e.pointerId); }catch(err){} return; }
      const dx=e.clientX-(lastPointer?.x||e.clientX);
      const dy=e.clientY-(lastPointer?.y||e.clientY);
      lastPointer={x:e.clientX,y:e.clientY};
      if(dx!==0 || dy!==0){
        const now=performance.now();
        const dt=Math.max(1, now-lastMoveTime);
        pushMove(dx,dy,dt);
        velocity.x=clampVel(dx/dt);
        velocity.y=clampVel(dy/dt);
        lastMoveTime=now;
        applyPanDelta(dx,dy);
      }
      e.preventDefault();
    };
    const pointerEnd=(e)=>{
      if(e.pointerId!==pointerId) return;
      stopDrag(true);
    };
    const pointerLost=()=>{ stopDrag(); };
    const mouseDown=(e)=>{
      if(!canInteract(e.target)) return;
      if(getPanLocked()) return;
      if(e.button!==0) return;
      dragging=true;
      lastPointer={x:e.clientX,y:e.clientY};
      lastMoveTime=performance.now();
      velocity={x:0,y:0};
      clearHistory();
      stopMomentum();
      onPanStart();
      e.preventDefault();
    };
    const mouseMove=(e)=>{
      if(!dragging) return;
      if(getPanLocked()){ stopDrag(); return; }
      const dx=e.clientX-(lastPointer?.x||e.clientX);
      const dy=e.clientY-(lastPointer?.y||e.clientY);
      lastPointer={x:e.clientX,y:e.clientY};
      if(dx!==0 || dy!==0){
        const now=performance.now();
        const dt=Math.max(1, now-lastMoveTime);
        pushMove(dx,dy,dt);
        velocity.x=clampVel(dx/dt);
        velocity.y=clampVel(dy/dt);
        lastMoveTime=now;
        applyPanDelta(dx,dy);
      }
    };
    const mouseUp=()=>{ if(!dragging) return; stopDrag(true); };
    if(supportsPointer){
      add(element,'pointerdown', pointerDown);
      add(element,'pointermove', pointerMove);
      add(element,'pointerup', pointerEnd);
      add(element,'pointercancel', pointerEnd);
      add(element,'lostpointercapture', pointerLost);
    }else{
      add(element,'mousedown', mouseDown);
      add(document,'mousemove', mouseMove);
      add(document,'mouseup', mouseUp);
    }
    const wheelHandler=(e)=>{
      if(!canInteract(e.target)) return;
      if(!getEnabled()) return;
      e.preventDefault();
      const deltaMode=e.deltaMode||0;
      const deltaY=normalizeWheelDelta(e.deltaY, deltaMode);
      const deltaX=normalizeWheelDelta(e.deltaX, deltaMode);
      if(getZoomLocked()){
        if(getPanLocked()) return;
        const prioritizeX = e.shiftKey || Math.abs(deltaX)>Math.abs(deltaY);
        if(prioritizeX){ applyPanDelta(-deltaX,0); }
        else{ applyPanDelta(0,-deltaY); }
        return;
      }
      const anchor=anchorFromClient(e.clientX,e.clientY);
      const scale=Math.exp(-e.deltaY/400);
      setZoom(getZoom()*scale,{anchor});
    };
    add(element,'wheel', wheelHandler,{passive:false});
    const dblHandler=(e)=>{
      if(!canInteract(e.target)) return;
      if(!getEnabled() || getZoomLocked()) return;
      // ページめくりボタンやナビゲーションUIは無視
      if(e.target.closest('#stagePrevArrow') || e.target.closest('#stageNextArrow') || e.target.closest('.pane-arrows')) return;
      e.preventDefault();
      onReset();
    };
    add(element,'dblclick', dblHandler);
    const touchStart=(e)=>{
      if(!getEnabled()) return;
      if(shouldIgnoreTarget(e.target)) return;
      if(e.touches.length===2){
        if(getZoomLocked()) return;
        stopDrag();
        pinchActive=true;
        pinchStartDist=touchDistance(e.touches[0], e.touches[1])||1;
        pinchStartZoom=getZoom();
        const midX=(e.touches[0].clientX+e.touches[1].clientX)/2;
        const midY=(e.touches[0].clientY+e.touches[1].clientY)/2;
        pinchAnchor=anchorFromClient(midX, midY);
        e.preventDefault();
      }
    };
    const touchMove=(e)=>{
      if(!getEnabled()) return;
      if(pinchActive && e.touches.length===2){
        if(getZoomLocked()){ pinchActive=false; return; }
        e.preventDefault();
        const dist=touchDistance(e.touches[0], e.touches[1])||1;
        const scale=dist/(pinchStartDist||dist);
        setZoom(pinchStartZoom*scale,{anchor:pinchAnchor});
      }
    };
    const touchEnd=(e)=>{
      if(!getEnabled()) return;
      if(shouldIgnoreTarget(e.target)){
        lastTapTime=0;
        lastTapPos=null;
        return;
      }
      if(e.touches.length<2) pinchActive=false;
      if(e.touches.length===0 && e.changedTouches.length===1){
        const now=Date.now();
        const tap=e.changedTouches[0];
        const dist=lastTapPos ? Math.hypot(tap.clientX-lastTapPos.x, tap.clientY-lastTapPos.y) : 0;
        if(doubleTapResetEnabled && !getZoomLocked() && !dragging && !pinchActive && now-lastTapTime<doubleTapThreshold && dist<doubleTapDistance){
          onReset();
          e.preventDefault();
        }
        lastTapTime=now;
        lastTapPos={x:tap.clientX,y:tap.clientY};
      }
    };
    add(element,'touchstart', touchStart,{passive:false});
    add(element,'touchmove', touchMove,{passive:false});
    add(element,'touchend', touchEnd,{passive:false});
    add(element,'touchcancel', touchEnd,{passive:false});
    const cancelInteractions=()=>{
      pinchActive=false;
      stopDrag();
    };
    return {destroy:()=>cleanup.forEach(fn=>fn()), cancel:cancelInteractions};
  }
  function applyViewTransform(){
    if(!img) return;
    refreshZoomBounds();
    const clampBookTranslate=()=>{
      const stageRect=stage?.getBoundingClientRect?.();
      const baseW=img?.clientWidth||img?.naturalWidth||0;
      const baseH=img?.clientHeight||img?.naturalHeight||0;
      const layoutOffset=getStageLayoutOffset();
      const offsetX=layoutOffset.x||0;
      const offsetY=layoutOffset.y||0;
      if(!stageRect || !baseW || !baseH) return;
      viewState.zoom = Math.max(viewState.minZoom, Math.min(viewState.maxZoom, viewState.zoom));
      if(keyNavConfig.bookClamp){
        const scaledW=baseW*viewState.zoom;
        const scaledH=baseH*viewState.zoom;
        const hardMaxX = Math.max(0, (scaledW - stageRect.width)/2);
        const hardMaxY = Math.max(0, (scaledH - stageRect.height)/2);
        viewState.translateX = clamp(viewState.translateX, -hardMaxX - offsetX, hardMaxX - offsetX);
        viewState.translateY = clamp(viewState.translateY, -hardMaxY - offsetY, hardMaxY - offsetY);
      }else{
        const margin=10;
        const scaledW=baseW*viewState.zoom;
        const scaledH=baseH*viewState.zoom;
        const softMaxX = Math.max(margin, ((scaledW - stageRect.width)/2) + margin);
        const softMaxY = Math.max(margin, ((scaledH - stageRect.height)/2) + margin);
        viewState.translateX = Math.max(-softMaxX - offsetX, Math.min(softMaxX - offsetX, viewState.translateX));
        viewState.translateY = Math.max(-softMaxY - offsetY, Math.min(softMaxY - offsetY, viewState.translateY));
      }
    };
  const shouldClamp = keyNavConfig.bookClamp || !clampSkipOnce;
  if(shouldClamp) clampBookTranslate();
  img.style.transformOrigin='center center';
  img.style.transform=`translate(${viewState.translateX}px, ${viewState.translateY}px) scale(${viewState.zoom})`;
}
  function resetViewState(opts={}){
    refreshZoomBounds();
    viewState.zoom=Math.max(viewState.minZoom, 1);
    viewState.translateX=0;
    viewState.translateY=0;
    stopInertia();
    if(!opts.keepAdjusted) viewState.userAdjusted=false;
    applyViewTransform();
    if(opts.toast){ showToast('ビューをリセットしました','ok'); }
    hideInteractionHint();
  }
  function triggerResetFlash(el){
    if(!el) return;
    el.classList.remove('reset-anim');
    void el.offsetWidth;
    el.classList.add('reset-anim');
    setTimeout(()=>el.classList.remove('reset-anim'),340);
  }
  let clampSkipOnce=false;
  function setZoom(next,{anchor=null,silent=false,skipClamp=false}={}){
    refreshZoomBounds();
    const prev=viewState.zoom||1;
    const maxZoom=Math.max(viewState.maxZoom, viewState.minZoom);
    const target=Math.max(viewState.minZoom, Math.min(maxZoom, next));
    const pivot=anchor||{x:0,y:0};
    if(prev!==target){
      const ratio=target/prev;
      viewState.translateX = pivot.x - ratio*(pivot.x - viewState.translateX);
      viewState.translateY = pivot.y - ratio*(pivot.y - viewState.translateY);
    }
    viewState.zoom=target;
    if(!silent) viewState.userAdjusted=true;
    if(skipClamp && !keyNavConfig.bookClamp) clampSkipOnce=true;
    applyViewTransform();
    clampSkipOnce=false;
    hideInteractionHint();
  }
  function hideInteractionHint(){
    if(!interactionHint) return;
    interactionHint.classList.add('hidden');
    if(hintTimer){ clearTimeout(hintTimer); hintTimer=null; }
  }
  function showInteractionHint(){
    if(!interactionHint) return;
    interactionHint.classList.remove('hidden');
    if(hintTimer){ clearTimeout(hintTimer); }
    hintTimer=setTimeout(()=>interactionHint.classList.add('hidden'), 3500);
  }
  function updateHintText(){
    if(!interactionHint) return;
    let text='';
    if(zoomLocked && panLocked){
      text='ズーム＆移動ロック中';
    }else if(zoomLocked){
      text='ズーム固定: ホイール＝上下移動 / ドラッグ＝移動';
    }else if(panLocked){
      text='移動ロック: ホイール＝ズーム / ドラッグ不可';
    }else{
      text='ホイール＝ズーム / ドラッグ＝移動 / ダブルクリック＝リセット';
    }
    interactionHint.textContent=text;
  }
  const paneControllers=[];
  function createPaneZoomer(paneEl, imgEl, surfaceKey){
    const surfaceRef=()=>selectionSurfaces[surfaceKey];
    if(!paneEl || !imgEl) return {reset:()=>{}, destroy:()=>{}, cancelInteractions:()=>{}};
    const state={zoom:1,minZoom:0.4,maxZoom:6,translateX:0,translateY:0};
    const enforceClamp=()=>{
      if(!keyNavConfig.bookClamp) return;
      const rect=paneEl.getBoundingClientRect?.();
      const baseW=imgEl?.clientWidth||imgEl?.naturalWidth||0;
      const baseH=imgEl?.clientHeight||imgEl?.naturalHeight||0;
      const layoutOffset=computeLayoutOffset(paneEl, imgEl);
      const offsetX=layoutOffset.x||0;
      const offsetY=layoutOffset.y||0;
      if(!rect || !baseW || !baseH) return;
      const fitZoom=Math.max(rect.width/(baseW||1), rect.height/(baseH||1));
      state.minZoom=Math.max(0.4, fitZoom);
      state.maxZoom=Math.max(state.maxZoom, state.minZoom);
      state.zoom=Math.max(state.minZoom, Math.min(state.maxZoom, state.zoom));
      const scaledW=baseW*state.zoom;
      const scaledH=baseH*state.zoom;
      const maxX=Math.max(0, (scaledW - rect.width)/2);
      const maxY=Math.max(0, (scaledH - rect.height)/2);
      state.translateX = clamp(state.translateX, -maxX - offsetX, maxX - offsetX);
      state.translateY = clamp(state.translateY, -maxY - offsetY, maxY - offsetY);
    };
    const apply=()=>{ enforceClamp(); imgEl.style.transformOrigin='center center'; imgEl.style.transform=`translate(${state.translateX}px,${state.translateY}px) scale(${state.zoom})`; };
    const reset=({toast=false}={})=>{
      state.zoom=Math.max(state.minZoom, 1);
      state.translateX=0;
      state.translateY=0;
      apply();
      if(toast) showToast('ビューをリセットしました','ok');
    };
    const onImgLoad=()=>reset();
    imgEl.addEventListener('load', onImgLoad);
    const setZoomValue=(value,{anchor=null}={})=>{
      const prev=state.zoom;
      enforceClamp();
      const target=Math.max(state.minZoom, Math.min(state.maxZoom, value));
      const pivot=anchor||{x:0,y:0};
      if(prev!==target){
        state.translateX = pivot.x - (target/prev)*(pivot.x - state.translateX);
        state.translateY = pivot.y - (target/prev)*(pivot.y - state.translateY);
      }
      state.zoom=target;
      apply();
    };
    const applyPanDelta=(dx,dy)=>{
      state.translateX+=dx;
      state.translateY+=dy;
      apply();
    };
    const isPaneVisible=()=>{
      if(stageDual && stageDual.classList.contains('hidden')) return false;
      return !paneEl.classList.contains('hidden-content');
    };
    const shouldIgnoreTarget=(target)=>{
      return target.closest('.pane-controls')||target.closest('.pane-arrows')||target.closest('.mini-menu');
    };
    const controller=createPanZoomSurface({
      element:paneEl,
      anchorFromClient:(x,y)=>anchorFromElement(paneEl,x,y),
      getEnabled:()=> isPaneVisible(),
      getZoom:()=>state.zoom,
      setZoom:(next,opts)=>setZoomValue(next,opts),
      getZoomLocked:()=>zoomLocked,
      getPanLocked:()=>panLocked || selecting,
      applyPanDelta:(dx,dy)=>applyPanDelta(dx,dy),
      onPanStart:()=>paneEl.classList.add('is-panning'),
      onPanEnd:()=>paneEl.classList.remove('is-panning'),
      onReset:()=>{ reset(); triggerResetFlash(paneEl); },
      shouldIgnoreTarget:shouldIgnoreTarget,
      doubleTapResetEnabled:true
    });
    const handleMouseDown=(e)=>{
      if(!selecting) return;
      if(shouldIgnoreTarget(e.target)) return;
      e.preventDefault();
      startDrag(e, surfaceRef());
    };
    const handleTouchStart=(e)=>{
      if(!selecting) return;
      if(shouldIgnoreTarget(e.target)) return;
      if(e.touches.length===1){
        e.preventDefault();
        startDrag(e, surfaceRef());
      }
    };
    const handleTouchMove=(e)=>{
      if(!selecting) return;
      e.preventDefault();
      moveDrag(e);
    };
    const handleTouchEnd=(e)=>{
      if(!selecting) return;
      e.preventDefault();
      endDrag(e);
    };
    paneEl.addEventListener('mousedown', handleMouseDown);
    paneEl.addEventListener('touchstart', handleTouchStart,{passive:false});
    paneEl.addEventListener('touchmove', handleTouchMove,{passive:false});
    paneEl.addEventListener('touchend', handleTouchEnd,{passive:false});
    paneEl.addEventListener('touchcancel', handleTouchEnd,{passive:false});
    const handleDblClick=(e)=>{
      e.preventDefault();
      if(zoomLocked) return;
      reset();
    };
    paneEl.addEventListener('dblclick', handleDblClick);
    return {
      reset,
      cancelInteractions:()=>controller.cancel?.(),
      destroy:()=>{
        controller.destroy?.();
        paneEl.removeEventListener('mousedown', handleMouseDown);
        paneEl.removeEventListener('touchstart', handleTouchStart);
        paneEl.removeEventListener('touchmove', handleTouchMove);
        paneEl.removeEventListener('touchend', handleTouchEnd);
        paneEl.removeEventListener('touchcancel', handleTouchEnd);
        paneEl.removeEventListener('dblclick', handleDblClick);
        imgEl.removeEventListener('load', onImgLoad);
      }
    };
  }

  function realOf(idx){return book.firstPageNumber + idx}
  function idxFromReal(real){return Math.min(Math.max(0, real - book.firstPageNumber), book.pages.length-1)}

  function refreshCustomControls(){
    customArea.innerHTML='';
    customFilter.innerHTML='<option value="">カスタム状態（任意）</option>';
    book.customStates.forEach(cs=>{
      const span=document.createElement('label'); span.className='tag';
      span.style.borderColor=cs.color||'#2a3a55';
      span.innerHTML=`<input type="checkbox" data-cs="${cs.id}"> ${escapeHTML(cs.name)} <span class="x" data-delcs="${cs.id}">✕</span>`;
      customArea.appendChild(span);
      const opt=document.createElement('option'); opt.value=cs.id; opt.textContent=cs.name; customFilter.appendChild(opt);
    });
  }
  refreshCustomControls();
  const leftPaneController=createPaneZoomer(paneLeft, imgLeft, 'left');
  const rightPaneController=createPaneZoomer(paneRight, imgRight, 'right');
  paneControllers.push(leftPaneController, rightPaneController);
  const applyControlWidth=()=>{
    wrap.style.setProperty('--control-width', `${controlWidth}px`);
  };
  applyControlWidth();
  const startResize=(clientX)=>{
    const rect=wrap.getBoundingClientRect();
    const stageRect=stageHost.getBoundingClientRect();
    const min=240, max=Math.max(280, rect.width*0.55);
    const onMove=(x)=>{
      const relative = rect.right - x;
      controlWidth = Math.min(max, Math.max(min, relative));
      applyControlWidth();
      refreshZoomBounds();
      applyViewTransform();
    };
    const moveHandler=(e)=>{ e.preventDefault(); onMove(e.clientX); };
    const upHandler=()=>{
      document.removeEventListener('mousemove', moveHandler);
      document.removeEventListener('mouseup', upHandler);
      localStorage.setItem('viewer-control-width', String(controlWidth));
    };
    document.addEventListener('mousemove', moveHandler);
    document.addEventListener('mouseup', upHandler);
    // initial set
    onMove(clientX);
  };
  controlResizer?.addEventListener('mousedown',(e)=>{
    e.preventDefault();
    startResize(e.clientX);
  });
  updateInteractionUI();
  applySplitRatio();
  function applyCompareHideState(){
    const shouldHide = compareRightHidden && mode==='compare';
    paneRight?.classList.toggle('hidden-content', shouldHide);
    if(shouldHide && pendingAnswerCrop?.surfaceKey==='right'){
      pendingAnswerCrop=null;
      selecting=false;
      syncSelectingUI();
    }
    if(compareHideBtn){
      compareHideBtn.classList.toggle('hidden', mode!=='compare');
      compareHideBtn.classList.toggle('active', shouldHide);
      compareHideBtn.textContent=shouldHide?'右側表示':'右側隠す';
      compareHideBtn.setAttribute('aria-pressed', shouldHide?'true':'false');
    }
    applySplitRatio();
    updateQuickActionButtons();
  }
  function resetCurrentView({toast=false}={}){
  if(mode==='single'){ 
      resetViewState({toast});
    }else{
      paneControllers.forEach((ctrl,idx)=>ctrl.reset({toast: toast && idx===0}));
      if(toast && paneControllers.length===0) showToast('ビューをリセットしました','ok');
    }
  }
  window.__viewerResetView=({toast=false}={})=>resetCurrentView({toast});
  function updateInteractionUI(){
    const isSingle = mode==='single';
    stage?.classList.toggle('pan-disabled', !isSingle || panLocked);
    if(!isSingle) stageSurface?.cancel?.();
    if(isSingle){ updateHintText(); showInteractionHint(); } else { hideInteractionHint(); }
  }

  function firstPageOf(targetBook){
    return (typeof targetBook?.firstPageNumber === 'number') ? targetBook.firstPageNumber : 1;
  }
  function realOfOtherBook(targetBook, idx){
    return firstPageOf(targetBook) + idx;
  }
  function idxFromRealForBook(targetBook, real){
    if(!targetBook || !Array.isArray(targetBook.pages) || !targetBook.pages.length) return 0;
    return clamp(real - firstPageOf(targetBook), 0, targetBook.pages.length-1);
  }
  function ensureCompareWindowPosition(){
    if(!compareWindow || !compareWindowOpen) return;
    requestAnimationFrame(()=>{
      if(!compareWindow || !compareWindowOpen) return;
      if(compareWindowPos){
        applyCompareWindowPosition(compareWindowPos);
        compareWindow.style.right='auto';
        return;
      }
      const viewerRect=wrap.getBoundingClientRect();
      const panelRect=compareWindow.getBoundingClientRect();
      const width=panelRect.width||320;
      const defaultLeft=Math.max(8, viewerRect.width - width - 16);
      const clamped=clampPanelPosition(compareWindow, defaultLeft, 120);
      compareWindow.style.left=`${clamped.left}px`;
      compareWindow.style.top=`${clamped.top}px`;
      compareWindow.style.right='auto';
      compareWindowPos=clamped;
      saveStoredJSON('viewer-compare-window-pos', compareWindowPos);
    });
  }
  function updateCompareWindowUI(shouldUpdateMenu=false){
    if(!compareWindow) return;
    compareWindow.classList.toggle('open', compareWindowOpen);
    compareWindow.classList.toggle('transparent', compareWindowTransparent);
    const hasBook = !!(compareWindowBook && compareWindowBook.pages && compareWindowBook.pages.length);
    compareWindow.classList.toggle('has-book', hasBook);
    if(compareWindowTitle){
      compareWindowTitle.textContent = hasBook ? (compareWindowBook.title || '比較ウィンドウ') : '比較ウィンドウ';
    }
    if(hasBook){
      compareWindowIndex = clamp(compareWindowIndex, 0, compareWindowBook.pages.length-1);
      if(compareWindowImg) compareWindowImg.src = compareWindowBook.pages[compareWindowIndex]?.dataUrl || '';
      if(compareWindowMeta) compareWindowMeta.textContent = `${compareWindowIndex+1}/${compareWindowBook.pages.length} ・ ${realOfOtherBook(compareWindowBook, compareWindowIndex)}p`;
      if(compareWindowPlaceholder) compareWindowPlaceholder.textContent='';
      const controlsEnabled = compareWindowOpen;
      if(compareWindowPrev) compareWindowPrev.disabled = !controlsEnabled || compareWindowIndex<=0;
      if(compareWindowNext) compareWindowNext.disabled = !controlsEnabled || compareWindowIndex>=compareWindowBook.pages.length-1;
      if(compareWindowGo) compareWindowGo.disabled=!controlsEnabled;
      if(compareWindowJump) compareWindowJump.disabled=!controlsEnabled;
    }else{
      if(compareWindowImg) compareWindowImg.removeAttribute('src');
      if(compareWindowMeta) compareWindowMeta.textContent = compareWindowOpen?'本を選択してください':'本が選択されていません';
      if(compareWindowPlaceholder) compareWindowPlaceholder.textContent='ここに比較ページが表示されます';
      [compareWindowPrev, compareWindowNext].forEach(btn=>{ if(btn) btn.disabled=true; });
      if(compareWindowGo) compareWindowGo.disabled=true;
      if(compareWindowJump){ compareWindowJump.disabled=true; compareWindowJump.value=''; }
      resetCompareView();
      compareNeedsReset=true;
    }
    if(compareWindowSync){
      compareWindowSync.classList.toggle('active', compareWindowTransparent);
      compareWindowSync.textContent = compareWindowTransparent ? '透明ON' : '透明';
      compareWindowSync.setAttribute('aria-pressed', compareWindowTransparent?'true':'false');
    }
    if(compareWindowBtn){
      compareWindowBtn.classList.toggle('active', compareWindowOpen);
      compareWindowBtn.textContent = compareWindowOpen ? '比較ウィンドウ解除' : '比較ウィンドウ';
    }
    updateCompareLockButtons();
    updateCompareDockUI();
    if(shouldUpdateMenu) updateQuickActionButtons();
    persistProgress();
  }
  function setCompareWindowOpen(open){
    compareWindowOpen=open;
    if(!compareWindowOpen) compareWindowMinimized=false;
    if(!compareWindowOpen){
      compareStageSurface?.cancel?.();
      if(pendingAnswerCrop?.surfaceKey==='compareWindow'){
        pendingAnswerCrop=null;
        selecting=false;
        syncSelectingUI();
      }
    }
    updateCompareWindowUI(true);
    if(compareWindowOpen) ensureCompareWindowPosition();
  }
  function setCompareWindowBook(nextBook){
    compareWindowBook = nextBook;
    if(compareWindowBook && compareWindowBook.pages && compareWindowBook.pages.length){
      const saved=getLastCompareWindowIndex(book.id, compareWindowBook.id);
      if(typeof saved==='number' && !Number.isNaN(saved)){
        compareWindowIndex = clamp(saved,0,compareWindowBook.pages.length-1);
      }else{
        compareWindowIndex = idxFromRealForBook(compareWindowBook, realOf(page));
      }
      compareWindowOpen = true;
    }else{
      compareWindowIndex = 0;
    }
    requestCompareViewReset();
    updateCompareWindowUI(true);
    if(compareWindowOpen) ensureCompareWindowPosition();
  }
  function shiftCompareWindow(delta){
    if(!compareWindowBook || !compareWindowBook.pages?.length) return;
    compareWindowIndex = clamp(compareWindowIndex + delta, 0, compareWindowBook.pages.length-1);
    requestCompareViewReset();
    updateCompareWindowUI(true);
  }
  function jumpCompareWindow(realPage){
    if(!compareWindowBook || !compareWindowBook.pages?.length) return;
    compareWindowIndex = idxFromRealForBook(compareWindowBook, realPage);
    requestCompareViewReset();
    updateCompareWindowUI(true);
  }
  function syncCompareWindow(){
    if(!compareWindowBook || !compareWindowBook.pages?.length) return;
    compareWindowIndex = idxFromRealForBook(compareWindowBook, realOf(page));
    requestCompareViewReset();
    updateCompareWindowUI(true);
  }


  function setSingle(){ 
      document.getElementById('stageSingle').classList.remove('hidden');
      document.getElementById('stageDual').classList.add('hidden');
    }
    function setDual(){
      document.getElementById('stageSingle').classList.add('hidden');
      document.getElementById('stageDual').classList.remove('hidden');
    }
  function renderBookmarks(){
    // keep bookmark structure available even if UI is hidden
    book.bookmarks = Array.isArray(book.bookmarks)?book.bookmarks:[];
  }
  function syncImmersive(){
    // immersive/reading mode placeholder
  }
  function persistProgress(){
    if(book?.id){
      setLastPageIndex(book.id, page);
    }
    if(mode==='compare' && rightBook?.id){
      setLastCompareIndex(book.id, rightBook.id, rightIndex);
    }
    if(compareWindowBook?.id){
      setLastCompareWindowIndex(book.id, compareWindowBook.id, compareWindowIndex);
    }
  }
  function load(){
    currentMode=mode;
    updateInteractionUI();
    if(mode==='single'){ 
      setSingle();
      img.src=book.pages[page].dataUrl; 
      pageBadge.textContent = `${realOf(page)}p`;
    } else if(mode==='spread'){ 
      setDual();
      leftIndex = page;
      rightIndex = Math.min(book.pages.length-1, leftIndex+1);
      document.getElementById('imgLeft').src = book.pages[leftIndex].dataUrl;
      document.getElementById('imgRight').src = book.pages[rightIndex].dataUrl;
      leftPaneController.reset();
      rightPaneController.reset();
      document.getElementById('badgeLeft').textContent = `${leftIndex+1}/${book.pages.length} ・ ${realOf(leftIndex)}p`;
      document.getElementById('badgeRight').textContent = `${rightIndex+1}/${book.pages.length} ・ ${realOf(rightIndex)}p`;
    } else if(mode==='compare'){ 
      setDual();
      // left: current book
      leftIndex = page;
      document.getElementById('imgLeft').src = book.pages[leftIndex].dataUrl;
      document.getElementById('badgeLeft').textContent = `${leftIndex+1}/${book.pages.length} ・ ${realOf(leftIndex)}p`;
      leftPaneController.reset();
      // right: other book
      if(rightBook && rightBook.pages && rightBook.pages.length){
        rightIndex = Math.min(rightIndex, rightBook.pages.length-1);
        document.getElementById('imgRight').src = rightBook.pages[rightIndex].dataUrl;
        document.getElementById('badgeRight').textContent = `${rightIndex+1}/${rightBook.pages.length}`;
        rightPaneController.reset();
      } else {
        document.getElementById('imgRight').src = '';
        document.getElementById('badgeRight').textContent = '右側: 未選択';
        rightPaneController.reset();
      }
    }
    applyCompareHideState();
    scrub.max = book.pages.length.toString();
    scrub.value = (page+1).toString();
    syncMemoFields(book.pages[page].memo||'', 'load');
    stFav.checked = !!book.pages[page].state?.fav;
    stWeak.checked = !!book.pages[page].state?.weak;
    stDone.checked = !!book.pages[page].state?.done;
    // custom checks
    document.querySelectorAll('[data-cs]').forEach(chk=>{
      const id=chk.getAttribute('data-cs');
      const curr = Array.isArray(book.pages[page].state.extra) ? book.pages[page].state.extra : (book.pages[page].state.extra = []);
      chk.checked = curr.includes(id);
      chk.onchange=async()=>{
        const arr = Array.isArray(book.pages[page].state.extra) ? book.pages[page].state.extra : (book.pages[page].state.extra = []);
        if(chk.checked){ if(!arr.includes(id)) arr.push(id); }
        else{ const i=arr.indexOf(id); if(i>=0) arr.splice(i,1); }
        await Book.put(book); updateThumbs();
      };
    });
    updateThumbs();
    renderBookmarks();
    syncImmersive();
    updateCompareWindowUI();
    updateQuickActionButtons();
    persistProgress();
  }
  function updateThumbs(){
    const list=document.getElementById('thumbList'); list.innerHTML='';
    const shown = book.pages.map((p,i)=>({p,i})).filter(({p})=>{
      if(customFilterId){ return (p.state?.extra||[]).includes(customFilterId); }
      if(filter==='all') return true;
      if(filter==='fav') return p.state?.fav;
      if(filter==='weak') return p.state?.weak;
      if(filter==='done') return p.state?.done;
      if(filter==='undone') return !p.state?.done;
      if(filter==='hasMemo') return (p.memo||'').trim().length>0;
      return true;
    });
    shown.forEach(({p,i})=>{
      const it=document.createElement('div'); it.className='item'+(i===page?' active':'');
      it.draggable=true; it.dataset.idx=i;
      const marks=[p.state?.fav?'★':'', p.state?.weak?'×':'' , p.state?.done?'✓':''].filter(Boolean).join(' ');
      const real=realOf(i);
      it.innerHTML=`
        ${multi?`<input type='checkbox' class='sel' ${selected.has(i)?'checked':''} data-sel='${i}'>`:''}
        <span class="pill">${i+1}</span><span class="muted">${real}p</span>
        <span class="muted">${marks}</span>
        <span class="muted">${(p.memo||'').slice(0,12)}</span>`;
      it.onclick=(e)=>{
        if(e.target.classList.contains('sel')){ 
          const idx=+e.target.getAttribute('data-sel');
          if(e.target.checked) selected.add(idx); else selected.delete(idx);
        }else{ page=i; load(); }
      };
      it.ondragstart=(e)=>{ e.dataTransfer.setData('text/plain', i); };
      it.ondragover=(e)=>{ e.preventDefault(); it.classList.add('dragover'); };
      it.ondragleave=()=> it.classList.remove('dragover');
      it.ondrop=(e)=>{
        e.preventDefault(); it.classList.remove('dragover');
        const from=+e.dataTransfer.getData('text/plain'); const to=i;
        movePage(from,to);
      };
      list.appendChild(it);
    });
  }
  function movePage(from,to){
    if(from===to) return;
    const item=book.pages.splice(from,1)[0];
    book.pages.splice(to,0,item);
    Book.put(book).then(()=>{ showToast('並べ替えました','ok'); page=to; load(); });
  }

  // fit modes
  function setFit(mode){
    if(mode==='contain'){ img.style.maxWidth='100%'; img.style.width=''; }
    if(mode==='width'){ img.style.maxWidth='none'; img.style.width='100%'; }
  }

  // selection crop
  function highlightAnswerTarget(){
    const targetKey=pendingAnswerCrop?.surfaceKey||null;
    [{key:'right',el:paneRight},{key:'compareWindow',el:compareWindowStage}].forEach(({key:k,el})=>{
      if(!el) return;
      el.classList.toggle('answer-target', !!targetKey && k===targetKey);
    });
  }
  function syncSelectingUI(){
    document.body.classList.toggle('selecting', selecting);
    [stage,paneLeft,paneRight,compareWindowStage].forEach(el=>{ if(el) el.style.cursor= selecting? 'crosshair' : ''; });
    if(!selecting){ clearSelectionCanvas(); }
    highlightAnswerTarget();
    selectQuickBtn?.classList.toggle('active', selecting);
    selectQuickBtn?.setAttribute('aria-pressed', selecting?'true':'false');
    if(selectQuickBtn){ selectQuickBtn.textContent = selecting ? '切取✓' : '切取'; }
  }
  function toggleSelect(){
    pendingAnswerCrop=null;
    selecting=!selecting;
    syncSelectingUI();
    floatbar.classList.remove('hidden');
    showToast(selecting? '選択モードON':'選択モードOFF');
  }
  function clearSelectionCanvas(){
    Object.values(selectionSurfaces).forEach(s=>{
      if(!s.canvas) return;
      s.canvas.classList.add('hidden');
      s.canvas.width=0;
      s.canvas.height=0;
    });
    boxRect=null;
    highlightAnswerTarget();
  }
  function chooseAnswerSurface(){
    if(compareWindowOpen && compareWindowBook && compareWindowStage && compareWindowImg && compareWindowImg.naturalWidth){
      return selectionSurfaces.compareWindow;
    }
    if(mode==='compare' && rightBook && !compareRightHidden && paneRight && imgRight?.naturalWidth){
      return selectionSurfaces.right;
    }
    return null;
  }
  function startAnswerCropTask({boxId,name,note,snippetId}){
    const surface=chooseAnswerSurface();
    if(!surface || !surface.container || !surface.img){
      showToast('解答側のビューが開いていません','error');
      return false;
    }
    pendingAnswerCrop={boxId,name,note,surfaceKey:surface.key,snippetId};
    selecting=true;
    syncSelectingUI();
    showToast('解答を切り取ってください（Escで中止）');
    return true;
  }
  function cancelAnswerCrop(){
    if(!pendingAnswerCrop) return;
    pendingAnswerCrop=null;
    selecting=false;
    syncSelectingUI();
    showToast('解答の追加切り取りをキャンセルしました','ok');
  }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function pointerClientXY(ev){
    if(ev.touches && ev.touches.length){ return {x:ev.touches[0].clientX, y:ev.touches[0].clientY}; }
    if(ev.changedTouches && ev.changedTouches.length){ return {x:ev.changedTouches[0].clientX, y:ev.changedTouches[0].clientY}; }
    return {x:ev.clientX, y:ev.clientY};
  }
  function normalizeWheelDelta(delta,mode){
    if(mode===1) return delta*28;
    if(mode===2) return delta*80;
    return delta;
  }
  function selectionMetaForSurface(surface){
    if(!surface) return null;
    if(surface===selectionSurfaces.single) return {bookId:book.id,pageIndex:page,firstPage:book.firstPageNumber||1};
    if(surface===selectionSurfaces.left) return {bookId:book.id,pageIndex:mode==='single'?page:leftIndex,firstPage:book.firstPageNumber||1};
    if(surface===selectionSurfaces.right){
      if(mode==='compare' && rightBook){ return {bookId:rightBook.id,pageIndex:rightIndex,firstPage:rightBook.firstPageNumber||1}; }
      return {bookId:book.id,pageIndex:rightIndex,firstPage:book.firstPageNumber||1};
    }
    if(surface===selectionSurfaces.compareWindow && compareWindowBook){
      return {bookId:compareWindowBook.id,pageIndex:compareWindowIndex,firstPage:compareWindowBook.firstPageNumber||1};
    }
    return {bookId:book.id,pageIndex:page,firstPage:book.firstPageNumber||1};
  }
  function startDrag(ev,surface){
    if(!selecting || !surface || !surface.img || !surface.canvas || !surface.container) return;
    if(pendingAnswerCrop && surface.key!==pendingAnswerCrop.surfaceKey) return;
    if(surface.container.classList.contains('hidden-content')) return;
    if(surface.key==='compareWindow' && (!compareWindowOpen)) return;
    const {x,y}=pointerClientXY(ev);
    rectImg=surface.img.getBoundingClientRect(); rectContainer=surface.container.getBoundingClientRect();
    if(x<rectImg.left||x>rectImg.right||y<rectImg.top||y>rectImg.bottom){return}
    dragging=true; startX=x; startY=y; activeSelectionSurface=surface;
    selectionMeta=selectionMetaForSurface(surface);
    const canvas=surface.canvas;
    canvas.classList.remove('hidden');
    canvas.style.left=(startX-rectContainer.left)+'px'; canvas.style.top=(startY-rectContainer.top)+'px';
    canvas.style.width='0px'; canvas.style.height='0px';
  }
  function moveDrag(ev){
    if(!dragging || !activeSelectionSurface) return;
    const {x,y}=pointerClientXY(ev);
    const cx=clamp(x,rectImg.left,rectImg.right);
    const cy=clamp(y,rectImg.top,rectImg.bottom);
    const relativeX=Math.min(startX,cx)-rectContainer.left;
    const relativeY=Math.min(startY,cy)-rectContainer.top;
    const w=Math.abs(cx-startX), h=Math.abs(cy-startY);
    const canvas=activeSelectionSurface.canvas;
    canvas.style.left=relativeX+'px'; canvas.style.top=relativeY+'px'; canvas.style.width=w+'px'; canvas.style.height=h+'px';
    canvas.width=Math.max(1,Math.floor(w)); canvas.height=Math.max(1,Math.floor(h));
    const ix0=Math.min(startX,cx)-rectImg.left, iy0=Math.min(startY,cy)-rectImg.top;
    boxRect={x:ix0,y:iy0,w:w,h:h};
  }
  async function endDrag(ev){
    if(!dragging || !activeSelectionSurface) return; dragging=false;
    if(!boxRect||boxRect.w<10||boxRect.h<10){ clearSelectionCanvas(); return; }
    const dataUrl = await cropDataUrlFromImg(activeSelectionSurface.img, boxRect, rectImg);
    const metaNow = selectionMeta || selectionMetaForSurface(activeSelectionSurface) || pendingSelectionMeta;
    selectionMeta=null;
    clearSelectionCanvas();
    if(pendingAnswerCrop){
      await saveAnswerCrop(dataUrl, metaNow);
      return;
    }
    pendingSelectionMeta=metaNow||pendingSelectionMeta;
    openBoxSelect(dataUrl, pendingSelectionMeta);
  }
  function interactiveTarget(target){
    return target.closest('.floatbar')||target.closest('.stage-arrows')||target.closest('.pane-controls')||target.closest('.pane-arrows')||target.closest('.mini-menu')||target.closest('.pane-divider');
  }
  let inertiaRaf=null;
  let inertiaVel={x:0,y:0};
  let inertiaPanTs=0;
  const stopInertia=()=>{
    if(inertiaRaf){ cancelAnimationFrame(inertiaRaf); inertiaRaf=null; }
    inertiaVel={x:0,y:0};
    inertiaPanTs=0;
  };
  const startInertia=()=>{
    if(zoomLocked || panLocked) return;
    const step=()=>{
      inertiaVel.x*=0.9;
      inertiaVel.y*=0.9;
      if(Math.abs(inertiaVel.x)+Math.abs(inertiaVel.y) < 0.05){
        stopInertia(); return;
      }
      viewState.translateX+=inertiaVel.x;
      viewState.translateY+=inertiaVel.y;
      applyViewTransform();
      inertiaRaf=requestAnimationFrame(step);
    };
    if(!inertiaRaf && (Math.abs(inertiaVel.x)>0.1 || Math.abs(inertiaVel.y)>0.1)){
      inertiaRaf=requestAnimationFrame(step);
    }
  };
  const stageSurface = createPanZoomSurface({
    element:stage,
    anchorFromClient:stageAnchorFromClient,
    getEnabled:()=>!!stage && !stage.classList.contains('hidden') && mode==='single',
    getZoom:()=>viewState.zoom,
    setZoom:(next,{anchor}={})=>setZoom(next,{anchor, skipClamp:!keyNavConfig.bookClamp}),
    getZoomLocked:()=>zoomLocked,
    getPanLocked:()=>panLocked || selecting,
    applyPanDelta:(dx,dy)=>{
      stopInertia();
      const now=performance.now();
      const dt=Math.max(8, now-(inertiaPanTs||now));
      inertiaPanTs=now;
      inertiaVel.x = dx/(dt/16);
      inertiaVel.y = dy/(dt/16);
      if(Math.abs(dx)>3 || Math.abs(dy)>3) panMoved=true;
      viewState.translateX+=dx;
      viewState.translateY+=dy;
      viewState.userAdjusted=true;
      applyViewTransform();
      hideInteractionHint();
    },
    onPanStart:()=>{
      stopInertia();
      stagePanning=true;
      stage?.classList.add('is-panning');
      viewState.userAdjusted=true;
    },
      onPanEnd:()=>{
        stagePanning=false;
      stage?.classList.remove('is-panning');
      startInertia();
      setTimeout(()=>{ panMoved=false; },120);
    },
    onReset:()=>{
      resetViewState({toast:false});
      hideInteractionHint();
      triggerResetFlash(stage);
    },
    shouldIgnoreTarget:(target)=>interactiveTarget(target),
    doubleTapResetEnabled:true
  });
  stage?.addEventListener('mousedown',(e)=>{
    if(!selecting) return;
    if(interactiveTarget(e.target)) return;
    e.preventDefault();
    startDrag(e, selectionSurfaces.single);
  });
  const docMoveSelection=(e)=>{ moveDrag(e); };
  const docUpSelection=(e)=>{ endDrag(e); };
  document.addEventListener('mousemove', docMoveSelection);
  document.addEventListener('mouseup', docUpSelection);
  stage?.addEventListener('touchstart',(e)=>{
    if(!selecting) return;
    if(interactiveTarget(e.target)) return;
    if(e.touches.length===1){
      e.preventDefault();
      startDrag(e, selectionSurfaces.single);
    }
  },{passive:false});
  stage?.addEventListener('touchmove',(e)=>{
    if(!selecting) return;
    e.preventDefault();
    moveDrag(e);
  },{passive:false});
  stage?.addEventListener('touchend',(e)=>{
    if(!selecting) return;
    e.preventDefault();
    endDrag(e);
  },{passive:false});
  const docKeydownSelection=(e)=>{ 
    if(e.key==='Escape'&&(dragging||selecting)){
      dragging=false;
      if(pendingAnswerCrop){ cancelAnswerCrop(); return; }
      selecting=false; syncSelectingUI();
    }
  };
  document.addEventListener('keydown',docKeydownSelection);

  // ---- Keyboard pan/zoom (arrow keys + . / \ _ with IME-friendly code fallbacks)
  const isTypingTarget=(el)=>{
    if(!el) return false;
    if(el.closest('input, textarea, select')) return true;
    if(el.isContentEditable) return true;
    return false;
  };
  const easeSmooth=(t)=> t<0.5 ? 2*t*t : 1-Math.pow(-2*t+2,2)/2; // legacy; kept for reference
  const PAN_DURATION=320;
  const ZOOM_DURATION=280;
  const PAN_DECAY=0.996; // per ms decay
  const ZOOM_DECAY=0.996;
  let panAnimId=null, panLastTs=0;
  let panVel={x:0,y:0};
  const runSmoothPan=(dx,dy,dt=16)=>{
    if(mode!=='single') return;
    if(panLocked || selecting) return;
    const base=keyNavConfig.panStep||DEFAULT_KEY_NAV_CONFIG.panStep;
    const zoomScale=1 + Math.max(0, viewState.zoom-1)*0.7;
    const distX=dx*base*zoomScale;
    const distY=dy*base*zoomScale;
    const impulse=(dt/16)/Math.max(75, PAN_DURATION);
    panVel.x += distX*impulse;
    panVel.y += distY*impulse;
    if(panAnimId){ return; }
    const step=(ts)=>{
      if(!panLastTs) panLastTs=ts;
      const dt=Math.min(48, ts-panLastTs||0);
      panLastTs=ts;
      viewState.translateX+=panVel.x*dt;
      viewState.translateY+=panVel.y*dt;
      applyViewTransform();
      const decay=Math.pow(PAN_DECAY, dt);
      panVel.x*=decay;
      panVel.y*=decay;
      if(Math.abs(panVel.x)+Math.abs(panVel.y) < 0.001){
        panVel={x:0,y:0};
        panLastTs=0;
        panAnimId=null;
        return;
      }
      panAnimId=requestAnimationFrame(step);
    };
    panAnimId=requestAnimationFrame(step);
  };
  let zoomAnimId=null, zoomLastTs=0;
  let zoomVel=0;
  const runSmoothZoom=(direction,dt=16)=>{
    if(mode!=='single') return;
    if(zoomLocked) return;
    refreshZoomBounds();
    const stepVal=keyNavConfig.zoomStep||DEFAULT_KEY_NAV_CONFIG.zoomStep;
    const factor=direction>0 ? stepVal : 1/(1 + (stepVal-1)*0.6);
    const targetZoom=Math.max(viewState.minZoom, Math.min(viewState.maxZoom, viewState.zoom*factor));
    const startZoom=viewState.zoom;
    const deltaZoom=targetZoom-startZoom;
    if(Math.abs(deltaZoom)<0.0001) return;
    const impulse=(dt/16)/Math.max(70, ZOOM_DURATION);
    zoomVel += deltaZoom*impulse;
    if(zoomAnimId){ return; }
    const step=(ts)=>{
      if(!zoomLastTs) zoomLastTs=ts;
      const dt=Math.min(48, ts-zoomLastTs||0);
      zoomLastTs=ts;
      const next=viewState.zoom + zoomVel*dt;
      setZoom(next,{anchor:{x:0,y:0},silent:false,skipClamp:!keyNavConfig.bookClamp});
      const decay=Math.pow(ZOOM_DECAY, dt);
      zoomVel*=decay;
      if(Math.abs(zoomVel)<0.000005){
        zoomVel=0;
        zoomLastTs=0;
        zoomAnimId=null;
        return;
      }
      zoomAnimId=requestAnimationFrame(step);
    };
    zoomAnimId=requestAnimationFrame(step);
  };
  const normKeys=(arr, fallback)=>Array.isArray(arr)?arr:fallback;
  const matchKey=(e, keys, codes)=> keys.includes(e.key) || codes.includes(e.code);
  const getKeyBindings=()=>{
    return {
      panLeftKeys:normKeys(keyNavConfig.panLeftKeys, DEFAULT_KEY_NAV_CONFIG.panLeftKeys),
      panRightKeys:normKeys(keyNavConfig.panRightKeys, DEFAULT_KEY_NAV_CONFIG.panRightKeys),
      panUpKeys:normKeys(keyNavConfig.panUpKeys, DEFAULT_KEY_NAV_CONFIG.panUpKeys),
      panDownKeys:normKeys(keyNavConfig.panDownKeys, DEFAULT_KEY_NAV_CONFIG.panDownKeys),
      zoomInKeys:normKeys(keyNavConfig.zoomInKeys, DEFAULT_KEY_NAV_CONFIG.zoomInKeys),
      zoomInCodes:normKeys(keyNavConfig.zoomInCodes, DEFAULT_KEY_NAV_CONFIG.zoomInCodes),
      zoomOutKeys:normKeys(keyNavConfig.zoomOutKeys, DEFAULT_KEY_NAV_CONFIG.zoomOutKeys),
      zoomOutCodes:normKeys(keyNavConfig.zoomOutCodes, DEFAULT_KEY_NAV_CONFIG.zoomOutCodes),
      resetKeys:normKeys(keyNavConfig.resetKeys, DEFAULT_KEY_NAV_CONFIG.resetKeys),
      resetCodes:normKeys(keyNavConfig.resetCodes, DEFAULT_KEY_NAV_CONFIG.resetCodes)
    };
  };
  const heldFns=new Map();
  let heldRaf=null, heldLastTs=0;
  const pumpHeld=(ts)=>{
    if(!heldLastTs) heldLastTs=ts;
    const dt=Math.min(60, ts-heldLastTs||0);
    heldLastTs=ts;
    heldFns.forEach(fn=>fn(dt));
    if(!heldFns.size){ heldRaf=null; heldLastTs=0; return; }
    heldRaf=requestAnimationFrame(pumpHeld);
  };
  const startHold=(key,fn)=>{
    if(heldFns.has(key)) return;
    heldFns.set(key,(dt)=>fn(dt||16));
    fn(16);
    if(!heldRaf) heldRaf=requestAnimationFrame(pumpHeld);
  };
  const stopHold=(key)=>{
    heldFns.delete(key);
    if(!heldFns.size && heldRaf){ cancelAnimationFrame(heldRaf); heldRaf=null; heldLastTs=0; }
  };
  const clearAllHolds=()=>{
    heldFns.clear();
    if(heldRaf){ cancelAnimationFrame(heldRaf); heldRaf=null; }
    heldLastTs=0;
  };
  const handleKeyboardNav=(e)=>{
    if(state.viewerContext!=='book') return;
    if(isTypingTarget(e.target)) return;
      const {
        panLeftKeys,panRightKeys,panUpKeys,panDownKeys,
        zoomInKeys,zoomInCodes,zoomOutKeys,zoomOutCodes,resetKeys,resetCodes
      } = getKeyBindings();
      const normKey=(s)=> (s||'').toLowerCase().trim();
      const match=(keys,codes)=> keys.map(normKey).includes(normKey(e.key)) || codes.map(normKey).includes(normKey(e.code));
      const k=e.key;
      let handled=false;
      if(match(panLeftKeys, [])){ startHold('panLeft',(dt)=>runSmoothPan(1,0,dt)); handled=true; }
      else if(match(panRightKeys, [])){ startHold('panRight',(dt)=>runSmoothPan(-1,0,dt)); handled=true; }
      else if(match(panUpKeys, [])){ startHold('panUp',(dt)=>runSmoothPan(0,1,dt)); handled=true; }
      else if(match(panDownKeys, [])){ startHold('panDown',(dt)=>runSmoothPan(0,-1,dt)); handled=true; }
      else if(match(zoomInKeys, zoomInCodes)){ startHold('zoomIn',(dt)=>runSmoothZoom(1,dt)); handled=true; }
      else if(match(zoomOutKeys, zoomOutCodes)){ startHold('zoomOut',(dt)=>runSmoothZoom(-1,dt)); handled=true; }
      else if(match(resetKeys, resetCodes)){ resetViewState({toast:false}); triggerResetFlash(stage); handled=true; }
    if(handled){
      e.preventDefault();
      e.stopPropagation();
    }
  };
  const handleKeyboardNavUp=(e)=>{
    stopHold(e.key);
    const {
      panLeftKeys,panRightKeys,panUpKeys,panDownKeys,
      zoomInKeys,zoomInCodes,zoomOutKeys,zoomOutCodes,resetKeys,resetCodes
    } = getKeyBindings();
    if(matchKey(e, panLeftKeys, [])) stopHold('panLeft');
    if(matchKey(e, panRightKeys, [])) stopHold('panRight');
    if(matchKey(e, panUpKeys, [])) stopHold('panUp');
    if(matchKey(e, panDownKeys, [])) stopHold('panDown');
    if(matchKey(e, zoomInKeys, zoomInCodes)) stopHold('zoomIn');
    if(matchKey(e, zoomOutKeys, zoomOutCodes)) stopHold('zoomOut');
  };
  if(window.__viewerKeyboardNav){
    document.removeEventListener('keydown', window.__viewerKeyboardNav);
  }
  if(window.__viewerKeyboardNavUp){
    document.removeEventListener('keyup', window.__viewerKeyboardNavUp);
  }
  window.__viewerKeyboardNav = handleKeyboardNav;
  window.__viewerKeyboardNavUp = handleKeyboardNavUp;
  document.addEventListener('keydown', handleKeyboardNav);
  document.addEventListener('keyup', handleKeyboardNavUp);
  window.addEventListener('blur', clearAllHolds);

  async function cropDataUrlFromImg(imgEl, rectOnDisp, rectDisp){
    const scaleX=imgEl.naturalWidth / rectDisp.width;
    const scaleY=imgEl.naturalHeight/ rectDisp.height;
    const sx=Math.max(0, Math.floor(rectOnDisp.x*scaleX));
    const sy=Math.max(0, Math.floor(rectOnDisp.y*scaleY));
    const sw=Math.max(1, Math.floor(rectOnDisp.w*scaleX));
    const sh=Math.max(1, Math.floor(rectOnDisp.h*scaleY));
    const c=document.createElement('canvas'); c.width=sw; c.height=sh;
    const g=c.getContext('2d'); g.drawImage(imgEl,sx,sy,sw,sh,0,0,sw,sh);
    return c.toDataURL('image/png');
  }

  async function openBoxSelect(dataUrl, meta){
    if(meta) pendingSelectionMeta=meta;
    const modal=document.getElementById('boxSelectModal');
    const sel=document.getElementById('boxSelect'); 
    if(!modal || !sel) return;
    sel.innerHTML='';
    const boxes=await Box.list();
    const recent=loadRecentBoxes();
    const idxMap=new Map(recent.map((id,i)=>[id,i]));
    boxes.sort((a,b)=>{
      const ai=idxMap.has(a.id)?idxMap.get(a.id):-1;
      const bi=idxMap.has(b.id)?idxMap.get(b.id):-1;
      if(ai!==bi){
        if(ai===-1) return 1;
        if(bi===-1) return -1;
        return ai-bi;
      }
      const ta=a.updatedAt??a.createdAt??0;
      const tb=b.updatedAt??b.createdAt??0;
      return tb-ta;
    });
    boxes.forEach(b=>{ const o=document.createElement('option'); o.value=b.id; o.textContent=b.name; sel.appendChild(o)});
    if(boxes.length){ sel.value=boxes[0].id; }
    document.getElementById('snippetName').value='';
    document.getElementById('snippetNote').value='';
    if(snippetPreview){ snippetPreview.src=dataUrl || 'data:,'; }
    const sourceMeta = pendingSelectionMeta || meta || selectionMetaForSurface(activeSelectionSurface);
    if(snippetSourceHint){
      const realPage = sourceMeta ? ((sourceMeta.firstPage||1)+(sourceMeta.pageIndex||0)) : realOf(page);
      snippetSourceHint.textContent = `元ページ: ${realPage}p`;
    }
    const alsoAnswer=document.getElementById('snippetAlsoAnswer');
    const ansModeCrop=document.getElementById('snippetAnswerModeCrop');
    const ansModePage=document.getElementById('snippetAnswerModePage');
    const updateAnswerOption=()=>{
      const candidate = answerCutCandidate(true);
      if(alsoAnswer){
        const enabled = alsoAnswer.checked;
        [ansModeCrop, ansModePage].forEach(r=>{ if(r){ r.disabled=!enabled; } });
        if(enabled){
          if(snippetAnswerHint) snippetAnswerHint.textContent = candidate ? `${candidate.label||'解答ビュー'} から追加保存できます` : '解答ウィンドウを表示して追加します';
        }else{
          if(snippetAnswerHint) snippetAnswerHint.textContent='解答を追加しない場合はチェックを外してください';
        }
      }
    };
    if(alsoAnswer){
      alsoAnswer.checked=false;
      alsoAnswer.disabled=false;
      [ansModeCrop, ansModePage].forEach(r=>{ if(r){ r.disabled=true; } });
      if(ansModeCrop) ansModeCrop.checked=true;
      alsoAnswer.onchange=async()=>{
        if(alsoAnswer.checked){
          const hasCandidate=!!answerCutCandidate(true);
          if(!hasCandidate){
            const ok=await ensureAnswerWindowForAdding();
            if(!ok){ alsoAnswer.checked=false; updateAnswerOption(); return; }
          }
        }
        updateAnswerOption();
      };
      updateAnswerOption();
    }
    modal.style.display='flex';
    modal.querySelectorAll('[data-close]').forEach(btn=>{
      btn.onclick=()=>{ modal.style.display='none'; pendingAnswerCrop=null; selecting=false; syncSelectingUI(); };
    });
    document.getElementById('assignToBoxBtn').onclick=()=>assignToBox(sel.value,dataUrl);
    document.getElementById('newBoxBtn').onclick=()=>{
      document.getElementById('newBoxModal').style.display='flex';
      document.getElementById('createBoxBtn').onclick=async()=>{
        const name=(document.getElementById('newBoxName').value||'新しいボックス').trim();
        const tags=(document.getElementById('newBoxTags').value||'').split(',').map(s=>s.trim()).filter(Boolean);
        const nb={id:uuid(),name,createdAt:Date.now(),snippets:[],tags};
        await Box.add(nb);
        document.getElementById('newBoxModal').style.display='none'; openBoxSelect(dataUrl);
      };
    };
  }
  function answerCutCandidate(preferWindow=true){
    const windowReady = compareWindowOpen && compareWindowBook && compareWindowBook.pages?.length && compareWindowImg?.naturalWidth;
    const splitReady = mode==='compare' && rightBook && rightBook.pages?.length && !compareRightHidden && imgRight?.naturalWidth;
    const windowCandidate = windowReady ? {dataUrl:compareWindowBook.pages?.[compareWindowIndex]?.dataUrl, meta:{bookId:compareWindowBook.id,pageIndex:compareWindowIndex,firstPage:compareWindowBook.firstPageNumber||1}, label:'比較ウィンドウ', surfaceKey:'compareWindow'} : null;
    const splitCandidate = splitReady ? {dataUrl:rightBook.pages?.[rightIndex]?.dataUrl, meta:{bookId:rightBook.id,pageIndex:rightIndex,firstPage:rightBook.firstPageNumber||1}, label:rightBook.title?`${rightBook.title} (右側)`:'右側', surfaceKey:'right'} : null;
    if(preferWindow && windowCandidate) return windowCandidate;
    return windowCandidate || splitCandidate || null;
  }
  async function ensureAnswerWindowForAdding(){
    if(compareWindowOpen && compareWindowBook) return true;
    const pid=primaryAnswerId();
    if(!pid){
      showToast('紐付け解答がありません','error');
      return false;
    }
    await openLinkedAnswerInWindow(pid);
    return compareWindowOpen && !!compareWindowBook;
  }
  async function assignToBox(boxId,dataUrl){
    if(!boxId){showToast('ボックスを選択してください','error'); return;}
    const bx=await Box.get(boxId); 
    if(!bx){ showToast('ボックスが見つかりません','error'); return; }
    bx.snippets=bx.snippets||[];
    const name=(document.getElementById('snippetName').value||'').trim();
    const note=(document.getElementById('snippetNote').value||'').trim();
    const alsoAnswer=document.getElementById('snippetAlsoAnswer')?.checked;
    const ansMode=(document.querySelector('input[name="snippetAnswerMode"]:checked')?.value)||'crop';
    const meta=pendingSelectionMeta || {bookId:book.id,pageIndex:page,firstPage:book.firstPageNumber||1};
    const snippetId=uuid();
    const newSnippet={id:snippetId,bookId:meta.bookId||book.id,pageIndex:meta.pageIndex??page,dataUrl,name, note, memo:note, weak:false, state:{fav:false,weak:false,done:false,extra:[]}, createdAt:Date.now(), answer:null};
    if(alsoAnswer && ansMode==='page'){
      let ans=answerCutCandidate(true);
      if(!ans){
        const ensured = await ensureAnswerWindowForAdding();
        if(!ensured){
          showToast('解答ウィンドウを開けませんでした','error');
        }
        ans=answerCutCandidate(true);
      }
      if(ans?.dataUrl){
        newSnippet.answer={dataUrl:ans.dataUrl, meta:ans.meta||{}, surfaceKey:ans.surfaceKey||null};
      }else{
        showToast('解答ビューが開いていません','error');
      }
    }
    bx.snippets.push(newSnippet);
    await Box.put(bx);
    bumpRecentBox(boxId);
    const modal=document.getElementById('boxSelectModal');
    if(modal) modal.style.display='none';
    showToast('ボックスに保存しました','ok');
    pendingSelectionMeta=null;
    if(alsoAnswer && ansMode==='crop'){
      let surface=chooseAnswerSurface();
      if(!surface){
        await ensureAnswerWindowForAdding();
      }
      if(startAnswerCropTask({boxId:bx.id,name,note,snippetId})){
        return;
      }
    }
    selecting=false; syncSelectingUI();
  }
  async function saveAnswerCrop(dataUrl, meta){
    const task=pendingAnswerCrop;
    pendingAnswerCrop=null;
    if(!task || !task.boxId){ selecting=false; syncSelectingUI(); return; }
    const bx=await Box.get(task.boxId);
    if(!bx){ showToast('ボックスが見つかりません','error'); selecting=false; syncSelectingUI(); return; }
    bx.snippets=bx.snippets||[];
    const target = bx.snippets.find(s=>s.id===task.snippetId);
    if(!target){
      showToast('解答を紐付ける切り抜きが見つかりません','error');
      selecting=false; syncSelectingUI(); return;
    }
    const m=meta || pendingSelectionMeta || {bookId:book.id,pageIndex:page,firstPage:book.firstPageNumber||1};
    target.answer={dataUrl, meta:m, surfaceKey:task.surfaceKey||null};
    await Box.put(bx);
    pendingSelectionMeta=null;
    showToast('解答を紐付けました','ok');
    selecting=false; syncSelectingUI();
  }

  // inline state & memo
  stFav.onchange=async()=>{ book.pages[page].state.fav=stFav.checked; await Book.put(book); updateThumbs(); };
  stWeak.onchange=async()=>{ book.pages[page].state.weak=stWeak.checked; await Book.put(book); updateThumbs(); };
  stDone.onchange=async()=>{
    book.pages[page].state.done=stDone.checked;
    await Book.put(book);
    updateThumbs();
  };

  document.getElementById('addState').onclick=()=>{
    const m=document.createElement('div'); m.className='modal'; m.style.display='flex';
    const b=document.createElement('div'); b.className='box';
    b.innerHTML=`<h3>カスタム状態を作成</h3>
      <input id="csName" class="input" placeholder="状態名（例：要復習/公式）" style="margin-bottom:8px"/>
      <input id="csColor" class="input" placeholder="#カラー（任意）" />
      <div class="row space" style="margin-top:10px"><button class="btn ghost" data-close>閉じる</button><button class="btn primary" data-save>追加</button></div>`;
    m.appendChild(b); document.body.appendChild(m);
    b.querySelector('[data-close]').onclick=()=>m.remove();
    b.querySelector('[data-save]').onclick=async()=>{
      const name=b.querySelector('#csName').value.trim(); if(!name){showToast('名前を入れてください','error');return}
      const color=(b.querySelector('#csColor').value||'').trim();
      book.customStates.push({id:uuid(),name,color}); await Book.put(book); m.remove(); refreshCustomControls(); load();
    };
  };
  customArea.addEventListener('click', async (e)=>{
    const del=e.target.getAttribute('data-delcs'); if(!del) return;
    // remove state id from all pages
    book.pages.forEach(p=>{ if(!Array.isArray(p.state.extra)) p.state.extra=[]; p.state.extra=p.state.extra.filter(x=>x!==del); });
    book.customStates = book.customStates.filter(x=>x.id!==del);
    await Book.put(book); refreshCustomControls(); load();
  });

  document.getElementById('customFilter').onchange=(e)=>{ customFilterId=e.target.value; updateThumbs(); };

  // buttons
  function goPrev(){
    const prev=findPrev(page);
    if(prev!==page){ page=prev; load(); }
  }
  function goNext(){
    const next=findNext(page);
    if(next!==page){ page=next; load(); }
  }
  const WHEEL_NAV_THRESHOLD=40;
  let wheelNavAccum=0;
  function handleWheelNavigation(delta){
    if(!delta) return;
    wheelNavAccum += delta;
    if(Math.abs(wheelNavAccum)>=WHEEL_NAV_THRESHOLD){
      if(wheelNavAccum>0){ goNext(); }
      else{ goPrev(); }
      wheelNavAccum=0;
    }
  }
  document.getElementById('prevBtn').onclick=goPrev;
  document.getElementById('nextBtn').onclick=goNext;
  document.getElementById('jumpGo').onclick=()=>{ const v=parseInt(document.getElementById('jumpInput').value,10); if(!isNaN(v)){ page=idxFromReal(v); load(); } };
  document.getElementById('fitContain').onclick=()=>setFit('contain');
  document.getElementById('fitWidth').onclick=()=>setFit('width');
  document.getElementById('selectBtn').onclick=toggleSelect;
  document.getElementById('insertBtn').onclick=()=>{ document.getElementById('pageInsertModal').style.display='flex'; };
  
  // spread toggle
  const spreadBtn = document.getElementById('spreadToggle');
  spreadBtn.onclick=()=>{
    mode = (mode==='spread') ? 'single' : 'spread';
    // selecting is not supported in dual mode (to keep UX簡潔)
    pendingAnswerCrop=null;
    selecting = false; syncSelectingUI();
    load();
  };
  // compare flow
  const compareStart = document.getElementById('compareStart');
  const compareEnd = document.getElementById('compareEnd');
  const compareModal = document.getElementById('compareModal');
  const compareSelect = document.getElementById('compareSelect');
  const compareGoBtn = document.getElementById('compareGo');
  const compareModalClose = compareModal?.querySelector('[data-close]');
  compareModal?.classList.add('window');
  compareModal?.querySelectorAll('[data-close]')?.forEach(btn=>{
    btn.addEventListener('click',()=>{ compareModal.style.display='none'; });
  });
  async function openComparePicker(target){
    if(!compareModal || !compareSelect || !compareGoBtn) return;
    compareModalTarget=target;
    compareSelect.innerHTML='';
    const all = await Book.list();
    const options = all.filter(b=>b.id!==book.id);
    if(!options.length){
      const opt=document.createElement('option');
      opt.value='';
      opt.textContent='比較できる本がありません';
      compareSelect.appendChild(opt);
      compareGoBtn.disabled=true;
    }else{
      options.forEach(bk=>{ const o=document.createElement('option'); o.value=bk.id; o.textContent=`${bk.title} (${bk.pages?.length||0}p)`; compareSelect.appendChild(o); });
      compareGoBtn.disabled=false;
    }
    compareGoBtn.textContent = target==='window'?'ウィンドウに表示':'並べて表示';
    compareModal.style.display='flex';
  }
  compareModalClose?.addEventListener('click',()=>{ compareModal.style.display='none'; });
  compareGoBtn?.addEventListener('click',async()=>{
    if(!compareSelect?.value) return;
    if(compareModalTarget==='window'){
      const nextBook=await Book.get(compareSelect.value);
      if(!nextBook){ showToast('選択した本が見つかりません','error'); return; }
      if(!nextBook.pages?.length){ showToast('ページがありません','error'); return; }
      setCompareWindowBook(nextBook);
    }else{
      rightBook = await Book.get(compareSelect.value);
      if(!rightBook){ showToast('選択した本が見つかりません','error'); return; }
      rightIndex = getCompareStartIndexFor(rightBook);
      mode = 'compare';
      compareEnd.classList.remove('hidden');
      compareStart.classList.add('hidden');
      pendingAnswerCrop=null;
      selecting = false; syncSelectingUI();
      compareRightHidden=false;
      load();
    }
    compareModal.style.display='none';
  });
  function exitCompareMode({toast=false}={}){
    if(mode==='compare' && rightBook?.id){
      setLastCompareIndex(book.id, rightBook.id, rightIndex);
    }
    mode='single';
    rightBook=null;
    rightIndex=0;
    if(pendingAnswerCrop){
      pendingAnswerCrop=null;
      selecting=false;
      syncSelectingUI();
    }
    compareEnd?.classList.add('hidden');
    compareStart?.classList.remove('hidden');
    compareRightHidden=false;
    load();
    if(toast) showToast('比較を一時停止しました','ok');
  }
  compareStart.onclick=()=>openComparePicker('split');
  compareEnd.onclick=()=>exitCompareMode();
  compareWindowBtn?.addEventListener('click',(e)=>{
    e.stopPropagation();
    if(compareWindowOpen){ setCompareWindowOpen(false); return; }
    if(compareWindowBook){ setCompareWindowOpen(true); return; }
    openComparePicker('window');
  });
  compareWindowZoomLock?.addEventListener('click',(e)=>{
    e.stopPropagation();
    setCompareZoomLock(!compareZoomLocked);
  });
  compareWindowPanLock?.addEventListener('click',(e)=>{
    e.stopPropagation();
    setComparePanLock(!comparePanLocked);
  });
  compareWindowSelect?.addEventListener('click',(e)=>{ e.stopPropagation(); openComparePicker('window'); });
  compareWindowClose?.addEventListener('click',(e)=>{ e.stopPropagation(); setCompareWindowOpen(false); });
  compareWindowPrev?.addEventListener('click',(e)=>{ e.stopPropagation(); shiftCompareWindow(-1); });
  compareWindowNext?.addEventListener('click',(e)=>{ e.stopPropagation(); shiftCompareWindow(1); });
  compareWindowGo?.addEventListener('click',(e)=>{ e.stopPropagation(); if(compareWindowJump){ const v=parseInt(compareWindowJump.value||'',10); if(!isNaN(v)) jumpCompareWindow(v); } });
  compareWindowJump?.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); compareWindowGo?.click(); } });
  compareWindowSync?.addEventListener('click',(e)=>{ e.stopPropagation(); setCompareWindowTransparent(!compareWindowTransparent); });
  // dual pane controls
  document.getElementById('leftPrev').onclick=()=>{ if(mode==='spread'){ page=Math.max(0, page-2); } else { page=Math.max(0, page-1);} load(); };
  document.getElementById('leftNext').onclick=()=>{ if(mode==='spread'){ page=Math.min(book.pages.length-1, page+2); } else { page=Math.min(book.pages.length-1, page+1);} load(); };
  document.getElementById('leftGo').onclick=()=>{ const v=parseInt(document.getElementById('leftJump').value||''); if(!isNaN(v)){ if(mode==='spread'){ page = idxFromReal(v); if(page%2===1) page--; } else { page = idxFromReal(v); } load(); } };
  document.getElementById('rightPrev').onclick=async()=>{ if(mode==='spread'){ page=Math.max(0, page-2); load(); } else if(mode==='compare' && rightBook){ rightIndex=Math.max(0,rightIndex-1); load(); } };
  document.getElementById('rightNext').onclick=async()=>{ if(mode==='spread'){ page=Math.min(book.pages.length-1, page+2); load(); } else if(mode==='compare' && rightBook){ rightIndex=Math.min(rightBook.pages.length-1,rightIndex+1); load(); } };
  document.getElementById('rightGo').onclick=()=>{ const v=parseInt(document.getElementById('rightJump').value||''); if(!isNaN(v)){ if(mode==='spread'){ const idx = idxFromReal(v); page = (idx%2===0)? idx : idx-1; } else if(mode==='compare' && rightBook){ rightIndex = Math.max(0, Math.min(rightBook.pages.length-1, v-1)); } load(); } };
  stagePrevArrow?.addEventListener('click',(e)=>{ e.stopPropagation(); goPrev(); });
  stageNextArrow?.addEventListener('click',(e)=>{ e.stopPropagation(); goNext(); });
  paneLeftPrevArrow?.addEventListener('click',(e)=>{ e.stopPropagation(); document.getElementById('leftPrev')?.click(); });
  paneLeftNextArrow?.addEventListener('click',(e)=>{ e.stopPropagation(); document.getElementById('leftNext')?.click(); });
  paneRightPrevArrow?.addEventListener('click',(e)=>{ e.stopPropagation(); document.getElementById('rightPrev')?.click(); });
  paneRightNextArrow?.addEventListener('click',(e)=>{ e.stopPropagation(); document.getElementById('rightNext')?.click(); });


  const backBtn=document.getElementById('backLib');
  backBtn.onclick=()=>{ 
    stopFlip();
    setMenu(false);
    setMemoWindow(false);
    state.view='library';
    state.viewerContext=null;
    viewerMemory.book.closed=true;
    viewerMemory.book.id=null;
    pendingAnswerCrop=null;
    selecting=false;
    syncSelectingUI();
    stage.removeEventListener('click', stageTap);
    stage.removeEventListener('wheel', wheelHandler);
    document.removeEventListener('mousemove', docMouseMovePan);
    document.removeEventListener('mouseup', docMouseUpPan);
    document.removeEventListener('mousemove', docMoveSelection);
    document.removeEventListener('mouseup', docUpSelection);
    document.removeEventListener('keydown', docKeydownSelection);
      paneControllers.forEach(ctrl=>ctrl.destroy?.());
    stopInertia();
    bodyObserver.disconnect();
    window.removeEventListener('resize', onWindowResize);
    host.innerHTML='';
    host.classList.add('hidden');
    showTab('library');
    window.__viewerResetView=null;
    document.body.classList.remove('reading');
  };
  document.getElementById('filterSelect').onchange=(e)=>{ filter=e.target.value; updateThumbs(); };

  // flip-through
  const flipPlayBtn=document.getElementById('flipPlay');
  const flipStopBtn=document.getElementById('flipStop');
  const flipSpeedInput=document.getElementById('flipSpeed');
  const fFlipBtn=document.getElementById('fFlip');
  function playFlip(){
    stopFlip();
    const pps = Math.max(1, parseInt(flipSpeedInput.value,10)||8); // pages per second
    flipTimer=setInterval(()=>{
      const next=findNext(page);
      if(next===page){ stopFlip(); return; }
      page=next; load();
    }, Math.floor(1000/pps));
    showToast('めくりまくり開始');
  }
  function stopFlip(){
    if(flipTimer){ clearInterval(flipTimer); flipTimer=null; showToast('停止'); }
  }
  flipPlayBtn.onclick=playFlip;
  if(fFlipBtn) fFlipBtn.onclick=()=> flipTimer? stopFlip(): playFlip();
  if(flipStopBtn) flipStopBtn.onclick=stopFlip;
  scrub.oninput=(e)=>{ const v=Math.max(1, Math.min(book.pages.length, parseInt(scrub.value,10)||1)); page=v-1; load(); };

  // floating (main2)
  const fPrev=document.getElementById('fPrev');
  const fNext=document.getElementById('fNext');
  const fGo=document.getElementById('fGo');
  const fJump=document.getElementById('fJump');
  const fSelect=document.getElementById('fSelect');
  if(fPrev) fPrev.onclick=()=>goPrev();
  if(fNext) fNext.onclick=()=>goNext();
  if(fGo) fGo.onclick=()=>{ const v=parseInt(fJump?.value||'',10); if(!isNaN(v)){ page=idxFromReal(v); load(); } };
  if(fSelect) fSelect.onclick=()=>toggleSelect();

  function findNext(from){
    for(let i=from+1;i<book.pages.length;i++){
      if(matchFilter(book.pages[i])) return i;
    }
    return from; // no further page under filter
  }
  function findPrev(from){
    for(let i=from-1;i>=0;i--){
      if(matchFilter(book.pages[i])) return i;
    }
    return from; // no previous page under filter
  }
  function matchFilter(p){
    if(customFilterId){ return (p.state?.extra||[]).includes(customFilterId); }
    if(filter==='all') return true;
    if(filter==='fav') return p.state?.fav;
    if(filter==='weak') return p.state?.weak;
    if(filter==='done') return p.state?.done;
    if(filter==='undone') return !p.state?.done;
    if(filter==='hasMemo') return (p.memo||'').trim().length>0;
    return true;
  }

  // multi select ops
  document.getElementById('multiToggle').onclick=()=>{ multi=!multi; selected.clear(); updateThumbs(); showToast(multi?'複数選択ON':'複数選択OFF'); };
  document.getElementById('multiAll').onclick=()=>{ if(!multi) return; selected.clear(); for(let i=0;i<book.pages.length;i++) selected.add(i); updateThumbs(); };
  document.getElementById('multiNone').onclick=()=>{ selected.clear(); updateThumbs(); };
  document.getElementById('multiMove').onclick=()=>{
    if(!selected.size) return showToast('選択がありません','error');
    const to = parseInt(prompt('移動先のインデックス（1始まり, 現在の並びで）'),10);
    if(!to||to<1||to>book.pages.length) return;
    const idxs=[...selected].sort((a,b)=>a-b);
    const block = idxs.map(i=>book.pages[i]);
    // remove from end to preserve indexes
    idxs.reverse().forEach(i=>book.pages.splice(i,1));
    const insertAt = Math.min(book.pages.length, to-1);
    book.pages.splice(insertAt,0,...block);
    Book.put(book).then(()=>{ selected.clear(); page=insertAt; load(); showToast('移動しました','ok'); });
  };
  document.getElementById('multiCopy').onclick=()=>{
    if(!selected.size) return showToast('選択がありません','error');
    const to = parseInt(prompt('コピー先のインデックス（1始まり）'),10);
    if(!to||to<1||to>book.pages.length+1) return;
    const idxs=[...selected].sort((a,b)=>a-b);
    const copies = idxs.map(i=> ({...structuredClone(book.pages[i]), id:uuid()}));
    const insertAt = Math.min(book.pages.length, to-1);
    book.pages.splice(insertAt,0,...copies);
    Book.put(book).then(()=>{ selected.clear(); page=insertAt; load(); showToast('コピーしました','ok'); });
  };
  document.getElementById('multiDelete').onclick=()=>{
    if(!selected.size) return showToast('選択がありません','error');
    if(!confirm('選択したページを削除しますか？')) return;
    const idxs=[...selected].sort((a,b)=>b-a);
    idxs.forEach(i=>book.pages.splice(i,1));
    Book.put(book).then(()=>{ selected.clear(); page=Math.max(0,Math.min(page,book.pages.length-1)); load(); showToast('削除しました','ok'); });
  };
  document.getElementById('multiSet').onclick=()=>{
  document.getElementById('multiNewBook').onclick=()=>{
    if(!selected.size) return showToast('選択がありません','error');
    const modal=document.getElementById('newBookFromSelModal');
    modal.style.display='flex';
    // close on backdrop
    modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; }, {once:true});
    const box=modal.querySelector('.box');
    const nbCreate=modal.querySelector('#nbCreate');
    const nbClose=box.querySelector('[data-close]');
    nbClose.onclick=()=>{ modal.style.display='none'; };
    nbCreate.onclick=async()=>{
      const title=(box.querySelector('#nbTitle').value||'').trim();
      if(!title){ showToast('タイトルを入力してください','error'); return; }
      const tags=(box.querySelector('#nbTags').value||'').split(',').map(s=>s.trim()).filter(Boolean);
      const folder=(box.querySelector('#nbFolder').value||'').trim();
      const remove=box.querySelector('#nbRemove').checked;
      const idxs=[...selected].sort((a,b)=>a-b);
      const pages = idxs.map(i=>{
        const src = book.pages[i];
        return { id: uuid(), dataUrl: src.dataUrl, state: structuredClone(src.state||{fav:false,weak:false,done:false,extra:[]}), memo: src.memo||'' };
      });
      const newBook = { id: uuid(), title, tags, folder, createdAt: Date.now(), pages, firstPageNumber: 1, coverDataUrl: pages[0]?.dataUrl || null, customStates: structuredClone(book.customStates||[]), bookmarks:[], answerBookIds:[] };
      await Book.add(newBook);
      if(remove){
        // delete from original starting from tail
        idxs.sort((a,b)=>b-a).forEach(i=> book.pages.splice(i,1));
        await Book.put(book);
        page = Math.max(0, Math.min(page, book.pages.length-1));
      }
      selected.clear();
      modal.style.display='none';
      showToast('新しい本を作成しました','ok');
      // refresh library silently
      refresh();
    };
  };
  
    if(!selected.size) return showToast('選択がありません','error');
    const m=document.createElement('div'); m.className='modal'; m.style.display='flex';
    const b=document.createElement('div'); b.className='box';
    const csOpts = book.customStates.map(cs=>`<label class='row' style='gap:6px'><input type='checkbox' data-bcs='${cs.id}'> ${escapeHTML(cs.name)}</label>`).join('');
    b.innerHTML=`<h3>選択の状態変更</h3>
      <label class='row' style='gap:6px'><input id='bFav' type='checkbox'> ★お気に入り</label>
      <label class='row' style='gap:6px'><input id='bWeak' type='checkbox'> ×苦手</label>
      <label class='row' style='gap:6px'><input id='bDone' type='checkbox'> ✓完了</label>
      <div class='hr' style='height:1px;background:#1d2738;margin:8px 0'></div>
      <div>カスタム状態</div>
      <div class='split' style='margin:6px 0'>${csOpts||'<span class="muted">（なし）</span>'}</div>
      <div class='row space' style='margin-top:10px'><button class='btn ghost' data-close>閉じる</button><button class='btn primary' data-apply>適用</button></div>`;
    m.appendChild(b); document.body.appendChild(m);
    b.querySelector('[data-close]').onclick=()=>m.remove();
    b.querySelector('[data-apply]').onclick=async()=>{
      const fav=b.querySelector('#bFav').checked;
      const weak=b.querySelector('#bWeak').checked;
      const done=b.querySelector('#bDone').checked;
      const extra=[...b.querySelectorAll('[data-bcs]')].filter(x=>x.checked).map(x=>x.getAttribute('data-bcs'));
      selected.forEach(i=>{
        book.pages[i].state.fav=fav; book.pages[i].state.weak=weak; book.pages[i].state.done=done;
        book.pages[i].state.extra=extra.slice();
      });
      await Book.put(book); m.remove(); updateThumbs(); showToast('状態を更新しました','ok');
    };
  };

  // add/insert
  (function wireInsert(){
    const modal=document.getElementById('pageInsertModal');
    const picker=document.getElementById('insertPicker');
    document.getElementById('insertNowBtn').onclick=async()=>{
      const files=Array.from(picker.files||[]); if(!files.length){ showToast('画像を選んでください','error'); return; }
      const add=[]; for(const f of files){ const d=await fileToDataURL(f); add.push({id:uuid(),dataUrl:d,state:{fav:false,weak:false,done:false,extra:[]},memo:''}); }
      const insertAt = page+1;
      book.pages.splice(insertAt,0,...add);
      await Book.put(book);
      modal.style.display='none'; picker.value=''; page=insertAt; load(); showToast('挿入しました','ok');
    };
    modal.addEventListener('click', (e)=>{ if(e.target===modal) modal.style.display='none'; });
  })();

  // close modals
  document.querySelectorAll('.modal').forEach(m=> m.addEventListener('click',(e)=>{ if(e.target===m) m.style.display='none'; }));
  document.querySelectorAll('[data-close]').forEach(btn=>{
    btn.addEventListener('click',()=>{
      const modal=btn.closest('.modal');
      if(modal) modal.style.display='none';
    });
  });

  // initial
  setFit('contain');
  load();
  renderOpenTabs();
}

/** ===== Viewer (Box) ===== */
function mountBoxViewer(box){
  state.view='viewer';
  state.viewerContext='box';
  state.activeTab='boxes';
  viewerMemory.box.id=box.id;
  viewerMemory.box.closed=false;
  ensureOpenTab('box', box.id, box.name||'無題ボックス');
  const host=document.getElementById('viewerView'); host.innerHTML=''; host.classList.remove('hidden');
  const wrap=document.createElement('div'); wrap.className='viewer';
  wrap.innerHTML=`
    <div class="stage" id="stage">
      <div class="stage-inner">
        <img id="pageImg" alt="snippet" draggable="false"/>
      </div>
    </div>
    <div class="control">
      <div class="row space"><h3 style="margin:0">${escapeHTML(box.name)}</h3><span class="muted">${(box.snippets||[]).length} 件</span></div>
      <div class="toolbar" style="margin-bottom:6px">
        <button class="btn" id="prevBtn">← 前へ</button>
        <button class="btn" id="nextBtn">次へ →</button>
        <button class="btn ghost" id="gridBtn">一覧</button>
        <button class="btn ghost" id="editSnip">切り取りの編集</button>
        <button class="btn" id="renameBox">ボックス編集</button>
      </div>
      <div class="hr" style="height:1px;background:#1d2738;margin:8px 0"></div>
      <div class="list" id="thumbList" style="flex:1"></div>
      <div class="hr" style="height:1px;background:#1d2738;margin:8px 0"></div>
      <button class="btn ghost" id="backBoxes">← ボックス一覧に戻る</button>
    </div>`;
  host.appendChild(wrap);
  let idx=0;
  const img=document.getElementById('pageImg');
  function setSingle(){ 
      document.getElementById('stageSingle').classList.remove('hidden');
      document.getElementById('stageDual').classList.add('hidden');
    }
    function setDual(){
      document.getElementById('stageSingle').classList.add('hidden');
      document.getElementById('stageDual').classList.remove('hidden');
    }
  function load(){ img.src=(box.snippets?.[idx]?.dataUrl)||''; updateThumbs(); }
  function updateThumbs(){
    const list=document.getElementById('thumbList'); list.innerHTML='';
    (box.snippets||[]).forEach((s,i)=>{
      const it=document.createElement('div'); it.className='item'+(i===idx?' active':'');
      const label = s.name ? escapeHTML(s.name) : `切り抜き${i+1}`;
      const marks = s.weak? ' ×' : '';
      it.innerHTML=`<span class="pill">${i+1}</span> <span>${label}</span><span class="muted">${marks}</span>`;
      it.onclick=()=>{ idx=i; load(); };
      list.appendChild(it);
    });
  }
  document.getElementById('prevBtn').onclick=()=>{ idx=(idx-1+(box.snippets?.length||1))%(box.snippets?.length||1); load(); };
  document.getElementById('nextBtn').onclick=()=>{ idx=(idx+1)%(box.snippets?.length||1); load(); };
  document.getElementById('gridBtn').onclick=()=>{
    const m=document.createElement('div'); m.className='modal'; m.style.display='flex';
    const b=document.createElement('div'); b.className='box'; b.style.width='min(880px,96vw)';
    b.innerHTML='<h3>一覧</h3><div class="thumbGrid" id="gridx"></div><div class="row" style="justify-content:flex-end;margin-top:8px"><button class="btn ghost" data-close>閉じる</button></div>';
    m.appendChild(b); document.body.appendChild(m);
    const gx=b.querySelector('#gridx');
    (box.snippets||[]).forEach((s,i)=>{ const d=document.createElement('div'); d.className='thumbCell'; d.innerHTML=`<img src="${s.dataUrl}"/><div class="small">${escapeHTML(s.name||('切り抜き'+(i+1)))}</div>`; d.onclick=()=>{ idx=i; load(); m.remove(); }; gx.appendChild(d); });
    b.querySelector('[data-close]').onclick=()=>m.remove();
  };
  document.getElementById('editSnip').onclick=async()=>{
    if(!box.snippets||!box.snippets.length) return;
    const s=box.snippets[idx];
    const m=document.createElement('div'); m.className='modal'; m.style.display='flex';
    const b=document.createElement('div'); b.className='box';
    b.innerHTML=`<h3>切り取りの編集</h3>
      <input id="snName" class="input" value="${escapeHTML(s.name||'')}" placeholder="名前" style="margin-bottom:8px"/>
      <textarea id="snNote" class="input" placeholder="メモ">${escapeHTML(s.note||'')}</textarea>
      <label class="row" style="gap:8px;margin-top:8px"><input type="checkbox" id="snWeak" ${s.weak?'checked':''}/> 苦手</label>
      <div class="row space" style="margin-top:10px">
        <button class="btn ghost" data-close>閉じる</button>
        <button class="btn primary" data-save>保存</button>
      </div>`;
    m.appendChild(b); document.body.appendChild(m);
    b.querySelector('[data-close]').onclick=()=>m.remove();
    b.querySelector('[data-save]').onclick=async()=>{
      s.name=b.querySelector('#snName').value||'';
      s.note=b.querySelector('#snNote').value||'';
      s.weak=b.querySelector('#snWeak').checked;
      await Box.put(box); m.remove(); load(); showToast('保存しました','ok');
    };
  };
  document.getElementById('renameBox').onclick=()=> editBoxMeta(box);
  document.getElementById('backBoxes').onclick=()=>{ 
    state.view='boxes';
    state.viewerContext=null;
    viewerMemory.box.closed=true;
    viewerMemory.box.id=null;
    host.innerHTML='';
    host.classList.add('hidden'); 
    showTab('boxes'); 
  };
  load();
  renderOpenTabs();
}

/** ===== Upload/Create ===== */
const upload={files:[], setFiles(list){this.files=Array.from(list); renderPreview();}};
function renderPreview(){
  const area=document.getElementById('previewArea'); area.innerHTML='';
  upload.files.forEach((f,i)=>{
    const url=URL.createObjectURL(f);
    const d=document.createElement('div'); d.className='card'; d.draggable=true; d.dataset.idx=i;
    d.innerHTML=`<div class="thumb"><img src="${url}"/></div><div class="meta"><div class="row space"><span class="muted">${escapeHTML(f.name)}</span><span class="pill">${i+1}</span></div></div>`;
    d.ondragstart=(e)=>{ e.dataTransfer.setData('text/plain',i); };
    d.ondragover=(e)=>e.preventDefault();
    d.ondrop=(e)=>{ e.preventDefault(); const from=+e.dataTransfer.getData('text/plain'); const to=+d.dataset.idx; moveFile(from,to); };
    area.appendChild(d);
  });
}
function moveFile(from,to){ if(from===to) return; const arr=upload.files; const item=arr.splice(from,1)[0]; arr.splice(to,0,item); renderPreview(); }
async function createBookFromUpload(){
  const title=(document.getElementById('bookTitle').value||'無題').trim();
  const tags=(document.getElementById('bookTags').value||'').split(',').map(s=>s.trim()).filter(Boolean);
  const folder=(document.getElementById('bookFolder').value||'').trim();
  if(!upload.files.length){showToast('画像を選択してください','error'); return;}
  const pages=[];
  for(const f of upload.files){ const dataUrl=await fileToDataURL(f); pages.push({id:uuid(), dataUrl, state:{fav:false,weak:false,done:false,extra:[]}, memo:''}); }
  const book={id:uuid(), title, tags, folder, createdAt:Date.now(), pages, firstPageNumber:1, coverDataUrl:null, customStates:[], bookmarks:[], answerBookIds:[]};
  await Book.add(book);
  upload.files=[]; renderPreview(); document.getElementById('imagePicker').value='';
  document.getElementById('bookTitle').value=''; document.getElementById('bookTags').value=''; document.getElementById('bookFolder').value='';
  showToast('保存しました','ok'); refresh(); showTab('library');
}
function setupUploadUI(){
  const picker=document.getElementById('imagePicker');
  picker.onchange=(e)=> upload.setFiles(e.target.files);
  document.getElementById('clearImages').onclick=()=>{ upload.files=[]; renderPreview(); picker.value=''; };
  const dz=document.getElementById('dropZone');
  dz.ondragover=(e)=>{ e.preventDefault(); dz.style.background='#0b1322'; };
  dz.ondragleave=()=> dz.style.background='';
  dz.ondrop=(e)=>{ e.preventDefault(); dz.style.background=''; upload.setFiles(e.dataTransfer.files); };
  document.getElementById('createBook').onclick=createBookFromUpload;
}

/** ===== Sidebar ===== */
function renderTags(books){
  const area=document.getElementById('tagArea'); area.innerHTML='';
  const counts=new Map(); books.forEach(b=>(b.tags||[]).forEach(t=>counts.set(t,(counts.get(t)||0)+1)));
  [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0,50).forEach(([t,n])=>{
    const chip=document.createElement('span'); chip.className='chip'; chip.textContent=`${t} (${n})`;
    chip.onclick=()=>{ state.tagFilter=(state.tagFilter===t?null:t); refresh(); };
    if(state.tagFilter===t) chip.style.borderColor='var(--brand)';
    area.appendChild(chip);
  });
}
function renderFolders(books){
  const tree=document.getElementById('folderTree'); tree.innerHTML='';
  const groups=groupBy(books,b=>b.folder||'未分類');
  Object.keys(groups).sort().forEach(f=>{
    const d=document.createElement('div'); d.className='fnode';
    d.innerHTML=`<span class="pill">${groups[f].length}</span> <span>${escapeHTML(f)}</span>`;
    d.onclick=()=>{ state.folderFilter=(state.folderFilter===f?null:f); refresh(); };
    if(state.folderFilter===f) d.style.border='1px solid var(--brand)';
    tree.appendChild(d);
  });
}
function updateHiddenAnswersInfo(hiddenCount){
  const info=document.getElementById('hiddenAnswersInfo');
  if(!info) return;
  if(hiddenCount>0){
    info.textContent = state.showAnswers ? `${hiddenCount}冊` : `${hiddenCount}冊を非表示`;
  }else{
    info.textContent='';
  }
}
async function removeAnswerReferences(bookId){
  if(!bookId) return;
  const books = Array.isArray(window.__allBooksCache) ? window.__allBooksCache : await Book.list();
  let updated=false;
  for(const bk of books){
    if(!Array.isArray(bk.answerBookIds)) continue;
    if(!bk.answerBookIds.includes(bookId)) continue;
    bk.answerBookIds=bk.answerBookIds.filter(id=>id!==bookId);
    await Book.put(bk);
    updated=true;
  }
  if(updated){
    window.__allBooksCache = await Book.list();
  }
}

/** ===== Export/Import ===== */
async function exportData(){
  const books=await Book.list(); const boxes=await Box.list();
  const blob=new Blob([JSON.stringify({books,boxes},null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='study-ebook-backup.json'; a.click(); URL.revokeObjectURL(url);
}
function downloadJSON(obj, filename){
  const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); URL.revokeObjectURL(url);
}
async function exportSingleBook(book){
  if(!book) return;
  downloadJSON({type:'book',version:1,book}, `${(book.title||'book')}.json`);
}
async function exportSingleBox(box){
  if(!box) return;
  downloadJSON({type:'box',version:1,box}, `${(box.name||'box')}.json`);
}
async function importDataFile(file){
  const text=await file.text(); const data=JSON.parse(text);
  if(data.books){ for(const b of data.books){ await Book.put(b) } }
  if(data.boxes){ for(const b of data.boxes){ await Box.put(b) } }
  showToast('インポートしました','ok'); refresh();
}
function normalizeBookShape(book){
  book.pages=book.pages||[];
  book.pages.forEach(p=>{
    p.id=p.id||uuid();
    p.state=p.state||{fav:false,weak:false,done:false,extra:[]};
    if(!Array.isArray(p.state.extra)) p.state.extra=[];
    p.memo=p.memo||'';
  });
  book.id=book.id||uuid();
  book.createdAt=book.createdAt||Date.now();
  book.customStates=book.customStates||[];
  book.bookmarks=book.bookmarks||[];
  book.answerBookIds=book.answerBookIds||[];
  return book;
}
function normalizeBoxShape(box){
  box.snippets=box.snippets||[];
  box.customStates=box.customStates||[];
  box.snippets.forEach(s=>{
    s.id=s.id||uuid();
    s.state=s.state||{fav:false,weak:false,done:false,extra:[]};
    if(!Array.isArray(s.state.extra)) s.state.extra=[];
    s.memo=typeof s.memo==='string'?s.memo:(s.note||'');
    if(!s.answer) s.answer=null;
  });
  box.id=box.id||uuid();
  box.createdAt=box.createdAt||Date.now();
  box.tags=box.tags||[];
  return box;
}
async function importSingleBookFile(file){
  if(!file) return;
  const text=await file.text();
  let parsed=null;
  try{ parsed=JSON.parse(text); }catch(e){ showToast('JSONを読み込めません','error'); return; }
  let book = parsed?.book || parsed;
  if(!book || !book.pages){ showToast('本データではありません','error'); return; }
  book = normalizeBookShape(book);
  const existing = await Book.get(book.id);
  if(existing){
    const overwrite = confirm('同じIDの本があります。上書きしますか？キャンセルで新規IDとして追加します。');
    if(!overwrite){ book.id=uuid(); }
  }
  await Book.put(book);
  showToast('本をインポートしました','ok');
  refresh();
}
async function importSingleBoxFile(file){
  if(!file) return;
  const text=await file.text();
  let parsed=null;
  try{ parsed=JSON.parse(text); }catch(e){ showToast('JSONを読み込めません','error'); return; }
  let box = parsed?.box || parsed;
  if(!box || !Array.isArray(box.snippets)){ showToast('ボックスデータではありません','error'); return; }
  box = normalizeBoxShape(box);
  const existing = await Box.get(box.id);
  if(existing){
    const overwrite = confirm('同じIDのボックスがあります。上書きしますか？キャンセルで新規IDとして追加します。');
    if(!overwrite){ box.id=uuid(); }
  }
  await Box.put(box);
  showToast('ボックスをインポートしました','ok');
  renderBoxes();
}
async function resetAllData(){
  if(!confirm('全データ（本・ボックス・設定）を完全に削除します。よろしいですか？')) return;
  try{ localStorage.clear(); }catch(e){}
  await new Promise((resolve)=>{ const req=indexedDB.deleteDatabase(DB_NAME); req.onsuccess=req.onerror=req.onblocked=()=>resolve(); });
  location.reload();
}
async function resetLibraryOnly(){
  if(!confirm('ライブラリ内の本をすべて削除します。よろしいですか？')) return;
  const books=await Book.list();
  for(const b of books){ await Book.del(b.id); }
  openTabsState.splice(0, openTabsState.length, ...openTabsState.filter(t=>t.type!=='book'));
  activeOpenTabId=openTabsState[0]?.key||null;
  persistOpenTabs(); renderOpenTabs();
  refresh();
  const viewerEl=document.getElementById('viewerView');
  if(viewerEl){ viewerEl.innerHTML=''; viewerEl.classList.add('hidden'); }
  state.viewerContext=null;
  showTab('library');
  showToast('ライブラリをリセットしました','ok');
}
async function resetBoxesOnly(){
  if(!confirm('ボックスをすべて削除します。よろしいですか？')) return;
  const boxes=await Box.list();
  for(const bx of boxes){ await Box.del(bx.id); }
  openTabsState.splice(0, openTabsState.length, ...openTabsState.filter(t=>t.type!=='box'));
  activeOpenTabId=openTabsState[0]?.key||null;
  persistOpenTabs(); renderOpenTabs();
  renderBoxes();
  const viewerEl=document.getElementById('viewerView');
  if(viewerEl){ viewerEl.innerHTML=''; viewerEl.classList.add('hidden'); }
  state.viewerContext=null;
  showTab('boxes');
  showToast('ボックスをリセットしました','ok');
}

/** ===== Global Wiring ===== */
const plannerTabIds=['planner'];
function showTab(id){
  const tabIds=['library','boxes','uploader','settings'];
  const readerLayout=document.getElementById('readerLayout');
  const plannerApp=document.getElementById('plannerApp');
  const isPlanner = plannerTabIds.includes(id);
  if(isPlanner){
    state.activeTab=id;
    activeOpenTabId=null;
    renderOpenTabs();
    persistOpenTabs();
  }else if(tabIds.includes(id)){
    state.activeTab=id;
    activeOpenTabId=null;
    renderOpenTabs();
    persistOpenTabs();
  }
  if(tabIds.includes(id)){
    if(plannerApp) plannerApp.classList.add('hidden');
    if(readerLayout) readerLayout.classList.remove('hidden');
  }
  document.querySelectorAll('#tabs .tab').forEach(t=> t.classList.toggle('active', t.dataset.tab===id));
  if(isPlanner){
    if(readerLayout) readerLayout.classList.add('hidden');
    if(plannerApp) plannerApp.classList.remove('hidden');
    document.body.classList.remove('reading');
    window.__plannerStyles?.enable?.();
    if(window.__setPlannerTheme) window.__setPlannerTheme();
    window.__activatePlannerTab?.(window.__plannerLastTab?.() || id);
    return;
  }
  const isLibrary = id==='library';
  const isBoxes = id==='boxes';
  const isUploader = id==='uploader';
  const isSettings = id==='settings';
  const viewerEl=document.getElementById('viewerView');
  const viewerActive = viewerEl && viewerEl.children.length>0;

  const libraryEl=document.getElementById('libraryView');
  const boxesEl=document.getElementById('boxesView');
  const uploadEl=document.getElementById('uploadView');
  const settingsEl=document.getElementById('settingsView');

  // viewerは対応タブに応じて表示（ライブラリ=book, ボックス=box）
  const showViewer = viewerActive && ((isLibrary && state.viewerContext==='book') || (isBoxes && state.viewerContext==='box'));
  if(viewerEl) viewerEl.classList.toggle('hidden', !showViewer);

  if(libraryEl) libraryEl.classList.toggle('hidden', !isLibrary || showViewer);
  if(boxesEl) boxesEl.classList.toggle('hidden', !isBoxes || showViewer);
  if(uploadEl) uploadEl.classList.toggle('hidden', !isUploader);
  if(settingsEl) settingsEl.classList.toggle('hidden', !isSettings);
  if(showViewer){ document.body.classList.add('reading'); }else{ document.body.classList.remove('reading'); }

  if(isBoxes) renderBoxes();
}
function wireGlobal(){
  document.getElementById('sortSelect').onchange=(e)=>{ state.sort=e.target.value; refresh(); };
  document.querySelectorAll('.toggle .btn').forEach(b=> b.onclick=()=>{ state.viewMode=b.dataset.view; refresh(); });
  const showAnswersToggle=document.getElementById('showAnswersToggle');
  if(showAnswersToggle){
    showAnswersToggle.checked=state.showAnswers;
    showAnswersToggle.onchange=(e)=>{
      state.showAnswers=e.target.checked;
      saveStoredBool(LIBRARY_SHOW_ANSWERS_KEY, state.showAnswers);
      refresh();
    };
  }
  document.getElementById('quickMake').onclick=()=> showTab('uploader');
  document.getElementById('exportBtn').onclick=exportData;
  document.getElementById('importBtn').onclick=()=> document.getElementById('importFile').click();
  document.getElementById('importFile').onchange=(e)=> e.target.files[0]&&importDataFile(e.target.files[0]);
  document.getElementById('resetAllBtn').onclick=resetAllData;
  document.getElementById('resetLibraryBtn').onclick=resetLibraryOnly;
  document.getElementById('resetBoxesBtn').onclick=resetBoxesOnly;
  document.getElementById('importBookSingleBtn').onclick=()=> document.getElementById('importBookSingleFile').click();
  document.getElementById('importBookSingleFile').onchange=(e)=> e.target.files[0]&&importSingleBookFile(e.target.files[0]);
  document.getElementById('importBoxSingleBtn').onclick=()=> document.getElementById('importBoxSingleFile').click();
  document.getElementById('importBoxSingleFile').onchange=(e)=> e.target.files[0]&&importSingleBoxFile(e.target.files[0]);
  document.getElementById('searchInput').oninput=(e)=>{ state.search=e.target.value; refresh(); };
  document.addEventListener('keydown',(e)=>{ if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='k'){ e.preventDefault(); document.getElementById('searchInput').focus(); } });
  const perfToggle=document.getElementById('perfModeToggle');
  if(perfToggle){ perfToggle.checked=loadStoredBool(PERF_MODE_KEY,false); perfToggle.onchange=(e)=>applyPerfMode(e.target.checked); }

  // tabs
  document.querySelectorAll('#tabs .tab').forEach(t=> t.onclick=async()=>{
    const id=t.dataset.tab;
    if(plannerTabIds.includes(id)){
      showTab(id);
      return;
    }
    const currentlyOnLibrary = state.activeTab==='library';
    const currentlyOnBoxes = state.activeTab==='boxes';
    const libraryViewerOpen = state.viewerContext==='book' && currentlyOnLibrary;
    const boxViewerOpen = state.viewerContext==='box' && currentlyOnBoxes;

    // ライブラリで閲覧中に再度ライブラリを押した場合のみ一覧へ戻す（状態は閉じる）
    if(id==='library' && libraryViewerOpen){
      viewerMemory.book.closed=true;
      viewerMemory.book.id=null;
      state.viewerContext=null;
      const viewerEl=document.getElementById('viewerView');
      if(viewerEl){ viewerEl.innerHTML=''; }
      document.body.classList.remove('reading');
      showTab('library');
      return;
    }
    // ボックスで閲覧中に再度ボックスを押した場合は一覧へ戻す（状態は閉じる）
    if(id==='boxes' && boxViewerOpen){
      viewerMemory.box.closed=true;
      viewerMemory.box.id=null;
      state.viewerContext=null;
      const viewerEl=document.getElementById('viewerView');
      if(viewerEl){ viewerEl.innerHTML=''; }
      showTab('boxes');
      return;
    }

    showTab(id);

    // タブ切り替え後に前回のビューを自動復帰
    if(id==='library' && viewerMemory.book.id && !viewerMemory.book.closed && state.viewerContext!=='book'){
      const book=await Book.get(viewerMemory.book.id);
      if(book) mountBookViewer(book);
    }
    if(id==='boxes' && viewerMemory.box.id && !viewerMemory.box.closed && state.viewerContext!=='box'){
      const box=await Box.get(viewerMemory.box.id);
      if(box) window.mountBoxViewer && mountBoxViewer(box);
    }
  });

  // Boxes toolbar
  const bs=document.getElementById('boxSearch');
  const bsort=document.getElementById('boxSort');
  const bweak=document.getElementById('onlyWeakBox');
  const bnew=document.getElementById('newBoxToolbar');
  if(bs){ bs.oninput=()=>renderBoxes(); }
  if(bsort){ bsort.onchange=()=>renderBoxes(); }
  if(bweak){ bweak.onchange=()=>renderBoxes(); }
  if(bnew){ bnew.onclick=()=>{ document.getElementById('newBoxModal').style.display='flex'; }; }

  // delegate clicks in main
  document.getElementById('main').addEventListener('click', async (e)=>{
    const btn=e.target.closest('button'); if(!btn) return;
    if(btn.dataset.open){ const book=await Book.get(btn.dataset.open); mountBookViewer(book); }
    if(btn.dataset.edit){ const book=await Book.get(btn.dataset.edit); editBookMeta(book); }
    if(btn.dataset.del){
      const id=btn.dataset.del;
      const target=await Book.get(id);
      if(confirm('本を削除しますか？')){
        await Book.del(id);
        await removeAnswerReferences(id);
        refresh(); showToast('削除しました');
      }
    }
    
    if(btn.dataset.dup){
      const id = btn.dataset.dup;
      const original = await Book.get(id);
      if(!original){ showToast('本が見つかりません','error'); return; }
      const copy = structuredClone(original);
      copy.id = uuid();
      copy.title = (original.title || '無題') + ' のコピー';
      copy.createdAt = Date.now();
      // ensure page ids are unique
      const pageIdMap=new Map();
      copy.pages = (original.pages||[]).map(p=>{
        const newId=uuid();
        pageIdMap.set(p.id,newId);
        return { id: newId, dataUrl: p.dataUrl, state: structuredClone(p.state||{fav:false,weak:false,done:false,extra:[]}), memo: p.memo||'' };
      });
      copy.customStates = structuredClone(original.customStates||[]);
      copy.bookmarks = (original.bookmarks||[]).map(bm=>({
        id:uuid(),
        label:bm.label,
        page:bm.page||0,
        pageId:bm.pageId && pageIdMap.get(bm.pageId) || null
      }));
      await Book.add(copy);
      showToast('複製を作成しました','ok');
      refresh();
    }

    if(btn.dataset.openBox){ const box=await Box.get(btn.dataset.openBox); mountBoxViewer(box); }
    if(btn.dataset.editBox){ const box=await Box.get(btn.dataset.editBox); editBoxMeta(box); }
    if(btn.dataset.delBox){
      const id=btn.dataset.delBox;
      const bx=await Box.get(id);
      if(confirm('ボックスを削除しますか？')){
        await Box.del(id);
        renderBoxes();
      }
    }
  });

  // main mode button（通常/メイン の2状態）
  const mainBtn=document.getElementById('mainModeBtn');
  const toggleMain=()=>{
    const active=document.body.classList.toggle('mainmode2');
    document.body.classList.remove('mainmode');
    mainBtn.textContent = active ? '通常表示' : 'メイン';
    const fb=document.getElementById('floatbar');
    if(fb){ fb.classList.add('hidden'); }
  };
  mainBtn.onclick=toggleMain;
  document.addEventListener('keydown',(e)=>{ if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='m'){ e.preventDefault(); toggleMain(); } });
}

function editBookMeta(book){
  const m=document.createElement('div'); m.className='modal'; m.style.display='flex';
  const b=document.createElement('div'); b.className='box'; b.style.width='min(700px,96vw)';
  b.innerHTML=`<h3>本の情報を編集</h3>
  <label>タイトル</label><input id="t" class="input" value="${escapeHTML(book.title)}" style="margin-bottom:8px"/>
  <label>タグ（カンマ区切り）</label><input id="g" class="input" value="${escapeHTML((book.tags||[]).join(', '))}" style="margin-bottom:8px"/>
  <label>フォルダ</label><input id="f" class="input" value="${escapeHTML(book.folder||'')}" style="margin-bottom:8px"/>
  <label>実ページの開始番号（最初は何ページ目か）</label><input id="p0" type="number" class="input" value="${book.firstPageNumber||1}" style="margin-bottom:8px"/>
  <label>表紙画像（任意）</label><input id="coverFile" type="file" accept="image/*" class="input" style="margin-bottom:8px"/>
  <div class="row" style="gap:6px;margin-top:6px">
    <button class="btn" id="recalcReal">実ページ番号を再表示</button>
  </div>
  <div class="row" style="justify-content:space-between;gap:8px;margin-top:8px">
    <button class="btn ghost" data-close>閉じる</button>
    <div class="row" style="gap:8px">
      <button class="btn ghost" id="exportThisBook">この本をエクスポート</button>
      <button class="btn primary" data-save>保存</button>
    </div>
  </div>`;
  m.appendChild(b); document.body.appendChild(m);
  b.querySelector('[data-close]').onclick=()=>m.remove();
  b.querySelector('#recalcReal').onclick=()=>{ showToast('ページ一覧の表示を更新します'); };
  b.querySelector('#exportThisBook').onclick=()=>exportSingleBook(book);
  b.querySelector('[data-save]').onclick=async()=>{
    book.title=b.querySelector('#t').value.trim();
    book.tags=b.querySelector('#g').value.split(',').map(s=>s.trim()).filter(Boolean);
    book.folder=b.querySelector('#f').value.trim();
    book.firstPageNumber=parseInt(b.querySelector('#p0').value,10)||1;
    const file=b.querySelector('#coverFile').files?.[0];
    if(file){ book.coverDataUrl = await fileToDataURL(file); }
    await Book.put(book); m.remove(); refresh(); showToast('更新しました','ok');
  };
}

async function refresh(){
  const books=await Book.list();
  window.__allBooksCache = books;
  hiddenAnswerIdsCache = collectHiddenAnswerIds(books);
  const visible = state.showAnswers ? books : books.filter(b=>!hiddenAnswerIdsCache.has(b.id));
  renderTags(visible);
  renderFolders(visible);
  renderLibrary(visible);
  updateHiddenAnswersInfo(hiddenAnswerIdsCache.size);
}

// boot
dbReady.then(async ()=>{ 
  wireGlobal(); 
  setupUploadUI(); 
  await refresh(); 
  const restored = await restoreOpenTabs();
  if(!restored) renderOpenTabs();
});
</script>

  <div class="modal" id="newBookFromSelModal">
    <div class="box">
      <h3>選択ページから新しい本を作成</h3>
      <input id="nbTitle" class="input" placeholder="タイトル（必須）" style="margin-bottom:8px"/>
      <input id="nbTags" class="input" placeholder="タグ（カンマ区切り, 任意）" style="margin-bottom:8px"/>
      <input id="nbFolder" class="input" placeholder="フォルダ（任意）" style="margin-bottom:8px"/>
      <label class="row" style="gap:8px;margin:6px 0"><input id="nbRemove" type="checkbox"/> 元の本から選択ページを削除する</label>
      <div class="row space" style="margin-top:10px">
        <button class="btn ghost" data-close>閉じる</button>
        <button class="btn primary" id="nbCreate">作成</button>
      </div>
    </div>
  </div>

<!-- Box viewer parity override -->
<script>
(function(){
  if(!window) return;
  const True = true; // guard for minifier edge-cases

  // helper to ensure structure
  function _ensureSnippetShape(box){
    box.snippets = box.snippets || [];
    box.customStates = box.customStates || [];
    box.snippets.forEach(s=>{
      s.state = s.state || {fav:false, weak:false, done:false, extra:[]};
      if(!Array.isArray(s.state.extra)) s.state.extra = [];
      if(typeof s.memo!=='string') s.memo = (s.note||'');
      if(!s.answer) s.answer = null;
    });
  }

  // If selection → Box 追加する処理が古い形なら、追加時にstate/memoを補完する軽いパッチ
  try{
    const origAddSel = window.addSelectionToBox;
    if(typeof origAddSel === 'function'){
      window.addSelectionToBox = async function(bx, payload){
        const r = await origAddSel.apply(this, arguments);
        try{ _ensureSnippetShape(bx); if(window.Box && Box.put) await Box.put(bx); }catch(e){}
        return r;
      }
    }
  }catch(e){}

  // CSS: 必要最低限（tag/dragover等）
const css = `.item.dragover{outline:2px dashed #3a5aa0}
  .tag{display:inline-flex;align-items:center;gap:4px;border:1px solid #2a3a55;border-radius:999px;padding:1px 6px;font-size:12px;background:#0f1b30}
  .tag .x{cursor:pointer;opacity:.75}`;
  const st = document.createElement('style'); st.textContent = css; document.head.appendChild(st);
  // pan/zoom surface (available even if book viewer hasn't run yet)
  const normalizeWheelDeltaCompat = (delta, mode)=>{
    if(mode===1) return delta*28;
    if(mode===2) return delta*80;
    return delta;
  };
  const touchDistanceCompat = (a,b)=>{
    const dx=a.clientX-b.clientX;
    const dy=a.clientY-b.clientY;
    return Math.hypot(dx,dy);
  };
  function createPanZoomSurfaceCompat(options={}){
    const {
      element,
      anchorFromClient=(x,y)=>({x,y}),
      getEnabled=()=>true,
      getZoom=()=>1,
      setZoom=()=>{},
      getZoomLocked=()=>false,
      getPanLocked=()=>false,
      applyPanDelta=()=>{},
      onPanStart=()=>{},
      onPanEnd=()=>{},
      onReset=()=>{},
      shouldIgnoreTarget=()=>false,
      doubleTapThreshold=350,
      doubleTapDistance=28,
      doubleTapResetEnabled=true
    }=options||{};
    if(!element) return {destroy:()=>{}};
    let dragging=false;
    let pointerId=null;
    let lastPointer=null;
    let pinchActive=false;
    let pinchStartDist=0;
    let pinchStartZoom=1;
    let pinchAnchor=null;
    let lastTapTime=0;
    let lastTapPos=null;
    const cleanup=[];
    const add=(target,type,handler,opts)=>{
      if(!target) return;
      target.addEventListener(type,handler,opts);
      cleanup.push(()=>target.removeEventListener(type,handler,opts));
    };
    const canInteract=(target)=> getEnabled() && !shouldIgnoreTarget(target);
    // 慣性の強さを調整（軽いドラッグでも反応）
    const MIN_SPEED=0.00003;
    const DECAY=0.94;
    const BOOST=1.1;
    const MAX_SPEED=1.4;
    let velocity={x:0,y:0};
    let lastMoveTime=0;
    let momentumId=null;
    const clampVel=(v)=>Math.max(-MAX_SPEED, Math.min(MAX_SPEED, v));
    const stopMomentum=(resetVelocity=true)=>{
      if(momentumId){ cancelAnimationFrame(momentumId); momentumId=null; }
      if(resetVelocity) velocity={x:0,y:0};
    };
    const startMomentum=()=>{
      if(getPanLocked() || !getEnabled()) return;
      const releaseVel={...velocity};
      stopMomentum(false);
      velocity.x=clampVel(releaseVel.x);
      velocity.y=clampVel(releaseVel.y);
      const speed=Math.max(Math.abs(velocity.x), Math.abs(velocity.y));
      if(speed<MIN_SPEED){
        stopMomentum();
        return;
      }
      let lastTs=performance.now();
      const step=(ts)=>{
        const dt=Math.max(1, ts-lastTs);
        lastTs=ts;
        velocity.x=clampVel(velocity.x*DECAY);
        velocity.y=clampVel(velocity.y*DECAY);
        applyPanDelta(velocity.x*dt*BOOST, velocity.y*dt*BOOST);
        if(Math.max(Math.abs(velocity.x), Math.abs(velocity.y))<MIN_SPEED){
          stopMomentum();
          return;
        }
        momentumId=requestAnimationFrame(step);
      };
      momentumId=requestAnimationFrame(step);
    };
    const stopDrag=(withMomentum=false)=>{
      if(!dragging) return;
      dragging=false;
      if(pointerId!==null){
        try{ element.releasePointerCapture(pointerId); }catch(err){}
      }
      pointerId=null;
      if(withMomentum){ startMomentum(); } else { stopMomentum(); }
      onPanEnd();
    };
    const supportsPointer = typeof window!=='undefined' && 'PointerEvent' in window;
    const pointerDown=(e)=>{
      if(!canInteract(e.target)) return;
      if(getPanLocked()) return;
      if(e.pointerType!=='touch' && e.button!==0) return;
      if(e.pointerType==='touch' && pinchActive) return;
      dragging=true;
      pointerId=e.pointerId;
      lastPointer={x:e.clientX,y:e.clientY};
      lastMoveTime=performance.now();
      velocity={x:0,y:0};
      stopMomentum();
      onPanStart();
      try{ element.setPointerCapture(e.pointerId); }catch(err){}
      e.preventDefault();
    };
    const pointerMove=(e)=>{
      if(!dragging || e.pointerId!==pointerId) return;
      if(getPanLocked()){ stopDrag(); try{ element.releasePointerCapture(e.pointerId); }catch(err){} return; }
      const dx=e.clientX-(lastPointer?.x||e.clientX);
      const dy=e.clientY-(lastPointer?.y||e.clientY);
      lastPointer={x:e.clientX,y:e.clientY};
      if(dx!==0 || dy!==0){
        const now=performance.now();
        const dt=Math.max(1, now-lastMoveTime);
        velocity.x=clampVel(dx/dt);
        velocity.y=clampVel(dy/dt);
        lastMoveTime=now;
        applyPanDelta(dx,dy);
      }
      e.preventDefault();
    };
    const pointerEnd=(e)=>{
      if(e.pointerId!==pointerId) return;
      stopDrag(true);
    };
    const pointerLost=()=>{ stopDrag(); };
    const mouseDown=(e)=>{
      if(!canInteract(e.target)) return;
      if(getPanLocked()) return;
      if(e.button!==0) return;
      dragging=true;
      lastPointer={x:e.clientX,y:e.clientY};
      lastMoveTime=performance.now();
      velocity={x:0,y:0};
      stopMomentum();
      onPanStart();
      e.preventDefault();
    };
    const mouseMove=(e)=>{
      if(!dragging) return;
      if(getPanLocked()){ stopDrag(); return; }
      const dx=e.clientX-(lastPointer?.x||e.clientX);
      const dy=e.clientY-(lastPointer?.y||e.clientY);
      lastPointer={x:e.clientX,y:e.clientY};
      if(dx!==0 || dy!==0){
        const now=performance.now();
        const dt=Math.max(1, now-lastMoveTime);
        velocity.x=clampVel(dx/dt);
        velocity.y=clampVel(dy/dt);
        lastMoveTime=now;
        applyPanDelta(dx,dy);
      }
    };
    const mouseUp=()=>{ if(!dragging) return; stopDrag(true); };
    if(supportsPointer){
      add(element,'pointerdown', pointerDown);
      add(element,'pointermove', pointerMove);
      add(element,'pointerup', pointerEnd);
      add(element,'pointercancel', pointerEnd);
      add(element,'lostpointercapture', pointerLost);
    }else{
      add(element,'mousedown', mouseDown);
      add(document,'mousemove', mouseMove);
      add(document,'mouseup', mouseUp);
    }
    const wheelHandler=(e)=>{
      if(!canInteract(e.target)) return;
      if(!getEnabled()) return;
      e.preventDefault();
      const deltaMode=e.deltaMode||0;
      const deltaY=normalizeWheelDeltaCompat(e.deltaY, deltaMode);
      const deltaX=normalizeWheelDeltaCompat(e.deltaX, deltaMode);
      if(getZoomLocked()){
        if(getPanLocked()) return;
        const prioritizeX = e.shiftKey || Math.abs(deltaX)>Math.abs(deltaY);
        if(prioritizeX){ applyPanDelta(-deltaX,0); }
        else{ applyPanDelta(0,-deltaY); }
        return;
      }
      const anchor=anchorFromClient(e.clientX,e.clientY);
      const scale=Math.exp(-e.deltaY/400);
      setZoom(getZoom()*scale,{anchor});
    };
    add(element,'wheel', wheelHandler,{passive:false});
    const dblHandler=(e)=>{
      if(!canInteract(e.target)) return;
      if(!getEnabled() || getZoomLocked()) return;
      e.preventDefault();
      onReset();
    };
    add(element,'dblclick', dblHandler);
    const touchStart=(e)=>{
      if(!getEnabled()) return;
      if(shouldIgnoreTarget(e.target)) return;
      if(e.touches.length===2){
        if(getZoomLocked()) return;
        stopDrag();
        pinchActive=true;
        pinchStartDist=touchDistanceCompat(e.touches[0], e.touches[1])||1;
        pinchStartZoom=getZoom();
        const midX=(e.touches[0].clientX+e.touches[1].clientX)/2;
        const midY=(e.touches[0].clientY+e.touches[1].clientY)/2;
        pinchAnchor=anchorFromClient(midX, midY);
        e.preventDefault();
      }
    };
    const touchMove=(e)=>{
      if(!getEnabled()) return;
      if(pinchActive && e.touches.length===2){
        if(getZoomLocked()){ pinchActive=false; return; }
        e.preventDefault();
        const dist=touchDistanceCompat(e.touches[0], e.touches[1])||1;
        const scale=dist/(pinchStartDist||dist);
        setZoom(pinchStartZoom*scale,{anchor:pinchAnchor});
      }
    };
    const touchEnd=(e)=>{
      if(!getEnabled()) return;
      if(shouldIgnoreTarget(e.target)){
        lastTapTime=0;
        lastTapPos=null;
        return;
      }
      if(e.touches.length<2) pinchActive=false;
      if(e.touches.length===0 && e.changedTouches.length===1){
        const now=Date.now();
        const tap=e.changedTouches[0];
        const dist=lastTapPos ? Math.hypot(tap.clientX-lastTapPos.x, tap.clientY-lastTapPos.y) : 0;
        if(doubleTapResetEnabled && !getZoomLocked() && !dragging && !pinchActive && now-lastTapTime<doubleTapThreshold && dist<doubleTapDistance){
          onReset();
          e.preventDefault();
        }
        lastTapTime=now;
        lastTapPos={x:tap.clientX,y:tap.clientY};
      }
    };
    add(element,'touchstart', touchStart,{passive:false});
    add(element,'touchmove', touchMove,{passive:false});
    add(element,'touchend', touchEnd,{passive:false});
    add(element,'touchcancel', touchEnd,{passive:false});
    const cancelInteractions=()=>{
      pinchActive=false;
      stopDrag();
    };
    return {destroy:()=>cleanup.forEach(fn=>fn()), cancel:cancelInteractions};
  }
  const getPanZoomSurface = ()=>{
    if(typeof window.createPanZoomSurface === 'function') return window.createPanZoomSurface;
    window.createPanZoomSurface = createPanZoomSurfaceCompat;
    return window.createPanZoomSurface;
  };

  // ==== OVERRIDE ====
  window.mountBoxViewer = function(box){
    state.view='viewer';
    state.viewerContext='box';
    state.activeTab='boxes';
    viewerMemory.box.id=box.id;
    viewerMemory.box.closed=false;
    ensureOpenTab('box', box.id, box.name||'無題ボックス');
    const host=document.getElementById('viewerView'); if(!host) return;
    host.innerHTML=''; host.classList.remove('hidden');

    _ensureSnippetShape(box);

    // hide list while viewing box (match book viewer behavior)
    const libraryEl=document.getElementById('libraryView');
    const boxesEl=document.getElementById('boxesView');
    libraryEl?.classList.add('hidden');
    boxesEl?.classList.add('hidden');
    document.body.classList.add('reading');

    const wrap=document.createElement('div'); wrap.className='viewer box-viewer';
    wrap.innerHTML = `
      <div id="stageHost" class="stage-host">
        <div class="stage-buttons left">
          <button class="mini-menu" id="stageMenuBtn" aria-label="メニュー">☰</button>
          <button class="mini-menu" id="zoomLockBtn" aria-label="ズームロック">🔒ズ</button>
          <button class="mini-menu" id="panLockBtn" aria-label="移動ロック">🔒移</button>
          <button class="mini-menu" id="sliceViewBtn" aria-label="ハーフ表示">半切</button>
          <button class="mini-menu" id="boxAnswerQuickBtn" aria-label="解答ウィンドウ">解答</button>
          <button class="mini-menu hidden" id="boxAnswerDockFloatBtn" aria-label="解答ウィンドウを再表示">解答↺</button>
        </div>
        <div class="stage-buttons right">
          <button class="mini-menu" id="memoMiniBtn" aria-label="メモ">📝</button>
          <div class="page-badge" id="pageBadge"></div>
        </div>
      <div class="stage" id="stageSingle">
        <div class="stage-inner">
          <img id="pageImg" alt="snippet" draggable="false"/>
          <div class="interaction-hint" id="interactionHint">ホイール＝ズーム / ドラッグ＝移動 / ダブルクリック＝リセット</div>
          <div class="stage-arrows">
            <button class="stage-arrow" id="stagePrevArrow" aria-label="前へ">‹</button>
            <button class="stage-arrow" id="stageNextArrow" aria-label="次へ">›</button>
          </div>
        </div>
      </div>
    </div>
    <div class="book-menu compact" id="bookMenuPanel">
        <div class="menu-header" id="menuDragHandle">
          <span></span>
          <button id="menuCloseBtn" aria-label="閉じる">×</button>
        </div>
        <div class="menu-body">
          <div class="menu-actions" id="menuActions"></div>
        </div>
      </div>
      <div class="memo-window" id="memoWindow">
        <div class="memo-header" id="memoWindowDrag">
          <span>メモ</span>
          <button id="memoWindowClose" aria-label="閉じる">×</button>
        </div>
        <textarea id="memoWindowInput" placeholder="この切り抜きのメモ"></textarea>
      </div>
      <div class="compare-window" id="boxAnswerWindow">
        <div class="compare-header" id="boxAnswerDrag">
          <span class="compare-title" id="boxAnswerTitle">解答</span>
          <div class="compare-quick">
            <button class="mini-menu" id="boxAnswerZoomLock" aria-label="ズームロック">🔓ズ</button>
            <button class="mini-menu" id="boxAnswerPanLock" aria-label="移動ロック">🔓移</button>
            <button class="mini-menu" id="boxAnswerTransparent" aria-label="透明切替">透明</button>
            <button class="mini-menu" id="boxAnswerMinimize" aria-label="最小化">＿</button>
            <button class="mini-menu" id="boxAnswerClose" aria-label="閉じる">×</button>
          </div>
        </div>
        <div class="compare-body">
          <div class="compare-stage" id="boxAnswerStage">
            <span class="compare-placeholder" id="boxAnswerPlaceholder">紐付け解答なし</span>
            <img id="boxAnswerImg" alt="解答" draggable="false"/>
          </div>
          <div class="compare-controls">
            <span class="compare-meta" id="boxAnswerMeta">紐付け解答なし</span>
          </div>
        </div>
      </div>
      <div class="control-resizer" id="controlResizer" role="separator" aria-label="右パネル幅を変更"></div>
      <div class="control">
        <div class="row space">
          <div>
            <h3 style="margin:0">${(window.escapeHTML?escapeHTML:(s=>s))(box.name||'無題ボックス')}</h3>
            <span class="muted">${(box.snippets||[]).length} 件</span>
          </div>
          <div class="row" style="gap:6px">
            <button class="btn small ghost" id="bookMenuBtn">☰ メニュー</button>
            <button class="btn small ghost" id="renameBox">ボックス編集</button>
          </div>
        </div>

        <div class="statebar">
          <label class="row" style="gap:6px"><input type="checkbox" id="stFav"> ★お気に入り</label>
          <label class="row" style="gap:6px"><input type="checkbox" id="stWeak"> ×苦手</label>
          <label class="row" style="gap:6px"><input type="checkbox" id="stDone"> ✓完了</label>
          <div id="customStateArea" class="row" style="gap:6px;flex-wrap:wrap"></div>
          <button class="btn small ghost" id="addState">+ 状態を作成</button>
        </div>

        <div class="memo-panel">
          <button class="btn small ghost" id="memoToggle">メモ欄を開く</button>
          <div class="memo-body hidden" id="memoBody">
            <textarea id="pageMemo" class="input" placeholder="この切り抜きのメモ"></textarea>
          </div>
        </div>

        <div class="toolbar" style="margin:8px 0;flex-wrap:wrap">
          <select id="filterSelect" class="input" style="max-width:180px">
            <option value="all">すべて表示</option>
            <option value="fav">★のみ</option>
            <option value="weak">×のみ</option>
            <option value="undone">未完了のみ</option>
            <option value="done">完了のみ</option>
            <option value="hasMemo">メモありのみ</option>
          </select>
          <select id="customFilter" class="input" style="max-width:180px"><option value="">カスタム状態（任意）</option></select>

          <button class="btn" id="prevBtn">← 前へ</button>
          <button class="btn" id="nextBtn">次へ →</button>
          <input class="input" id="jumpInput" placeholder="番号" style="width:100px"/>
          <button class="btn" id="jumpGo">移動</button>
          <button class="btn ghost" id="fitContain">フィット</button>
          <button class="btn ghost" id="fitWidth">幅フィット</button>
          <button class="btn ghost" id="answerWindowBtn">解答を見る</button>
          <button class="btn ghost hidden" id="boxAnswerDockBtn">解答ウィンドウを再表示</button>
        </div>

        <div class="toolbar" style="margin-bottom:6px;flex-wrap:wrap">
          <button class="btn small" id="multiToggle">□ 複数選択</button>
          <button class="btn small ghost" id="multiAll">すべて選択</button>
          <button class="btn small ghost" id="multiNone">選択解除</button>
          <button class="btn small" id="multiSet">選択の状態を変更</button>
          <button class="btn small danger" id="multiDelete">選択を削除</button>
        </div>

        <div class="list" id="thumbList" style="flex:1"></div>
        <div class="hr" style="height:1px;background:#1d2738;margin:8px 0"></div>
        <div class="row space">
          <button class="btn ghost" id="backBoxes">← ボックス一覧に戻る</button>
          <span class="muted" id="idxInfo"></span>
        </div>
      </div>`;
    host.appendChild(wrap);

    // refs
    const stageHost=document.getElementById('stageHost');
    const stage=document.getElementById('stageSingle');
    const stagePrevArrow=document.getElementById('stagePrevArrow');
    const stageNextArrow=document.getElementById('stageNextArrow');
    const pageImg=document.getElementById('pageImg');
    const pageBadge=document.getElementById('pageBadge');
    const interactionHint=document.getElementById('interactionHint');
    const zoomLockBtn=document.getElementById('zoomLockBtn');
    const panLockBtn=document.getElementById('panLockBtn');
    const sliceViewBtn=document.getElementById('sliceViewBtn');
    const boxAnswerQuickBtn=document.getElementById('boxAnswerQuickBtn');
    const stageMenuBtn=document.getElementById('stageMenuBtn');
    const bookMenuBtn=document.getElementById('bookMenuBtn');
    const bookMenuPanel=document.getElementById('bookMenuPanel');
    const menuDragHandle=document.getElementById('menuDragHandle');
    const menuCloseBtn=document.getElementById('menuCloseBtn');
    const menuActionsContainer=document.getElementById('menuActions');
    const memoMiniBtn=document.getElementById('memoMiniBtn');
    const memoWindow=document.getElementById('memoWindow');
    const memoWindowInput=document.getElementById('memoWindowInput');
    const memoWindowDrag=document.getElementById('memoWindowDrag');
    const memoWindowClose=document.getElementById('memoWindowClose');
    const answerDockBtn=document.getElementById('boxAnswerDockBtn');
    const answerDockFloatBtn=document.getElementById('boxAnswerDockFloatBtn');
    const answerWindow=document.getElementById('boxAnswerWindow');
    const answerWindowBtn=document.getElementById('answerWindowBtn');
    const answerWindowDrag=document.getElementById('boxAnswerDrag');
    const answerWindowClose=document.getElementById('boxAnswerClose');
    const answerTransparentBtn=document.getElementById('boxAnswerTransparent');
    const answerImg=document.getElementById('boxAnswerImg');
    const answerMeta=document.getElementById('boxAnswerMeta');
    const answerPlaceholder=document.getElementById('boxAnswerPlaceholder');
    const answerZoomLockBtn=document.getElementById('boxAnswerZoomLock');
    const answerPanLockBtn=document.getElementById('boxAnswerPanLock');
    const answerMinimizeBtn=document.getElementById('boxAnswerMinimize');
    const memoToggle=document.getElementById('memoToggle');
    const memoBody=document.getElementById('memoBody');
    const pageMemo=document.getElementById('pageMemo');
    const stFav=document.getElementById('stFav');
    const stWeak=document.getElementById('stWeak');
    const stDone=document.getElementById('stDone');
    const customArea=document.getElementById('customStateArea');
    const addStateBtn=document.getElementById('addState');
    const customFilter=document.getElementById('customFilter');
    const filterSelect=document.getElementById('filterSelect');
    const prevBtn=document.getElementById('prevBtn');
    const nextBtn=document.getElementById('nextBtn');
    const jumpInput=document.getElementById('jumpInput');
    const jumpGo=document.getElementById('jumpGo');
    const fitContain=document.getElementById('fitContain');
    const fitWidth=document.getElementById('fitWidth');
    const thumbList=document.getElementById('thumbList');
    const idxInfo=document.getElementById('idxInfo');
    const multiToggle=document.getElementById('multiToggle');
    const multiAll=document.getElementById('multiAll');
    const multiNone=document.getElementById('multiNone');
    const multiDelete=document.getElementById('multiDelete');
    const multiSet=document.getElementById('multiSet');
    const controlResizer=document.getElementById('controlResizer');

    const VIEWER_STATE_KEYS={
      zoomLock:'viewer-zoom-lock',
      panLock:'viewer-pan-lock',
      sliceView:'viewer-slice-view'
    };
    const viewState={zoom:1,minZoom:0.4,maxZoom:6,translateX:0,translateY:0,userAdjusted:false};
    let zoomLocked=loadStoredBool(VIEWER_STATE_KEYS.zoomLock,false);
    let panLocked=loadStoredBool(VIEWER_STATE_KEYS.panLock,false);
    let sliceMode=loadStoredBool(VIEWER_STATE_KEYS.sliceView,false);
    let menuOpen=false;
    let memoWindowOpen=false;
    let answerWindowOpen=false;
    let answerMinimized=false;
    let answerZoomLocked=false;
    let answerPanLocked=false;
    const ANSWER_WINDOW_POS_KEY='box-answer-window-pos';
    const ANSWER_WINDOW_TRANSPARENT_KEY='box-answer-window-transparent';
    let answerWindowPos=loadStoredJSON(ANSWER_WINDOW_POS_KEY);
    let answerTransparent=loadStoredBool(ANSWER_WINDOW_TRANSPARENT_KEY,false);
    const answerView={zoom:1,minZoom:0.4,maxZoom:6,translateX:0,translateY:0};
    let hintTimer=null;
    let stageSurface=null;
    let controlWidth=parseFloat(localStorage.getItem('viewer-control-width')||'340')||340;
    let idx=0, filter='all', customFilterId='', multi=false;
    const selected=new Set();
    const savedView = getLastBoxView();
    if(savedView && savedView.boxId===box.id){
      idx = Math.max(0, Math.min((box.snippets?.length||1)-1, savedView.index||0));
    }
    // start unlocked to avoid carrying over locked state from book viewer
    zoomLocked=false;
    panLocked=false;

    function pointerClientXY(ev){
      if(ev.touches && ev.touches.length){ return {x:ev.touches[0].clientX, y:ev.touches[0].clientY}; }
      if(ev.changedTouches && ev.changedTouches.length){ return {x:ev.changedTouches[0].clientX, y:ev.changedTouches[0].clientY}; }
      return {x:ev.clientX, y:ev.clientY};
    }
    function applyControlWidth(){
      wrap.style.setProperty('--control-width', `${controlWidth}px`);
    }
    applyControlWidth();
    const startResize=(clientX)=>{
      const rect=wrap.getBoundingClientRect();
      const min=240, max=Math.max(280, rect.width*0.55);
      const onMove=(x)=>{
        const relative = rect.right - x;
        controlWidth = Math.min(max, Math.max(min, relative));
        applyControlWidth();
      };
      const moveHandler=(e)=>{ e.preventDefault(); onMove(e.clientX); };
      const upHandler=()=>{
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', upHandler);
        try{ localStorage.setItem('viewer-control-width', String(controlWidth)); }catch(err){}
      };
      document.addEventListener('mousemove', moveHandler);
      document.addEventListener('mouseup', upHandler);
      onMove(clientX);
    };
    controlResizer?.addEventListener('mousedown',(e)=>{ e.preventDefault(); startResize(e.clientX); });

    function clampBoxPanelPosition(panel,left,top){
      const viewerRect=wrap.getBoundingClientRect();
      const panelRect=panel.getBoundingClientRect();
      const width=panelRect.width||panel.offsetWidth||320;
      const height=panelRect.height||panel.offsetHeight||220;
      const barRect=document.querySelector('.topbar')?.getBoundingClientRect();
      const minTop = Math.max(
        0,
        (barRect?.bottom ?? 0) - viewerRect.top + 8
      );
      const minLeft = -width*0.2;
      const maxLeft = viewerRect.width - width*0.2;
      const maxTop = viewerRect.height - height*0.2;
      return {
        left:Math.max(minLeft, Math.min(left, maxLeft)),
        top:Math.max(minTop, Math.min(top, maxTop))
      };
    }
    function makeDraggable(panel, handle, {onMove}={}){
      if(!panel || !handle) return;
      let dragging=false;
      let offsetX=0, offsetY=0;
      const move=(clientX,clientY)=>{
        if(!dragging) return;
        const viewerRect=wrap.getBoundingClientRect();
        let left=clientX - offsetX - viewerRect.left;
        let top=clientY - offsetY - viewerRect.top;
        const clamped=clampBoxPanelPosition(panel,left,top);
        panel.style.left=`${clamped.left}px`;
        panel.style.top=`${clamped.top}px`;
        onMove?.(clamped.left, clamped.top);
      };
      const end=()=>{
        if(!dragging) return;
        dragging=false;
        panel.classList.remove('dragging');
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        document.removeEventListener('touchmove', onTouchMove);
        document.removeEventListener('touchend', onTouchEnd);
      };
      const start=(clientX,clientY)=>{
        const rect=panel.getBoundingClientRect();
        offsetX=clientX-rect.left;
        offsetY=clientY-rect.top;
        dragging=true;
        panel.classList.add('dragging');
      };
      const onMouseMove=(e)=>move(e.clientX,e.clientY);
      const onMouseUp=()=>end();
      const onTouchMove=(e)=>{ const {x,y}=pointerClientXY(e); move(x,y); e.preventDefault(); };
      const onTouchEnd=()=>end();
      handle.addEventListener('mousedown',(e)=>{
        if(e.button!==0) return;
        if(e.target.closest('button, input, select, textarea')) return;
        e.preventDefault();
        start(e.clientX,e.clientY);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
      handle.addEventListener('touchstart',(e)=>{
        if(e.target.closest('button, input, select, textarea')) return;
        const {x,y}=pointerClientXY(e);
        start(x,y);
        e.preventDefault();
        document.addEventListener('touchmove', onTouchMove,{passive:false});
        document.addEventListener('touchend', onTouchEnd);
      },{passive:false});
    }

    function applyView(){
      if(!pageImg) return;
      pageImg.style.transformOrigin='center center';
      pageImg.style.transform=`translate(${viewState.translateX}px,${viewState.translateY}px) scale(${viewState.zoom})`;
    }
    function hideInteractionHint(){
      if(!interactionHint) return;
      interactionHint.classList.add('hidden');
      if(hintTimer){ clearTimeout(hintTimer); hintTimer=null; }
    }
    function showInteractionHint(){
      if(!interactionHint) return;
      interactionHint.classList.remove('hidden');
      if(hintTimer){ clearTimeout(hintTimer); }
      hintTimer=setTimeout(()=>interactionHint.classList.add('hidden'), 3500);
    }
    function updateHintText(){
      if(!interactionHint) return;
      let text='';
      if(zoomLocked && panLocked){
        text='ズーム＆移動ロック中';
      }else if(zoomLocked){
        text='ズーム固定: ホイール＝上下移動 / ドラッグ＝移動';
      }else if(panLocked){
        text='移動ロック: ホイール＝ズーム / ドラッグ不可';
      }else{
        text='ホイール＝ズーム / ドラッグ＝移動 / ダブルクリック＝リセット';
      }
      interactionHint.textContent=text;
    }
    function applySliceViewState(){
      stageHost?.classList.toggle('slice-view', sliceMode);
      if(sliceViewBtn){
        sliceViewBtn.classList.toggle('active', sliceMode);
        sliceViewBtn.setAttribute('aria-pressed', sliceMode?'true':'false');
        sliceViewBtn.textContent = sliceMode ? '半切✓' : '半切';
      }
    }
    function updateLockButtons(){
      if(zoomLockBtn){
        zoomLockBtn.classList.toggle('active', zoomLocked);
        zoomLockBtn.textContent = zoomLocked ? '🔒ズ' : '🔓ズ';
        zoomLockBtn.setAttribute('aria-pressed', zoomLocked?'true':'false');
      }
      if(panLockBtn){
        panLockBtn.classList.toggle('active', panLocked);
        panLockBtn.textContent = panLocked ? '🔒移' : '🔓移';
        panLockBtn.setAttribute('aria-pressed', panLocked?'true':'false');
      }
      stage?.classList.toggle('pan-disabled', panLocked);
      updateHintText();
      updateQuickActionButtons();
    }
    function setZoomLock(next){
      zoomLocked=next;
      saveStoredBool(VIEWER_STATE_KEYS.zoomLock, zoomLocked);
      stageSurface?.cancel?.();
      updateLockButtons();
      showInteractionHint();
    }
    function setPanLock(next){
      panLocked=next;
      saveStoredBool(VIEWER_STATE_KEYS.panLock, panLocked);
      if(panLocked) stageSurface?.cancel?.();
      updateLockButtons();
      showInteractionHint();
    }
    function setSliceView(next){
      sliceMode=next;
      saveStoredBool(VIEWER_STATE_KEYS.sliceView, sliceMode);
      applySliceViewState();
      updateQuickActionButtons();
    }
    function resetView({toast=false}={}){
      viewState.zoom=1;
      viewState.translateX=0;
      viewState.translateY=0;
      viewState.userAdjusted=false;
      applyView();
      hideInteractionHint();
      if(toast && window.showToast) showToast('ビューをリセット','ok');
    }
    window.__viewerResetView = ({toast=false}={})=>resetView({toast});
    function setZoom(value,{anchor=null,silent=false}={}){
      const prev=viewState.zoom||1;
      const target=Math.max(viewState.minZoom, Math.min(viewState.maxZoom, value));
      const pivot=anchor||{x:0,y:0};
      if(prev!==target){
        const ratio=target/prev;
        viewState.translateX = pivot.x - ratio*(pivot.x - viewState.translateX);
        viewState.translateY = pivot.y - ratio*(pivot.y - viewState.translateY);
      }
      viewState.zoom=target;
      if(!silent) viewState.userAdjusted=true;
      applyView();
      hideInteractionHint();
    }
    function getStageLayoutOffset(){
      if(!stage || !pageImg) return {x:0,y:0};
      const parent=pageImg.offsetParent;
      const stageRect=stage.getBoundingClientRect?.();
      const parentRect=parent?.getBoundingClientRect?.();
      if(!stageRect || !parentRect) return {x:0,y:0};
      const layoutCenterX=parentRect.left + pageImg.offsetLeft + (pageImg.offsetWidth||0)/2;
      const layoutCenterY=parentRect.top + pageImg.offsetTop + (pageImg.offsetHeight||0)/2;
      const stageCenterX=stageRect.left + stageRect.width/2;
      const stageCenterY=stageRect.top + stageRect.height/2;
      return {x:layoutCenterX - stageCenterX, y:layoutCenterY - stageCenterY};
    }
    function stageAnchorFromClient(clientX, clientY){
      const rect=stage?.getBoundingClientRect?.();
      if(!rect) return {x:0,y:0};
      const baseOffset=getStageLayoutOffset();
      const centerX=rect.left + rect.width/2;
      const centerY=rect.top + rect.height/2;
      return {x:clientX-centerX - baseOffset.x, y:clientY-centerY - baseOffset.y};
    };
    const panZoomSurface = getPanZoomSurface();
    if(panZoomSurface){
      stageSurface = panZoomSurface({
        element:stage,
        anchorFromClient:stageAnchorFromClient,
        getEnabled:()=>!!(box.snippets?.length),
        getZoom:()=>viewState.zoom,
    setZoom:(next,{anchor}={})=>setZoom(next,{anchor, skipClamp:!keyNavConfig.bookClamp}),
        getZoomLocked:()=>zoomLocked,
        getPanLocked:()=>panLocked,
        applyPanDelta:(dx,dy)=>{
          viewState.translateX+=dx;
          viewState.translateY+=dy;
          applyView();
        },
        onPanStart:()=>stage?.classList.add('is-panning'),
        onPanEnd:()=>stage?.classList.remove('is-panning'),
        onReset:()=>resetView(),
        shouldIgnoreTarget:(target)=>!!(
          target.closest('.mini-menu') ||
          target.closest('.stage-buttons') ||
          target.closest('.stage-arrows') ||
          target.closest('.book-menu')
        )
      });
    }

    // ---- Keyboard pan/zoom for box viewer
    const isTypingTarget=(el)=>{
      if(!el) return false;
      if(el.closest('input, textarea, select')) return true;
      if(el.isContentEditable) return true;
      return false;
    };
  const easeSmooth=(t)=> t<0.5 ? 2*t*t : 1-Math.pow(-2*t+2,2)/2; // legacy
  const PAN_DURATION=320;
  const ZOOM_DURATION=280;
  const PAN_DECAY=0.996;
  const ZOOM_DECAY=0.996;
    let panAnimId=null, panLastTs=0;
    let panVel={x:0,y:0};
    const runSmoothPan=(dx,dy,dt=16)=>{
      if(panLocked) return;
      const base=keyNavConfig.panStep||DEFAULT_KEY_NAV_CONFIG.panStep;
      const zoomScale=1 + Math.max(0, viewState.zoom-1)*0.7;
      const distX=dx*base*zoomScale;
      const distY=dy*base*zoomScale;
      const impulse=(dt/16)/Math.max(75, PAN_DURATION);
      panVel.x += distX*impulse;
      panVel.y += distY*impulse;
      if(panAnimId){ return; }
      const step=(ts)=>{
        if(!panLastTs) panLastTs=ts;
        const dt=Math.min(48, ts-panLastTs||0);
        panLastTs=ts;
        viewState.translateX+=panVel.x*dt;
        viewState.translateY+=panVel.y*dt;
        applyView();
        const decay=Math.pow(PAN_DECAY, dt);
        panVel.x*=decay;
        panVel.y*=decay;
        if(Math.abs(panVel.x)+Math.abs(panVel.y) < 0.001){
          panVel={x:0,y:0};
          panLastTs=0;
          panAnimId=null;
          return;
        }
        panAnimId=requestAnimationFrame(step);
      };
      panAnimId=requestAnimationFrame(step);
    };
    let zoomAnimId=null, zoomLastTs=0;
    let zoomVel=0;
    const runSmoothZoom=(direction,dt=16)=>{
      if(zoomLocked) return;
      const stepVal=keyNavConfig.zoomStep||DEFAULT_KEY_NAV_CONFIG.zoomStep;
      const factor=direction>0 ? stepVal : 1/(1 + (stepVal-1)*0.6);
      const targetZoom=Math.max(viewState.minZoom, Math.min(viewState.maxZoom, viewState.zoom*factor));
      const startZoom=viewState.zoom;
      const deltaZoom=targetZoom-startZoom;
      if(Math.abs(deltaZoom)<0.0001) return;
      const impulse=(dt/16)/Math.max(70, ZOOM_DURATION);
      zoomVel += deltaZoom*impulse;
      if(zoomAnimId){ return; }
      const step=(ts)=>{
        if(!zoomLastTs) zoomLastTs=ts;
        const dt=Math.min(48, ts-zoomLastTs||0);
        zoomLastTs=ts;
        const next=viewState.zoom + zoomVel*dt;
        setZoom(next,{anchor:{x:0,y:0},silent:false,skipClamp:!keyNavConfig.bookClamp});
        const decay=Math.pow(ZOOM_DECAY, dt);
        zoomVel*=decay;
        if(Math.abs(zoomVel)<0.000005){
          zoomVel=0;
          zoomLastTs=0;
          zoomAnimId=null;
          return;
        }
        zoomAnimId=requestAnimationFrame(step);
      };
      zoomAnimId=requestAnimationFrame(step);
    };
    const normKeys=(arr, fallback)=>Array.isArray(arr)?arr:fallback;
    const matchKey=(e, keys, codes)=> keys.includes(e.key) || codes.includes(e.code);
    const getKeyBindings=()=>{
      return {
        panLeftKeys:normKeys(keyNavConfig.panLeftKeys, DEFAULT_KEY_NAV_CONFIG.panLeftKeys),
        panRightKeys:normKeys(keyNavConfig.panRightKeys, DEFAULT_KEY_NAV_CONFIG.panRightKeys),
        panUpKeys:normKeys(keyNavConfig.panUpKeys, DEFAULT_KEY_NAV_CONFIG.panUpKeys),
        panDownKeys:normKeys(keyNavConfig.panDownKeys, DEFAULT_KEY_NAV_CONFIG.panDownKeys),
        zoomInKeys:normKeys(keyNavConfig.zoomInKeys, DEFAULT_KEY_NAV_CONFIG.zoomInKeys),
        zoomInCodes:normKeys(keyNavConfig.zoomInCodes, DEFAULT_KEY_NAV_CONFIG.zoomInCodes),
        zoomOutKeys:normKeys(keyNavConfig.zoomOutKeys, DEFAULT_KEY_NAV_CONFIG.zoomOutKeys),
        zoomOutCodes:normKeys(keyNavConfig.zoomOutCodes, DEFAULT_KEY_NAV_CONFIG.zoomOutCodes),
        resetKeys:normKeys(keyNavConfig.resetKeys, DEFAULT_KEY_NAV_CONFIG.resetKeys),
        resetCodes:normKeys(keyNavConfig.resetCodes, DEFAULT_KEY_NAV_CONFIG.resetCodes)
      };
    };
    const holdTimers=new Map();
    const heldFns=new Map();
    let heldRaf=null, heldLastTs=0;
    const pumpHeld=(ts)=>{
      if(!heldLastTs) heldLastTs=ts;
      const dt=Math.min(60, ts-heldLastTs||0);
      heldLastTs=ts;
      heldFns.forEach(fn=>fn(dt));
      if(!heldFns.size){ heldRaf=null; heldLastTs=0; return; }
      heldRaf=requestAnimationFrame(pumpHeld);
    };
    const startHold=(key,fn)=>{
      if(heldFns.has(key)) return;
      heldFns.set(key,(dt)=>fn(dt||16));
      fn(16);
      if(!heldRaf) heldRaf=requestAnimationFrame(pumpHeld);
    };
    const stopHold=(key)=>{
      heldFns.delete(key);
      if(!heldFns.size && heldRaf){ cancelAnimationFrame(heldRaf); heldRaf=null; heldLastTs=0; }
    };
    const clearAllHolds=()=>{
      heldFns.clear();
      if(heldRaf){ cancelAnimationFrame(heldRaf); heldRaf=null; }
      heldLastTs=0;
    };
    const handleKeyboardNav=(e)=>{
      if(state.viewerContext!=='box') return;
      if(isTypingTarget(e.target)) return;
      const {
        panLeftKeys,panRightKeys,panUpKeys,panDownKeys,
        zoomInKeys,zoomInCodes,zoomOutKeys,zoomOutCodes,resetKeys,resetCodes
      } = getKeyBindings();
      const normKey=(s)=> (s||'').toLowerCase().trim();
      const match=(keys,codes)=> keys.map(normKey).includes(normKey(e.key)) || codes.map(normKey).includes(normKey(e.code));
      let handled=false;
      if(match(panLeftKeys, [])){ startHold('panLeft',(dt)=>runSmoothPan(1,0,dt)); handled=true; }
      else if(match(panRightKeys, [])){ startHold('panRight',(dt)=>runSmoothPan(-1,0,dt)); handled=true; }
      else if(match(panUpKeys, [])){ startHold('panUp',(dt)=>runSmoothPan(0,1,dt)); handled=true; }
      else if(match(panDownKeys, [])){ startHold('panDown',(dt)=>runSmoothPan(0,-1,dt)); handled=true; }
      else if(match(zoomInKeys, zoomInCodes)){ startHold('zoomIn',(dt)=>runSmoothZoom(1,dt)); handled=true; }
      else if(match(zoomOutKeys, zoomOutCodes)){ startHold('zoomOut',(dt)=>runSmoothZoom(-1,dt)); handled=true; }
      else if(match(resetKeys, resetCodes)){ resetView({toast:false}); triggerResetFlash(stageDual); handled=true; }
      if(handled){
        e.preventDefault();
        e.stopPropagation();
      }
    };
    const handleKeyboardNavUp=(e)=>{
      stopHold(e.key);
      const {
        panLeftKeys,panRightKeys,panUpKeys,panDownKeys,
        zoomInKeys,zoomInCodes,zoomOutKeys,zoomOutCodes,resetKeys,resetCodes
      } = getKeyBindings();
      if(matchKey(e, panLeftKeys, [])) stopHold('panLeft');
      if(matchKey(e, panRightKeys, [])) stopHold('panRight');
      if(matchKey(e, panUpKeys, [])) stopHold('panUp');
      if(matchKey(e, panDownKeys, [])) stopHold('panDown');
      if(matchKey(e, zoomInKeys, zoomInCodes)) stopHold('zoomIn');
      if(matchKey(e, zoomOutKeys, zoomOutCodes)) stopHold('zoomOut');
    };
    if(window.__boxKeyboardNav){
      document.removeEventListener('keydown', window.__boxKeyboardNav);
    }
    if(window.__boxKeyboardNavUp){
      document.removeEventListener('keyup', window.__boxKeyboardNavUp);
    }
    window.__boxKeyboardNav = handleKeyboardNav;
    window.__boxKeyboardNavUp = handleKeyboardNavUp;
    document.addEventListener('keydown', handleKeyboardNav);
    document.addEventListener('keyup', handleKeyboardNavUp);
    window.addEventListener('blur', clearAllHolds);

    function setFit(mode){
      if(mode==='contain'){ pageImg.style.maxWidth='100%'; pageImg.style.width=''; }
      if(mode==='width'){ pageImg.style.maxWidth='none'; pageImg.style.width='100%'; }
      resetView();
    }

    function refreshCustomControls(){
      customArea.innerHTML='';
      customFilter.innerHTML='<option value=\"\">カスタム状態（任意）</option>';
      (box.customStates||[]).forEach(cs=>{
        const span=document.createElement('label'); span.className='tag';
        span.style.borderColor=cs.color||'#2a3a55';
        span.innerHTML=`<input type="checkbox" data-cs="${cs.id}"> ${cs.name} <span class="x" data-delcs="${cs.id}">✕</span>`;
        customArea.appendChild(span);
        const opt=document.createElement('option'); opt.value=cs.id; opt.textContent=cs.name; customFilter.appendChild(opt);
      });
    }
    refreshCustomControls();

    function matchFilter(s){
      if(customFilterId){ return (s.state?.extra||[]).includes(customFilterId); }
      if(filter==='all') return True;
      if(filter==='fav') return s.state?.fav;
      if(filter==='weak') return s.state?.weak;
      if(filter==='done') return s.state?.done;
      if(filter==='undone') return !s.state?.done;
      if(filter==='hasMemo') return (s.memo||'').trim().length>0;
      return true;
    }

    function updateThumbs(){
      thumbList.innerHTML='';
      const shown = (box.snippets||[]).map((s,i)=>({s,i})).filter(({s})=>matchFilter(s));
      shown.forEach(({s,i})=>{
        const it=document.createElement('div'); it.className='item'+(i===idx?' active':'');
        it.draggable=true; it.dataset.idx=i;
        const marks=[s.state?.fav?'★':'', s.state?.weak?'×':'', s.state?.done?'✓':''].filter(Boolean).join(' ');
        const tags=(s.state?.extra||[]).map(id=>{
          const cs=(box.customStates||[]).find(c=>c.id===id); return cs?cs.name:'';
        }).filter(Boolean);
        const tagHtml = tags.slice(0,2).map(n=>`<span class="tag">${n}</span>`).join(' ') + (tags.length>2? ` <span class="muted">+${tags.length-2}</span>`:'');

        it.innerHTML=`${multi?`<input type='checkbox' class='sel' ${selected.has(i)?'checked':''} data-sel='${i}'>`:''}
          <span class="pill">${i+1}</span> <span class="muted">${marks}</span>
          <span>${(window.escapeHTML?escapeHTML:(s=>s))(s.name||('切り抜き'+(i+1)))}</span>
          ${tagHtml} <span class="muted">${(s.memo||'').slice(0,14)}</span>`;
        it.onclick=(e)=>{
          if(e.target.classList.contains('sel')){
            const ix=+e.target.getAttribute('data-sel');
            if(e.target.checked) selected.add(ix); else selected.delete(ix);
          }else{ idx=i; load(); }
        };
        it.ondragstart=(e)=>{ e.dataTransfer.setData('text/plain', i); };
        it.ondragover=(e)=>{ e.preventDefault(); it.classList.add('dragover'); };
        it.ondragleave=()=> it.classList.remove('dragover');
        it.ondrop=(e)=>{
          e.preventDefault(); it.classList.remove('dragover');
          const from=+e.dataTransfer.getData('text/plain'); const to=i;
          if(Number.isNaN(from) || from===to) return;
          const item=box.snippets.splice(from,1)[0];
          box.snippets.splice(to,0,item);
          if(window.Box && Box.put) Box.put(box).then(()=>{ idx=to; load(); if(window.showToast) showToast('並べ替えました','ok'); });
        };
        thumbList.appendChild(it);
      });
    }

    function syncMemoFields(value, source){
      if(pageMemo && source!=='main') pageMemo.value=value;
      if(memoWindowInput && source!=='window') memoWindowInput.value=value;
    }
    async function commitMemo(value){
      if(!box.snippets[idx]) return;
      box.snippets[idx].memo=value;
      if(window.Box && Box.put) await Box.put(box);
      updateThumbs();
    }

    function load(){
      if(!box.snippets.length){
        pageImg.src=''; pageBadge.textContent=''; thumbList.innerHTML=''; idxInfo.textContent='';
        resetView(); return;
      }
      idx = Math.max(0, Math.min(idx, box.snippets.length-1));
      setLastBoxView(box.id, idx);
      const s = box.snippets[idx];
      pageImg.src = s.dataUrl || '';
      pageBadge.textContent = `${idx+1}/${box.snippets.length}`;
      stFav.checked = !!s.state?.fav;
      stWeak.checked = !!s.state?.weak;
      stDone.checked = !!s.state?.done;
      syncMemoFields(s.memo||'', null);
    if(answerWindowOpen && !hasLinkedAnswer()) answerWindowOpen=false;
    if(answerMinimized && !answerWindowOpen) answerMinimized=false;
    updateAnswerWindow();
      customArea.querySelectorAll('[data-cs]').forEach(chk=>{
        const id=chk.getAttribute('data-cs');
        const arr = Array.isArray(s.state?.extra) ? s.state.extra : (s.state.extra=[]);
        chk.checked = arr.includes(id);
        chk.onchange = async ()=>{
          const a = Array.isArray(s.state.extra) ? s.state.extra : (s.state.extra=[]);
          if(chk.checked){ if(!a.includes(id)) a.push(id); }
          else{ const i=a.indexOf(id); if(i>=0) a.splice(i,1); }
          if(window.Box && Box.put) await Box.put(box);
          updateThumbs();
        };
      });

      updateThumbs();
      idxInfo.textContent = `#${idx+1}`;
      updateQuickActionButtons();
    }

    pageImg?.addEventListener('load',()=>{ resetView(); });
    stagePrevArrow?.addEventListener('click',()=>{ if(!box.snippets.length) return; idx=Math.max(0,idx-1); load(); });
    stageNextArrow?.addEventListener('click',()=>{ if(!box.snippets.length) return; idx=Math.min(box.snippets.length-1,idx+1); load(); });
    prevBtn?.addEventListener('click',()=>{ if(!box.snippets.length) return; idx=Math.max(0,idx-1); load(); });
    nextBtn?.addEventListener('click',()=>{ if(!box.snippets.length) return; idx=Math.min(box.snippets.length-1,idx+1); load(); });
    jumpGo?.addEventListener('click',()=>{
      const v=parseInt(jumpInput?.value||'',10);
      if(!isNaN(v)){ idx=Math.max(0, Math.min(box.snippets.length-1, v-1)); load(); }
    });

    fitContain?.addEventListener('click',()=>setFit('contain'));
    fitWidth?.addEventListener('click',()=>setFit('width'));
    zoomLockBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); setZoomLock(!zoomLocked); });
    panLockBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); setPanLock(!panLocked); });
    sliceViewBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); setSliceView(!sliceMode); });

    pageMemo?.addEventListener('input',()=>{ syncMemoFields(pageMemo.value,'main'); });
    pageMemo?.addEventListener('change',()=>commitMemo(pageMemo.value));
    memoWindowInput?.addEventListener('input',()=>{ syncMemoFields(memoWindowInput.value,'window'); });
    memoWindowInput?.addEventListener('change',()=>commitMemo(memoWindowInput.value));

    memoToggle?.addEventListener('click',()=>{
      if(!memoBody) return;
      const nowHidden=memoBody.classList.toggle('hidden');
      memoToggle.textContent=nowHidden?'メモ欄を開く':'メモ欄を閉じる';
      updateQuickActionButtons();
    });
    function setMemoWindow(open){
      if(!memoWindow) return;
      memoWindowOpen=open;
      memoWindow.classList.toggle('open', open);
      updateQuickActionButtons();
    }
    memoMiniBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); setMemoWindow(!memoWindowOpen); });
    memoWindowClose?.addEventListener('click',()=>setMemoWindow(false));
    function hasLinkedAnswer(){
      const s=box.snippets[idx];
      return !!(s && s.answer && s.answer.dataUrl);
    }
    function updateAnswerLockButtons(){
      if(answerZoomLockBtn){
        answerZoomLockBtn.classList.toggle('active', answerZoomLocked);
        answerZoomLockBtn.textContent = answerZoomLocked ? '🔒ズ' : '🔓ズ';
        answerZoomLockBtn.setAttribute('aria-pressed', answerZoomLocked?'true':'false');
      }
      if(answerPanLockBtn){
        answerPanLockBtn.classList.toggle('active', answerPanLocked);
        answerPanLockBtn.textContent = answerPanLocked ? '🔒移' : '🔓移';
        answerPanLockBtn.setAttribute('aria-pressed', answerPanLocked?'true':'false');
      }
    }
    function setAnswerZoomLock(next){
      answerZoomLocked=next;
      updateAnswerLockButtons();
    }
    function setAnswerPanLock(next){
      answerPanLocked=next;
      if(answerPanLocked) answerStageSurface?.cancel?.();
      updateAnswerLockButtons();
    }
    let answerStageSurface=null;
    function applyAnswerView(){
      if(!answerImg) return;
      answerImg.style.transformOrigin='center center';
      answerImg.style.transform=`translate(${answerView.translateX}px,${answerView.translateY}px) scale(${answerView.zoom})`;
    }
    function resetAnswerView(){
      answerView.zoom=1; answerView.translateX=0; answerView.translateY=0;
      applyAnswerView();
    }
    function rememberAnswerWindowPosition(){
      const viewerRect=wrap.getBoundingClientRect();
      const rect=answerWindow?.getBoundingClientRect();
      if(!rect || !answerWindow) return;
      const clamped=clampBoxPanelPosition(answerWindow, rect.left-viewerRect.left, rect.top-viewerRect.top);
      answerWindowPos=clamped;
      saveStoredJSON(ANSWER_WINDOW_POS_KEY, answerWindowPos);
    }
    function applyAnswerWindowPosition(pos){
      if(!answerWindow || !pos || Number.isNaN(pos.left) || Number.isNaN(pos.top)) return;
      const clamped=clampBoxPanelPosition(answerWindow, pos.left, pos.top);
      answerWindow.style.left=`${clamped.left}px`;
      answerWindow.style.top=`${clamped.top}px`;
      answerWindowPos=clamped;
      saveStoredJSON(ANSWER_WINDOW_POS_KEY, answerWindowPos);
    }
    function setAnswerTransparent(next){
      answerTransparent=!!next;
      saveStoredBool(ANSWER_WINDOW_TRANSPARENT_KEY, answerTransparent);
      updateAnswerWindow();
    }
    function updateAnswerDockUI(){
      const showDock = answerWindowOpen && answerMinimized;
      answerDockBtn?.classList.toggle('hidden', !showDock);
      answerDockFloatBtn?.classList.toggle('hidden', !showDock);
    }
    function updateAnswerWindow(){
      const s=box.snippets[idx];
      const has=hasLinkedAnswer();
      if(answerWindowBtn){
        answerWindowBtn.disabled=!has;
        answerWindowBtn.textContent = has ? (answerWindowOpen?'解答を閉じる':'解答を見る') : '解答なし';
      }
      if(!answerWindow || !answerImg || !answerMeta || !answerPlaceholder){
        return;
      }
      if(!has){
        answerWindow.classList.remove('open');
        answerWindow.classList.remove('has-book');
        answerWindow.classList.remove('minimized');
        answerImg.removeAttribute('src');
        answerPlaceholder.textContent='紐付け解答なし';
        answerMeta.textContent='紐付け解答なし';
        answerWindowOpen=false;
        return;
      }
      answerImg.src = s.answer.dataUrl;
      const meta = s.answer.meta||{};
      const real = (meta.firstPage||1)+(meta.pageIndex||0);
      answerMeta.textContent = `${real}p`;
      answerPlaceholder.textContent='';
      answerWindow.classList.toggle('open', answerWindowOpen && !answerMinimized);
      answerWindow.classList.toggle('has-book', true);
      answerWindow.classList.toggle('minimized', answerMinimized);
      answerWindow.classList.toggle('transparent', answerTransparent);
      if(answerTransparentBtn){
        answerTransparentBtn.classList.toggle('active', answerTransparent);
        answerTransparentBtn.textContent = answerTransparent ? '透明ON' : '透明';
        answerTransparentBtn.setAttribute('aria-pressed', answerTransparent?'true':'false');
      }
      if(answerWindowOpen && !answerMinimized){
        if(answerWindowPos) applyAnswerWindowPosition(answerWindowPos);
        resetAnswerView();
      }
      updateAnswerDockUI();
    }
    function setAnswerWindow(open){
      answerWindowOpen = open && hasLinkedAnswer();
      answerMinimized=false;
      updateAnswerWindow();
    }
    answerWindowBtn?.addEventListener('click',()=>{ if(answerWindowBtn.disabled) return; setAnswerWindow(!answerWindowOpen); });
    boxAnswerQuickBtn?.addEventListener('click',(e)=>{ 
      e.stopPropagation(); 
      if(!hasLinkedAnswer()){ window.showToast && showToast('紐付け解答がありません','error'); return; }
      setAnswerWindow(!answerWindowOpen); 
    });
    answerWindowClose?.addEventListener('click',()=>setAnswerWindow(false));
    const restoreAnswerWindow=()=>{
      if(!answerWindowOpen) setAnswerWindow(true);
      answerMinimized=false;
      updateAnswerWindow();
    };
    answerMinimizeBtn?.addEventListener('click',()=>{
      if(!hasLinkedAnswer()) return;
      if(!answerMinimized) rememberAnswerWindowPosition();
      answerMinimized=!answerMinimized;
      updateAnswerWindow();
    });
    answerDockBtn?.addEventListener('click',restoreAnswerWindow);
    answerDockFloatBtn?.addEventListener('click',(e)=>{ e?.preventDefault?.(); e?.stopPropagation?.(); restoreAnswerWindow(); });
    answerTransparentBtn?.addEventListener('click',()=>setAnswerTransparent(!answerTransparent));
    answerZoomLockBtn?.addEventListener('click',()=>setAnswerZoomLock(!answerZoomLocked));
    answerPanLockBtn?.addEventListener('click',()=>setAnswerPanLock(!answerPanLocked));
    if(answerWindow){
      const panZoomSurface = getPanZoomSurface();
      const answerStage=document.getElementById('boxAnswerStage');
      const answerAnchorFromClient=(clientX,clientY)=>{
        const rect=answerStage?.getBoundingClientRect?.();
        if(!rect) return {x:0,y:0};
        const centerX=rect.left + rect.width/2;
        const centerY=rect.top + rect.height/2;
        return {x:clientX - centerX, y:clientY - centerY};
      };
      answerStageSurface = panZoomSurface({
        element:answerStage,
        anchorFromClient:answerAnchorFromClient,
        getEnabled:()=>answerWindowOpen && !answerMinimized && hasLinkedAnswer(),
        getZoom:()=>answerView.zoom,
        setZoom:(next,{anchor}={})=>{
          const prev=answerView.zoom||1;
          const target=Math.max(answerView.minZoom, Math.min(answerView.maxZoom, next));
          const pivot=anchor||{x:0,y:0};
          if(prev!==target){
            answerView.translateX = pivot.x - (target/prev)*(pivot.x - answerView.translateX);
            answerView.translateY = pivot.y - (target/prev)*(pivot.y - answerView.translateY);
          }
          answerView.zoom=target;
          applyAnswerView();
        },
        getZoomLocked:()=>answerZoomLocked,
        getPanLocked:()=>answerPanLocked,
        applyPanDelta:(dx,dy)=>{
          answerView.translateX+=dx;
          answerView.translateY+=dy;
          applyAnswerView();
        },
        onPanStart:()=>answerStage?.classList.add('grabbing'),
        onPanEnd:()=>answerStage?.classList.remove('grabbing'),
        onReset:()=>resetAnswerView(),
        shouldIgnoreTarget:(target)=>!!(target.closest('.compare-quick') || target.closest('.mini-menu'))
      });
    }
    updateAnswerLockButtons();

    function setMenu(open){
      if(!bookMenuPanel) return;
      menuOpen=open;
      bookMenuPanel.classList.toggle('open', open);
    }
    function toggleMenu(){ setMenu(!menuOpen); }
    bookMenuBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); toggleMenu(); });
    stageMenuBtn?.addEventListener('click',(e)=>{ e.stopPropagation(); setMenu(true); });
    bookMenuPanel?.addEventListener('click',(e)=>e.stopPropagation());
    memoWindow?.addEventListener('click',(e)=>e.stopPropagation());
    menuCloseBtn?.addEventListener('click',()=>setMenu(false));

    filterSelect?.addEventListener('change',(e)=>{ filter=e.target.value; updateThumbs(); });
    customFilter?.addEventListener('change',(e)=>{ customFilterId=e.target.value; updateThumbs(); });

    addStateBtn?.addEventListener('click',()=>{
      const m=document.createElement('div'); m.className='modal'; m.style.display='flex';
      const b=document.createElement('div'); b.className='box';
      b.innerHTML=`<h3>カスタム状態を作成（ボックス）</h3>
        <input id="csNameB" class="input" placeholder="状態名" style="margin-bottom:8px"/>
        <input id="csColorB" class="input" placeholder="#カラー（任意）" />
        <div class="row space" style="margin-top:10px"><button class="btn ghost" data-close>閉じる</button><button class="btn primary" data-save>追加</button></div>`;
      m.appendChild(b); document.body.appendChild(m);
      b.querySelector('[data-close]').onclick=()=>m.remove();
      b.querySelector('[data-save]').onclick=async()=>{
        const name=b.querySelector('#csNameB').value.trim(); if(!name){if(window.showToast) showToast('名前を入れてください','error'); return;}
        const color=(b.querySelector('#csColorB').value||'').trim();
        box.customStates.push({id:(window.uuid?uuid:crypto.randomUUID)(), name, color});
        if(window.Box && Box.put) await Box.put(box);
        m.remove(); refreshCustomControls(); load();
      };
    });

    customArea.addEventListener('click', async (e)=>{
      const del=e.target.getAttribute('data-delcs'); if(!del) return;
      (box.snippets||[]).forEach(s=>{ s.state.extra = Array.isArray(s.state.extra)? s.state.extra:[]; s.state.extra = s.state.extra.filter(x=>x!==del); });
      box.customStates = (box.customStates||[]).filter(x=>x.id!==del);
      if(window.Box && Box.put) await Box.put(box);
      refreshCustomControls(); load();
    });

    multiToggle?.addEventListener('click',()=>{ multi=!multi; selected.clear(); updateThumbs(); if(window.showToast) showToast(multi?'複数選択ON':'複数選択OFF'); });
    multiAll?.addEventListener('click',()=>{ if(!multi) return; selected.clear(); for(let i=0;i<box.snippets.length;i++) selected.add(i); updateThumbs(); });
    multiNone?.addEventListener('click',()=>{ selected.clear(); updateThumbs(); });
    multiDelete?.addEventListener('click',async()=>{
      if(!selected.size) return (window.showToast && showToast('選択がありません','error'));
      if(!confirm('選択した切り抜きを削除しますか？')) return;
      const idxs=[...selected].sort((a,b)=>b-a);
      idxs.forEach(i=>box.snippets.splice(i,1));
      if(window.Box && Box.put) await Box.put(box);
      selected.clear(); idx=Math.max(0, Math.min(idx, (box.snippets.length||1)-1)); load();
      if(window.showToast) showToast('削除しました','ok');
    });
    multiSet?.addEventListener('click',()=>{
      if(!selected.size) return (window.showToast && showToast('選択がありません','error'));
      const m=document.createElement('div'); m.className='modal'; m.style.display='flex';
      const b=document.createElement('div'); b.className='box';
      const csOpts = (box.customStates||[]).map(cs=>`<label class='row' style='gap:6px'><input type='checkbox' data-bcs='${cs.id}'> ${cs.name}</label>`).join('');
      b.innerHTML=`<h3>選択の状態変更</h3>
        <label class='row' style='gap:6px'><input id='bFav' type='checkbox'> ★お気に入り</label>
        <label class='row' style='gap:6px'><input id='bWeak' type='checkbox'> ×苦手</label>
        <label class='row' style='gap:6px'><input id='bDone' type='checkbox'> ✓完了</label>
        <div class='hr' style='height:1px;background:#1d2738;margin:8px 0'></div>
        <div>カスタム状態</div>
        <div class='split' style='margin:6px 0'>${csOpts||'<span class="muted">（なし）</span>'}</div>
        <div class='row space' style='margin-top:10px'><button class='btn ghost' data-close>閉じる</button><button class='btn primary' data-apply>適用</button></div>`;
      m.appendChild(b); document.body.appendChild(m);
      b.querySelector('[data-close]').onclick=()=>m.remove();
      b.querySelector('[data-apply]').onclick=async()=>{
        const fav=b.querySelector('#bFav').checked;
        const weak=b.querySelector('#bWeak').checked;
        const done=b.querySelector('#bDone').checked;
        const extra=[...b.querySelectorAll('[data-bcs]')].filter(x=>x.checked).map(x=>x.getAttribute('data-bcs'));
        selected.forEach(i=>{ const s=box.snippets[i]; s.state.fav=fav; s.state.weak=weak; s.state.done=done; s.state.extra=extra.slice(); });
        if(window.Box && Box.put) await Box.put(box);
        m.remove(); updateThumbs(); if(window.showToast) showToast('状態を更新しました','ok');
      };
    });

    stFav?.addEventListener('change',async()=>{ if(!box.snippets[idx]) return; box.snippets[idx].state.fav=stFav.checked; if(window.Box && Box.put) await Box.put(box); updateThumbs(); });
    stWeak?.addEventListener('change',async()=>{ if(!box.snippets[idx]) return; box.snippets[idx].state.weak=stWeak.checked; if(window.Box && Box.put) await Box.put(box); updateThumbs(); });
    stDone?.addEventListener('change',async()=>{ if(!box.snippets[idx]) return; box.snippets[idx].state.done=stDone.checked; if(window.Box && Box.put) await Box.put(box); updateThumbs(); });

    makeDraggable(bookMenuPanel, menuDragHandle);
    makeDraggable(memoWindow, memoWindowDrag);
    makeDraggable(answerWindow, answerWindowDrag,{
      onMove:(left,top)=>{
        answerWindowPos={left,top};
        saveStoredJSON(ANSWER_WINDOW_POS_KEY, answerWindowPos);
      }
    });

    menuActionsContainerRef=menuActionsContainer;
    renderMenuButtons();
    updateQuickActionButtons();

    document.getElementById('renameBox')?.addEventListener('click',()=>{ if(typeof editBoxMeta==='function') editBoxMeta(box); });
    document.getElementById('backBoxes')?.addEventListener('click',()=>{ 
      stageSurface?.destroy?.();
      state.view='boxes';
      state.viewerContext=null;
      viewerMemory.box.closed=true;
      viewerMemory.box.id=null;
      setAnswerWindow(false);
      answerStageSurface?.destroy?.();
      host.innerHTML='';
      host.classList.add('hidden');
      window.__viewerResetView=null;
      menuActionsContainerRef=null;
      if(typeof showTab==='function'){ showTab('boxes'); }
    });

    applySliceViewState();
    updateLockButtons();
    updateHintText();
    setFit('contain');
    load();
    showInteractionHint();
    renderOpenTabs();
  };
})();
</script>


<!-- parity+origin+dup override -->
<script>
(function(){
  // ===== helpers =====
  const True = true;
  const esc = (window.escapeHTML?escapeHTML:(s=>String(s??'')));

  async function openSnippetSourceByIndex(box, idx){
    const s = (box&&box.snippets)? box.snippets[idx] : null;
    if(!s || !s.bookId) { window.showToast && showToast('出典情報がありません','error'); return; }
    const hasBookAPI = (typeof Book!=='undefined') && !!Book && typeof Book.get === 'function';
    if(!hasBookAPI){ window.showToast && showToast('本データにアクセスできません','error'); return; }
    const book = await Book.get(s.bookId);
    if(!book){ window.showToast && showToast('元の本が見つかりません','error'); return; }
    if(typeof window.mountBookViewer === 'function'){
      mountBookViewer(book);
      // 目的のページへジャンプ（実ページ番号で）
      const real = (book.firstPageNumber||1) + (s.pageIndex||0);
      const tryJump=()=>{
        const input = document.getElementById('jumpInput');
        const go = document.getElementById('jumpGo');
        if(input && go){
          input.value = String(real);
          go.click();
        }else{
          requestAnimationFrame(tryJump);
        }
      };
      requestAnimationFrame(tryJump);
    }
  }

  // ===== override: mountBookViewer (ensure tags appear in list) =====
  // Only override if the current implementation does NOT show custom tags in its list items.
  const prevMBV = window.mountBookViewer;
  window.mountBookViewer = function(book){
    // call original first to build DOM
    if(typeof prevMBV === 'function'){ prevMBV(book); }
    // then enhance list rows to include custom tags and real page "2p" style
    try{
      const list = document.getElementById('thumbList');
      if(!list) return;
      const cs = book.customStates || [];
      const mapName = (id)=>{ const x = cs.find(c=>c.id===id); return x? x.name : ''; };
      // Rebuild rows with tags if missing
      list.innerHTML = '';
      const realOf = (i)=> (book.firstPageNumber||1)+i;
      (book.pages||[]).forEach((p,i)=>{
        p.state = p.state || {fav:false,weak:false,done:false,extra:[]};
        if(!Array.isArray(p.state.extra)) p.state.extra=[];
        const marks=[p.state.fav?'★':'', p.state.weak?'×':'', p.state.done?'✓':''].filter(Boolean).join(' ');
        const tags=(p.state.extra||[]).map(mapName).filter(Boolean);
        const shownTags = tags.slice(0,2).map(n=>`<span class='tag'>${esc(n)}</span>`).join(' ');
        const more = tags.length>2 ? ` <span class='muted'>+${tags.length-2}</span>` : '';
        const it=document.createElement('div'); it.className='item'+(i===0?' active':'');
        it.innerHTML = `<span class="pill">${i+1}</span><span class="muted">${realOf(i)}p</span> <span class="muted">${marks}</span> ${shownTags}${more} <span class="muted">${(p.memo||'').slice(0,12)}</span>`;
        it.onclick = ()=>{
          // emulate clicking thumb to navigate: trigger existing prev/next/jump by setting global state via inputs
          const jump = document.getElementById('jumpInput');
          const go = document.getElementById('jumpGo');
          if(jump && go){ jump.value = String(realOf(i)); go.click(); }
        };
        list.appendChild(it);
      });
    }catch(e){ /* no-op enhancement failure */ }
  };

  // ===== override: mountBoxViewer (add origin info + 'open source' button) =====
  const prevMBX = window.mountBoxViewer;
  window.mountBoxViewer = function(box){
    if(typeof prevMBX === 'function'){ prevMBX(box); }
    try{
      // add origin info area under image
      const stage = document.getElementById('stageSingle') || document.querySelector('#stageSingle .stage-inner') || document.querySelector('#viewerView .stage');
      const img = document.getElementById('pageImg');
      if(stage && img && !document.getElementById('originInfoB')){
        const info = document.createElement('div');
        info.id = 'originInfoB';
        info.style.cssText = 'position:absolute;left:10px;bottom:10px;background:rgba(10,16,28,.28);border:1px solid rgba(90,122,171,.55);border-radius:8px;padding:4px 6px;font-size:11px;backdrop-filter:blur(4px);display:flex;align-items:center;gap:6px;box-shadow:0 8px 22px rgba(0,0,0,.2)';
        info.innerHTML = '<span class="muted">出典: 不明</span> <button class="btn small ghost" id="openSourceBtn" style="padding:4px 7px;font-size:11px;opacity:.9">元のページへ</button>';
        // if stage-inner exists, position relative
        const inner = stage.querySelector('.stage-inner') || stage;
        inner.style.position = 'relative';
        inner.appendChild(info);
      }
      // wiring: when snippet changes, refresh origin text
      const idxInfo = document.getElementById('idxInfo');
      async function updateOrigin(){
        const i = (idxInfo && idxInfo.textContent) ? (parseInt(idxInfo.textContent.replace('#',''))-1) : 0;
        const s = (box.snippets||[])[Math.max(0,Math.min(i,(box.snippets||[]).length-1))];
        const el = document.getElementById('originInfoB');
        if(!s || !el) return;
        if(s.bookId){
          try{
            const bk = await Book.get(s.bookId);
            const real = (bk?.firstPageNumber||1) + (s.pageIndex||0);
            el.querySelector('.muted').textContent = `出典: ${bk? (bk.title||'無題') : '不明'} / ${real}p`;
          }catch(e){
            el.querySelector('.muted').textContent = '出典: 不明';
          }
        }else{
          el.querySelector('.muted').textContent = '出典: 不明';
        }
      }
      updateOrigin();
      // hook prev/next/jump to update origin
      ['prevBtn','nextBtn','jumpGo','stagePrevArrow','stageNextArrow'].forEach(id=>{
        const b = document.getElementById(id);
        if(b && !b.__originHooked){
          b.addEventListener('click', ()=> setTimeout(updateOrigin, 30));
          b.__originHooked = true;
        }
      });
      const openBtn = document.getElementById('openSourceBtn');
      if(openBtn && !openBtn.__wired){
        openBtn.__wired = true;
        openBtn.addEventListener('click', ()=>{
          const i = (idxInfo && idxInfo.textContent) ? (parseInt(idxInfo.textContent.replace('#',''))-1) : 0;
          openSnippetSourceByIndex(box, i);
        });
      }
    }catch(e){}
  };

})();
</script>

</body>
</html>
